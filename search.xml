<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[elasticsearch安装及x-pack校验]]></title>
    <url>%2F2020%2F09%2F05%2Felasticsearch%E5%AE%89%E8%A3%85%E5%8F%8Ax-pack%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[​ 最近有地区要升级es版本，于是我在一台闲置的服务器上尝试了一下，小小的记录一下踩坑过程 简介​ Elasticsearch是一个基于Lucene库的搜索引擎。它提供了一个分布式、支持多租户的全文搜索引擎，具有HTTP Web接口和无模式JSON文档。Elasticsearch是用Java开发的，并在Apache许可证下作为开源软件发布（from wiki） 安装步骤本次安装环境为centos7，公司要求版本是Elasticsearch6.3.2，且需要启用x-pack进行加密访问 由于是指定安装6.3.2版本，直接搜索这个包，找到下载地址 在centos下安装的话，选择TAR包即可 下载下来后，上服务器，自行选终端连接器，我用的xshsell，从文件夹里选中直接往centos里边拖，如果提示要安装rz啥的，就安装一下 1sudo yum install lrzsz -y 拖进去之后，解压 1tar -zxvf elasticsearch-6.3.2.tar.gz 安装一下openjdk 1sudo yum install java-openjdk-devel java-openjdk 如果这个有问题可以重新手动下载jdk1.8版本 如果你服务器是以root方式启动，请切换到附带sudo权限的普通用户操作，因为Elasticsearch不能以root用户启动，没有用户就新加一个，不会请自行搜索一下教程，es文件夹也建议放进/home/noRootUser下操作，并更改es文件夹所有者到该用户 1sudo chown -R noRootUser:noRootUser /home/noRootUser/elasticsearch-6.3.2 更改配置文件，在config下有elasticsearch.yml 12345678910cluster.name: esnode.name: masternode.master: truenode.data: truepath.data: /home/user/elasticsearch-6.3.2/datapath.logs: /home/user/elasticsearch-6.3.2/logsnetwork.host: 0.0.0.0http.port: 9200transport.host: localhosttransport.tcp.port: 9300 这个是一个大概的配置，具体情况得具体分析，而且生产环境基本是集群配置，network.host那样设置以及设置transport.host是为了让其他机器可以直接访问，如果访问不了请关闭防火墙试试，具体部署应该不会关防火墙而是单独开放这个端口来访问（盲猜 随后可以尝试启动，上面步骤没问题的话，应该是可以正常启动的，直接在bin目录下执行./elasticsearch ，在物理机上访问一下ip加对应端口应该就可以看到一串json，这样就表示es开启成功了 如果要开启x-park，在配置文件中加入如下配置即可 12xpack.security.enabled: truexpack.security.transport.ssl.enabled: true 这里要注意一个问题，6.3+的版本，是自带x-park插件的，不需要安装，低于这个版本需要手动安装，但低于6.8的版本，x-park是需要购买的，直接这样配置只能试用30天，而且免费版本的功能并不全，如果需要全部功能依旧需要付费购买，开启之后，重新启动，访问服务就需要用户名和密码验证了 在bin目录下，执行 1./elasticsearch-setup-password interactive 可以设置4个账户（模糊记得有elastic和kibana_system，其他的忘了，这个是6.3.2的账户，7.9有7个）的密码，每个要输入两次，请记住密码，随后可以用这四个账户和对应密码通过x-park的验证，如果是集群的话，应该需要为每个节点配置 注意事项 推荐一款Linux必备工具——终端复用神器-tmux，很容易上手，操作效率更高 尽量看elasticsearch官网的步骤和配置说明，很多都写的很详细，甚至具体到了linux的发行版本（公司现场用的话大概率是centos7或者6.5吧），唯一不太友好的估计是语言，但这个问题不大，毕竟我这种辣鸡英文水平都能看懂 如果可以，请尽量装最新的稳定版本，我在自己本地尝试了最新的7.9，感觉良好 这只是安装尝试一下，现场真升级时估计够呛吧，还要跟client端匹配，而且以前没用过x-pack来加密= =，这坑有点深]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后来呢]]></title>
    <url>%2F2020%2F08%2F26%2F%E5%90%8E%E6%9D%A5%E5%91%A2%2F</url>
    <content type="text"><![CDATA[写这篇文章的最初契机，是因为两个字——离职，但实际内容可能远远不止这两个字，莫名其妙就想了好多好多，想到哪写到哪吧 ​ 南京好像开始降温了，夜晚在家甚至可以不开空调 ​ 两周前接了一个紧急需求，但不难，神奇的是，对面系统跟我对接的那个开发，在功能刚刚调通的那天，就和我说，他今天要离职了，如果有别的更改，再找他们leader，说罢，给需求展示了效果后，便走了，想起来也算有趣，去年来实习做的第一个项目需求，负责测我那个需求的测试小姐姐，在和我对接完之后，也离职了，感觉自己自带了某种神奇的属性，负责送走那些要离开的人。其实离职在私企是一件相当普遍的事情，甚至只要几个月就离职的也大有人在，私企甚至会有员工开除老板一说，不像国企公务员，离职那是相当慎重的 ​ 故事的重点当然不是上述的巧合，源于我同事说的一句“如果我们都离职了，你怎么办？”，刚听到这句话的时候，我的脑子里也是一片空白，刚来团队这边做需求的时候，是各种懵逼，干啥啥也不会，加上自己的动手能力也比较弱，好多事情都依赖着他们，遇到问题的排查能力也很差，如果他们真离职了，说实话，我可能真的会不知所措吧，这件事于我而言几乎是无法想象的，本来上半年，团队就走了三个高工，研发经理也换了一个，如果他们再走，损失不可估量，对于业务的熟悉需要大量的时间成本。可，私企，离职，换公司，真的太正常不过，铁打的仓库，流水的commit，代码里可以看到很多人的commit，大多数都不在了，留下的只是他们的代码，和一些大大小小的隐形bug ​ 往更久远的历史讲，从小，我好像就不是那种喜欢钻研和攻克难题的人，好几天都去做一个题这种事对于我来说几乎就不曾有过，但，相对的，做技术，要的就是面对难题时锲而不舍的精神，我开始怀疑自己真的适合做技术，尤其是做研发，大大小小的问题都需要排查，每一次都是一个难题，如果很多时候都要依赖别人，那样就会面临巨大的阻力。一开始的实习招聘和秋招其实就已经说明了很多，我大学时代学到的东西并不足以进入一线的大厂，尤其是互联网的，后来事实证明，我确实不适合，慢热，学东西慢，如果真进了，我都无法想象我在里边的情况 ​ 这几天，我也总在反思自己，为什么自己只有这样的水平，不仅是工作上，还有个人社交上，以及语言行动上，人要是反思起来，感觉什么事都像是自己错了，不该说的话，不该做的事，不该接触的人。忽然就想起来大二的时候上过的商务英语，Susan老师说过的一个词，“专注力”，培养这个真的很重要，我是一个极容易分心的人，在难题的钻研上也就显得力不从心，注意力总被分散 ​ 上班以来，在同事们的照顾下，亦或是因为我刚来不久，没有把特别重的任务给我，生活还算OK，大学室友们也还在南京，有时候会去他们那边玩，周末能回学校旁边吃好吃的，托乐嘉有靠谱的Tony，奥体有一群喜欢打羽毛球的人，住的房子里有可爱的女室友，说实话，如果我不去想以后结婚买房什么乱七八糟的事，我希望能永远这样，可惜并不能，30多岁还在外漂泊，以前认识的人大多有了自己的家庭，慢慢的就会和别人聊不来，南京这所城市也许美丽，也许文化底蕴深厚，也许不像北上深那样离谱的房价，但对于很多外地人来说，依旧不是他们的家，也许最后，离开还是最好的选择吧 ​ 博客断更好久了，之前燃脂运动和单词打卡都坚持下来了，这次也来坚持一下试试吧，一周一次技术博客更新，不能太敷衍，每周需要强迫自己去学东西才行]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用git操作]]></title>
    <url>%2F2020%2F08%2F09%2F%E5%B8%B8%E7%94%A8git%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[​ Git操作是开发日常中最基础的，同时也是最重要的开发工具之一，掌握git是一个开发人员的基本素养，下面记录一下在公司里最常用的Git操作 基础型梦开始的地方： git clone down就完事了 最常见的，也是最基础的： 1234git statusgit add .git commit -m "xxx"git push 这是在个人开发时最常用的三步走命令，git status是用来查看暂时已经更改的文件，git add命令会将改动的文件放入暂存区，git commit会生成一个快照记录，同时会有一个唯一的哈希值来标记这个记录，最后push是将本地分支推送到对应的远程分支（对于开发人员则是本地的feauture分支和远程分支） 每一次开发都是本地新建一个feature分支，随后在自己本地进行开发，开发完成后，在远端建立一个对应的feature分支，开发完成后，推到那个分支上，随后在远端仓库提出合并请求，将远程feature分支与主分支（一般是dev分支）进行合并，然后删掉远程分支，分支相关操作： 123git checkout //切换分支（未commit的代码会一起切过去git branch xx //新建xx分支git remote -v //查看本地分支与远程仓库的对应 签完到的第一件事一般是更新代码： 12git fetchgit merge git fetch命令会将远程分支的代码拉取到本地，git merge会把更新的那部分跟本地进行合并，如果拉取之后有冲突会提示让选择用哪边的代码或者是手动解决 有时候想去看看我旁边的老兄提交了多少代码，一般在dev分支上这么查一下 1git log --author="name" log会查到远程对应分支(一般查dev)的commit信息 1git diff 比对命令，可以比对分支或者是commit之前的区别，会显示到具体某一行哪里不同 进阶型git stash顾名思义，暂存，这个命令最常见于暂时保存手里还没做完的工作，暂存区和工作区的改动都会存起来 1234git stash list 显示保存的进度列表git stash drop 丢弃保存的一个进度，如果有多个，默认丢弃最新的git stash pop 弹出最近的一个进度，顾名思义，出栈，也可以指定弹出某一进度git stash clear 删除保存的所有进度 git rebase1234567891011121314151617181920git rebase &lt;远程仓库名&gt;/&lt;远程分支名&gt;git rebase -i HEAD^n# Rebase 986e234..84c413a onto 986e234 (4 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like "squash", but discard this commit's log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out pick：保留该commit（缩写:p） reword：保留该commit，但我需要修改该commit的注释（缩写:r） edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e） squash：将该commit和前一个commit合并（缩写:s） fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f） exec：执行shell命令（缩写:x） drop：我要丢弃该commit（缩写:d) 这个命令上大学的时候从来没用过。。一直到来了公司之后，开始参与公司项目的迭代，才接触到这个命令，简单来说，当自己的某项工作搁置了一段时间，落后远程分支挺多的时候，如果做完了，想把代码推上去，先拉去更新后会有很多的commit，加上自己本地提交的一些commit，直接提交的话远程分支很不整洁，这个时候可以用git rebase命令，把自己做的所有工作整合成一个commit，移到master或者dev分支的最前面，就可以了，但这只能适用于自己的分支，切不可在主干分支上进行这种操作 git revert1git revert commitid || HEAD^n 版本重做，用一个新的commit来回滚之前的commit，即丢弃某一commit或者是某些commit，然后HEAD往前推进，生成新的commit git reset版本回滚，退到的那个版本之后的commit全部消失，如果已经 123456git reset commitid || HEAD^N--soft 回退后a分支修改的代码被保留并标记为add的状态（git status 是绿色的状态）--mixed 重置索引，但不重置工作树，更改后的文件标记为未提交（add）的状态。默认操作。--hard 重置索引和工作树，并且a分支修改的所有文件和中间的提交，没提交的代码都被丢弃了。--merge 和--hard类似，只不过如果在执行reset命令之前你有改动一些文件并且未提交，merge会保留你的这些修改，hard则不会。【注：如果你的这些修改add过或commit过，merge和hard都将删除你的提交】--keep 和--hard类似，执行reset之前改动文件如果是a分支修改了的，会提示你修改了相同的文件，不能合并。如果不是a分支修改的文件，会移除缓存区。git status还是可以看到保持了这些修改。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯常规批笔试题]]></title>
    <url>%2F2019%2F04%2F11%2F%E8%85%BE%E8%AE%AF%E5%B8%B8%E8%A7%84%E6%89%B9%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[​ 腾讯3月的提前批投简历太慢，电话面试都木有一个，老老实实继续去参加常规批，笔试题目方在这，供参考。(选择题还挺基础的，但是编程题。。。一言难尽) 选择题 TCP与UDP 平衡二叉树 操作系统批处理的调度算法 给出一趟排序后的结果，选出可能的排序方法 C的static 访问一个https网站用到了哪些协议 阅读C++代码(类) 计算机网络子网划分 栈的进出 C++代码哪些行可能会编译错误 实时处理框架Storm技术 Java接口 SQL语句 C++代码输出 堆排序 FIFO缺页中断次数 递归函数的时间复杂度 LRU下一次替换的页 二叉树的先序和中序 Linux查找某文件 选择题虽然比较基础，但是由于全都是不定项，有的题目选项多达5个，如果基础不稳固的话时间耗费很大而且正确率没有保障，基础这一块需要加强。 编程题 输入整数n种不同面值的硬币，假定数量无限，再给一个m值作为上限，要求凑出1到m(包括1和m)之间所有的面值，需要的最少硬币数是多少，如果不存在输出-1。时间限制我模糊记得C/C++是3万多毫秒？n范围是1-100，m是1-1亿。 给一个仅仅包含0和1的字符串，如果有相邻的两个字符是01或者10，则将这两个消除，最后，输出最终的字符串最短长度。(没怎么看不记得限制条件了) 穿越怪兽谷，再怪兽谷依次会遇到N只怪兽，会给出每只怪兽的武力值和贿赂这只怪兽的金币数，贿赂了某只怪兽，该怪兽就会护送我们继续前进，如果不贿赂某只怪兽，该怪兽武力值大于护送我们的怪兽武力值之和，那我们就会被怪兽打。要想成功穿越怪兽谷还不被怪兽打，最少需要准备多少金币。 (编程题后期有时间争取补上去。。。) 原链接]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西加加后台开发面试总结]]></title>
    <url>%2F2019%2F04%2F03%2FC-%E8%A5%BF%E5%8A%A0%E5%8A%A0%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[C++后台开发的一些知识点，尽可能补全一点，无限更新中。 C/C++语言基础extern关键字作用 extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。 可以进行连接指定。 static关键字作用 static修饰局部变量，使得其成为静态变量，存储在静态区，静态区的数据生命周期和程序相同，main函数之前初始化，程序退出时销毁。 static修饰全局变量，全局变量本来就在静态区，所以并没有改变其存储位置，但是，static会限制其链接属性，被static修饰的全局变量智能被该包含该定义的文件访问。 static修饰函数，使得函数只能在半酣该函数定义的文件中被调用。如果static函数定义在头文件中，则每一个包含该头文件的文件都实现了一个fun函数，因此static实现了不同文件中定义同名的函数而不发生冲突。 在C++中，对于静态成员变量和静态成员函数，所有的对象都只维持一个同一个实例，因此，采用static可以实现不同对象之间数据共享。 volatile关键字用这个关键字声明的变量，每次访问，都会去相应的内存单元取值，也就是说，即使寄存器中有备份，也不会访问，部分编译器会对代码进行优化，频繁访问的变量会自动去寄存器中访问，毕竟访问寄存器的速度要比内存快得多。 const的作用 限定变量为不可修改 限定成员函数不可以修改任何数据成员 const与指针：const char *p 表示指向的内容不能改变；char* const p，将p声明为常指针，地址不能改变，是固定的，但内容可以改变。 new/delete和malloc/free的区别 malloc和free是库函数，而new和delete是C++操作符。 new可以自定计算需要的空间大小，而malloc需要指定。 new在动态分配时自动调用构造函数，delete释放内存时调用析构函数，而malloc只管分配，不会初始化。 new是C++操作符，是关键字，而operate new是C++库函数。 operator new / operator delete可以重载，而malloc不行。 new可以调用malloc来实现，反过来不行。 malloc可以直观地重新分配内存。 C++多态性和虚函数表 封装可以使得代码模块化，继承可以扩展已经存在的代码，这两者都是为了代码重用，而多态的目的则是为了接口重用，也就是说，不论传递过来的究竟是哪个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。常见用法是声明一个基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性。 虚函数在设计上还具有封装和抽象的作用，比如抽象工厂模式。 动态多态的设计思想：对于相关的对象类型，确定它们之间的一个共同功能集，然后在基类中，把这些共同的功能声明为多个公共的虚函数接口。各个子类重写这些虚函数，以完成具体的功能。客户端的代码通过指向基类的引用或指针来操作这些对象，对虚函数的调用会自动绑定到实际提供的子类对象上去。优点：实现与接口分离，可以复用；处理同一继承体系下异质对象集合的强大威力。缺点：运行期绑定，导致一定程度的运行时开销。编译器无法对虚函数进行优化。笨重的类继承体系，对接口的修改影响整个类层次。 静态多态的设计思想：对于相关的对象类型，直接实现它们各自的定义，不需要共有基类，甚至可以没有任何关系。只需要各个具体类的实现中要求相同的接口声明。客户端把操作这些对象的函数定义为模板，当需要操作什么类型的对象时，直接对模板置顶该类型实参即可。优点：静态多态在编译时完成，因此效率较高，编译器也可以进行优化。有很强的适配性和松耦合性，可以通过偏特化、全特化来处理特殊类型。最重要的一点是静态多态通过模板编程为C++带来了泛型设计的概念，比如强大的STL库。缺点：由于是模板来实现的静态多态，由此模板的不足也就是静态多态的劣势，比如调试困难、编译耗时、代码膨胀、编译器支持的兼容性，不能够处理异质对象集合。 动态绑定虚函数表是属于类的，而不是属于某个具体的对象，虚表的指针属于对象。动态绑定的实现依赖着虚表和虚函数，执行函数的动态绑定需要以下三个条件： 通过指针来调用函数 指针upcast向上转型(继承类向基类的转换成为upcast) 调用的是虚函数 虚函数和纯虚函数的选择 当基类中的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供缺省备选方案的时候，该方法应该设计成虚函数。 当基类中的某个成员方法，必须由子类提供个性化实现的时候，应该设计为纯虚函数。 指针和引用的区别 指针是一个变量，只不过变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名。 可以有const指针，但是没有const引用。 指针可以有多级，但引用只能是一级。 指针的值可以是空，但引用不能。 指针的值可以改变，而引用在进行初始化之后就不会再改变了。 内联函数 用inline关键字即可将函数定义为内联函数，当调用该函数时，编译器直接将函数的定义体来替换函数，而不是按照常规的函数调用那样压栈保存返回地址等一系列操作，这是建立在函数体十分短小简洁的前提下，相对于调用函数的时间来讲执行时间很短，如果函数体本身十分庞大复杂、执行时间较长，编译器将忽略内联定义作为普通函数处理。 虚函数不允许内联。 与宏不同，宏是强制的内联展开，可能会污染命名空间和代码，为程序的调试带来困难。 Map和SetMap和Set都是关联容器，Map基于红黑树的结构实现，以键值对的形式进行存储，方便进行查找，关键字起到索引的作用；Set基于红黑树的平衡二叉检索树结构实现，支持高效插入删除，插入元素的时候会自动调整二叉树的结构，维持平衡。 数据结构与算法Hash表 常见的解决冲突的方法有：开放定址法，链地址法，建立公共溢出区等。 树 二叉树的性质：第i层结点数最多为2^(i - 1)；高度为k的二叉树其结点总数最多为2^k-1；对于任意非空二叉树T，如果叶结点个数为n0，其度为2的结点数为n2，则：n0 = n2 + 1。 满二叉树：深度为k且有2^k - 1个结点的二叉树成为满二叉树。 完全二叉树：深度为k的，有n个结点的二叉树，当且仅当其每个结点都与深度为k的满二叉树中编号从1至n的结点一一对应，称之为完全二叉树。 具有n个结点的完全二叉树的深度为log2n + 1。 仅有前序和后序遍历，不能确定一个二叉树，必须有中序遍历的结果。 二叉排序树：左子树结点的值小于根结点的值，右子树结点的值大于根结点的值，没有键值相等的结点，平均时间复杂度是O(long(n))，最坏是O(n)。 平衡二叉树：又称为AVL树，左子树和右子树都是平衡二叉树，左子树和右子树的深度之差的绝对值不超过1。 红黑树：结点为红色或者黑色；根结点为黑色；从根结点到每个叶结点经过的黑色结点个数完全相同；父结点为红色的花子结点不能为红色。 红黑树是在平衡二叉树的严格平衡基础上，采取一定的方法，不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而能够提高性能。只是查找代价略逊色于AVL树，插入和删除的效率都将提升。 B~树：是一种非二叉的查找树，满足以下结构特性：一颗m阶的B~树；树的根或者是一片叶子(一个结点的树)，或者其儿子数在2和m之间；除根外，所有的非叶子结点的孩子数在m/2和m之间；所有的叶子结点都在相同的深度。平均深度为logm/2(N)，执行查找的平均时间为O(logm)。 字典树(Trie)：又称为单词查找树或者键树，是一种树型结构，哈希树的变种，典型应用是用于统计和排序大量的字符串(但不仅限于字符串)，经常被搜索引擎系统用于文本词频统计。优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表还要高，插入和查询的时间复杂度均为O(k)，核心思想是以空间换时间。 链表 链表的插入和删除，单向和双向都要会。 反向打印链表(递归)。 打印倒数第K个结点(前后指针)。 链表是否有环(快慢指针)。 栈和队列 栈和队列的区别：栈是先进后出，队列是先进先出，栈应该注意栈是否已满和为空的特殊情况，队列一般只要判空，栈一般应用于回文判断、迷宫问题，表达式的求值，函数调用和递归实现等场景，而队列大多应用于计算机系统中各种资源的管理，消息缓冲器的管理和广度优先搜索遍历等等。 海量数据问题 分而治之/hash映射+hash统计+堆/快排/归并排序。 Trie树/数据库/倒排索引。 外排序。 分布式处理Hadoop/Mapresuce。 网络与TCP/IPTCP与UDP的区别 TCP基于有连接，UDP基于无连接。有连接即TCP在传输前会先发送连接请求和应答包，保证能够正常通信后，才会进行数据传输。无连接就是在发送数据之前，并不考虑对方能否收到。 TCP能保证可靠传输，UDP不能保证可靠传输。 TCP结构复杂，消耗资源多，建立过程相对要慢要复杂。UDP结构简单，消耗资源少，建立过程比较快。 TCP基于流模式，UDP是数据报模式。TCP把数据堪称一连串无结构的字节流，没有边界，一段段传输构成整个数据块。通过发送缓冲区和接受缓冲区来存储数据流。而UDP数据报模式，每一个数据包都是一个独立的对象，有着指定的大小。 TCP有确认，重传，拥塞控制机制，UDP在没有建立连接或者对方已经推出的情况下依然会继续发送数据，导致通信流量的浪费。 TCP的三次握手和四次挥手建立连接——三次握手 客户端发送一个SYN来创建连接，随机序号为A。 服务端收到消息后，发送确认号ACK=A+1，并发回给客户端一个SYN，随机序号为B。 客户端收到后，再发送一个ACK，确认号为A+1，响应为B+1。 断开连接——四次挥手 客户端发送一个FIN=1的数据分段，进入FIN-WAIT状态，不再发送数据，只接受数据。 服务端收到FIN=1的数据分段后，发送一个带有ACK=1的剩余数据分段，告诉客户端，我收到了你的FIN=1的数据分段。 等到服务端将剩余数据全部发送完毕，即发送FIN=1的数据分段，进入CLOSE-WAIT状态，等待客户端的确认。 客户端收到服务端的FIN=1数据分段后，返回ACK=1报文进行确认，为了防止服务器没有收到，暂时进入TIME-WAIT状态。服务器收到报文后即关闭连接，客户端等待2MSL没收到回复即默认服务端已经关闭，于是客户端关闭。 TCP拥塞控制判断拥塞出现的条件：网络中出现分组丢失。 用到的拥塞避免算法：慢启动、快速重传、快速恢复。 需要维持的两个变量：拥塞窗口和慢启动阈值。 HTTPhttp2.0的特点 采用二进制格式而不是文本格式。 是完全多路复用的，而非有序并阻塞的。 报头进行了亚索，降低了开销。 服务器可以将响应主动“推送”到客户端缓存中。 ###get/post区别 实质上来说，可以没有区别，都是TCP包，所谓的区别都是因为大家的约定俗称的使用规则以及服务器和浏览器的限定跟HTTP的规定而确定下来的。 GET会把http header和data一并发送出去，服务器直接返回200.而POST，浏览器会先发送header，服务器相应100后继续，浏览器再发送data，服务器响应200ok返回数据。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST没有。 GET参数通过URL传递，POST放在Request body中。 状态码 100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 (切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。 200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 (已创建) 请求成功并且服务器创建了新的资源。 202 (已接受) 服务器已接受请求，但尚未处理。 203 (非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 (无内容) 服务器成功处理了请求，但没有返回任何内容。 300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 400 (错误请求) 服务器不理解请求的语法。 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 (禁止) 服务器拒绝请求。 404 (未找到) 服务器找不到请求的网页。 406 (不接受) 无法使用请求的内容特性响应请求的网页。 407 (需要代理授权) 此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理。 408 (请求超时) 服务器等候请求时发生超时。 500 (服务器内部错误) 服务器遇到错误，无法完成请求。 501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。 503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。 505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。 浏览器中输入一个URL用到哪些协议DNS协议，UDP协议(DNS服务器基于UDP)，http协议，TCP协议，IP协议，ARP协议。 安全相关SQL注入SQL注入发生在应用程序与数据库之间，由于输入的字符串没有进行严格的检查和过滤，别有用心的人会在其中注入SQL指令，使得数据库服务器将其误认为正常的SQL指令而运行，造成破坏或者入侵。一般发生原因都是权限过高和SQL指令组合不当。 XSS跨站脚本攻击，攻击者在王页可以输入的地方通过巧妙的方法注入恶意指令，使永无加载并执行攻击者恶意知道的网页程序，一般这些程序都是JavaScript，攻击成功后，攻击者可以得到更高的权限，拿到会话和cookie等内容。这里利用的是用户对指定网站的信任。 CSRF跨站请求伪造，挟持用户在纪录当前已登陆的Web应用程序上执行非本意的操作的攻击方法，这里利用的是网站对用户网页浏览器的信任。 SYN洪水攻击这个顾名思义，光发SYN不给ACK，典型的Dos攻击。 ARP欺骗攻击在ARP协议中有一个缺陷，请求主机在收到ARP应答包之后，不会去验证自己是否向对方主机发送锅ARP请求包，就直接把这个返回包中的IP地址与MAC地址的对应关系保存进ARP缓存表中，如果存在原有对应关系将会被替换。所以C只要假装是某主机给A发包，让A相信这是B的地址，就能达到欺骗A的目的了。 数据库​ 学完一遍再总结吧。 Linux进程与线程进程和线程的区别进程和线程是不同的CPU时间段，进程更大，线程要小一点。进程包括了上下文的切换，而线程之间是共享一个程序的上下文的。 线程跟进程比有什么优势fork代价昂贵，要把所有父进程的内存映像拷贝到子进程，并在子进程中复制所有描述字等等，线程的创建要比进程快的多，且易于共享内存。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[https原理]]></title>
    <url>%2F2018%2F11%2F18%2Fhttps%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[之前对https过程的理解过于表面，只知道三方机构的数字签名证书对服务端发来的公钥进行加密，保证公钥不被篡改，随后非对称加密(一般为RSA)保证对称加密算法的保密性和随机性，最后建立连接，但其实里边有很多细节，之前有过疑惑，但没有深究过。 这玩意儿不好分板块还是直接一路往下写好了。 最开始我也以为消息传输都是用非对称加密，后来才知道这样开销太大，所以都是用的对称加密。 那么如何保证对称加密是安全的呢？ 用非对称加密保证对称加密的方式和密钥不会泄露呗。 咦，那公钥肯定是服务端发给本地的，怎么确定公钥没被中间人篡改呢？ 这里就要用到数字证书了。 服务端用第三方机构的私钥对公钥进行加密，再丢给客户端，然后客户端用第三方机构的公钥进行解密，确定非对称加密的公钥没有问题。 那我怎么确定证书是真的呢？（你问题真特么多！ 所以还需要数字签名，用来解决同一机构颁发的不同证书被篡改的问题，证书是通过哈希算法(信息摘要算法)生成的，对证书内容进行哈希后，如果生成的签名一致，则说明没有问题。而且签名本身也会用第三方私钥进行加密。 然而还有问题，第三方的公钥又怎么到客户端呢？ 这就要靠权威的第三方权威机构列表(CA)，一次把公钥都丢过来，然后根据证书里边的颁发机构去本地找对应的公钥。 所以说到底，还是需要第三方的。 另外，没事不用纠结这么多细节，反而很乱，知道CA保证公钥安全，公钥保证对称加密安全就行了。 参考连接]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终于搭梯子了]]></title>
    <url>%2F2018%2F07%2F26%2F%E7%BB%88%E4%BA%8E%E6%90%AD%E6%A2%AF%E5%AD%90%E4%BA%86%2F</url>
    <content type="text"><![CDATA[​ 之前一直在用ACGPOWER，一个简单的代理，一个月7块，单纯用用google搜索的话稳的一批，不过ACGPOWER特别声明了，不允许单纯用于翻墙，特别是大流量的使用，所以他们把YouTube、Twitter、Facebook这些网站统统屏蔽了，今天终于决定抛弃它，开始租VPS自己搭梯子。 原理​ 很久很久之前，我们是可以轻松和世界上的人用互联网交流的，后来出现了墙这个东西，再然后，先是有了vpn，它通过RSA算法来加密数据，虽然RSA算法无法破解，可是，在密钥交换建立通信隧道之前，是明文传输的，破掉之后流量特征十分明显，就这样，VPN基本上凉了。接着，有大佬自己写了个东西，叫ss，全称是shadowsocks，好用还不会被封锁，于是把它丢到github上，接着…这个大佬就被请去喝茶了，删了代码并保证不再参与维护。可是呢，源码既然公布了肯定有人down了的，于是，又有一位大佬对其进行了改造，主要是在混淆和协议方面做了改进，使其流量更加不易被GFW察觉。再然后，这位大佬也被请去喝茶了…代理的原理，简单来说，先约定加密方式，伪装成正常的流量，逃过封锁，把请求发给中间人（VPS），VPS解密后，搞清楚了客户端的请求，于是去访问客户端想访问的，拿到结果后，再以同样的加密方式，发回去，再一次逃过封锁，返回给客户端，再解密，便完成了一次传输过程。 搭建过程​ 这里不准备详细写了，因为网上的教程实在太多…，我用的是cloudcone，简称为cc，很便宜，还很良心，具体请参考下面的链接。说几个我觉得应该注意的点： 按照自己的需求和预算去买，是单纯地作梯子用，还是要建站作渗透什么什么的，价格区别也挺大，当然了，土豪请随意。 会有优惠码或者优惠活动，想省钱的话先去找找看。 协议和加密方式最好还是慎重一点，如果线路本身不是很稳协议和加密还瞎选的话ip被墙的可能性会更大。 富强民主文明和谐，爱国敬业诚信友善，自由平等公正法治。阿门~ 参考链接： 梯子搭建教程 萌新手册 cloudcone介绍]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些感想]]></title>
    <url>%2F2018%2F07%2F19%2F%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[​ 卓越班今天要开始为项目分组了，凑巧的是，晚上莫名开始翻看周围同学的博客，发现大家都在各自喜欢的领域开始发力，回头看下自己，这一年，真正感兴趣的东西依旧没有找到，真的挺像歌词里边唱的那样“我懵懵懂懂过了一年”，不知不觉，就到了大二的暑假，这意味着，我的4年大学生活，已经过半，看了挺多同学的博文，感想挺多的，今天这篇文章，也算是给自己的大二一个交代吧。 学习​ 大学生的本职工作终归还是学习，所以放第一点。这一年总体上没有大一那么认真，特别是在自己不喜欢的科目上，大二上的数电几乎不曾好好听过，靠着考前复习了整整6天才侥幸通过，离散就是真的从没花过时间去学，最后妥妥挂掉，上学期唯一学了一点点的，就只有数据结构，大二下就更惨了，概率论和编码理论双双挂掉，近世代数和数论也都是飘过，本来就没有数学天分，还不够认真，结果也就这样吧，现在想起来还挺可笑的，自认为自己需要时间去追求喜欢的东西，从而在这些科目上堕落，可结果呢，追求的东西不怎么样，休闲的时光却增加了许多。回过头来看，不管是数电离散，还是概率论和编码论，其实都挺重要的，越往后学越觉得之前学的东西是多么有用，再也不给自己找什么借口，不曾努力学的基础课程和专业课程，最终都会付出惨重代价。 生活​ 开始睡懒觉了，再也没有像大一下那样，连续三十天打完早操打卡，连续30天跑完/走完体能，外卖叫的多了（确实便宜，尤其是DD这个逼）。体育运动好像比大一要好一点，毕竟大一下的体育课。。。手残选了什么傻叉散打，无聊的一批，大二的体育课选的相当给力，羽毛球和游泳，羽毛球班上跟两位大佬打的十分开心，最后发现那位大佬居然还是我的老乡哈哈哈哈哈真是厉害了，而且是在同一趟高铁下车后遇到的。游泳一时间给我造成了挺大的困扰，但最终还是成功游过了25米，同时也解锁了游泳馆这个新地方。篮球打的挺多的，特别是这一年的班赛，任大佬带着我们直接杀到了年级决赛，虽然被402打的挺惨但也挺开心。大二这年貌似也是开销巨大的一年，手机换了，电脑换了，买了显示器汤普森球鞋帆布鞋五分裤九分裤衬衫T-shirt晴雨伞balabala各种各样的小东西，仔细算算这金额好像有点庞大…emmm，下学期估计就没什么钱可花了，好好学习研究技能准备实习。 情感​ 有尝试过，但终究还是单身狗一条，不过确实懂了挺多道理，有些东西不经历的确没法明白。 志愿​ 为什么要单独划一个版块给志愿呢？其实在我整个大二学年，做志愿的时间并不算多，但我是真心喜欢（其他学校妹子的原话：我看得出来你是真心喜欢做志愿），一开始去做了迎新活动，至今记得一个人在羽毛球馆面对领军训服的新生各种忙活，还有全国高校仪器志愿时翘掉数电和数据结构整整两个白天跑到奥体去和学姐以及同年级的男生一起在那个小小的小件存储里边搬行李（貌似最后还发了200块钱，不过真的很廉价，给500都不过分，实在是太辛苦了），NOIP竞赛志愿时给会务组打杂看到了各种大佬（是的，江苏各个中学的竞赛领队老师），全国沙排时坐在观众席上和旁边浦口的妹子一边聊天一边看沙排大长腿，这些经历都刻骨铭心，见识了很多有意思的人，也给社会贡献了自己的一份温暖，同样赢得了尊重和赞赏。 技能​ 大二上初期一段时间在尝试CTF，不过打来打去，总觉得，这比赛，PWN和CTYPTO是真的需要非常扎实的基础才能打得动，而MISC，WEB这两者基本就靠经验积累和不断总结以及，那一闪而过的脑洞了，总的来说，是个，非常，非常，非常，肝的比赛，不过呢，肝归肝，只要自己喜欢，这都不算事，但从结果来看，似乎并不算好，没能怎么坚持下去，因为无法平衡学习和CTF两者，无奈放弃。 ​ 和16院的绝大部分人一样，加了一个科创团队，参加了一个科创项目，不过，很遗憾，这应该是我大二这一年里边最大的错误选择，没有之一。 ​ 开发方面好像就没怎么去动了，大二上的部分时间给了CTF，其他时间和数据结构做斗争，大二下拼死与PA相博最后在3.3时完美放弃，除了每天看看博客学学知识外实践的很少很少，可以说是毫无长进了。 乱七八糟不知放哪部分的​ 大二下最后的英语课，如愿以偿选到了吴珊老师的商务英语，果然名不虚传，好评如潮的Susan没有辜负我的期待，人好给分也高，在她那学到了许多学习英语的tips，也学到了许多英语之外的东西。除此之外，还认识了9院10院的6位大佬（我记得5位是文强班的），相当开心。 ​ 大二下的中期，在近世代数考试的前夕，作死和大佬们去了天津玩了4天，高铁上复习近世代数的时光永生难忘。 ​ 仔细想想遇到了挺多有意思的老师，幽默风趣的张小平老师，想尽办法让我们对计组有更多兴趣和信心的陈丹老师，严肃而又谦逊的人工智能的各个讲师，看似说话像催眠其实深藏不漏的黄玉划老师，三番五次勒令我不要在毛概课上写代码的赵媛媛老师等等等等，或许很多人都觉得他们教的很一般，但我认为，已经够了，奢求不了太多，学习更多的都是靠自己，有一个循循善诱的老师固然是美事，没有也不必遗憾。 总结​ 曾经那么努力，没能登上顶峰；只要松懈了一点点，便会跌入谷底。]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>回忆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[送给最后的pa]]></title>
    <url>%2F2018%2F07%2F18%2F%E9%80%81%E7%BB%99%E6%9C%80%E5%90%8E%E7%9A%84pa%2F</url>
    <content type="text"><![CDATA[​ 又是3个月没写过博客了，今天看到了学长发的“PA反馈精选”，突然回想起来交PA压缩包的那天，心情很糟，草草写了两百字就交上去了，现在看到大家的反馈，又忍不住重新回忆一下这一学期的PA之旅。 PA0​ 这部分其实很简单，配一下PA的环境即可，但讲义上来非得用英语，给我们造成了一些压力（其实很容易啃，至少比paper容易多了）。讲义说的太复杂，最主要的是针对一些之前完全对虚拟机和Linux没有接触过的同学，但其实，说白了，就是需要Linux环境，至于你是用服务器，虚拟机（VMware or virtulbox），Docker，还是双系统，都可以，想用什么用什么，如果后期遇到的问题，那就自己解决呗！比如输出图形，用图形化虚拟机或者真机的就不需要什么Xming，而且Xming的转发效率…..我一开始就是用的VMware， 后来有段时间用两个电脑做，另一台电脑装了Ubuntu-W10双系统，后来又变回VMware。PA0主要就学学虚拟机的搭建与网络配置，vim的使用，git的初体验，基础Linux指令。 PA1​ 这里要写一个调试器，功能有单步执行、打印程序状态、表达式求值、扫描内存、设置监视点等等，比较简单，不过需要学一下正则表达式，这玩意语法有点反人类，刚开始肯定是用一次看一次手册，根本记不住，后面写多了才熟，不过不用就会忘（答辩的时候耗子哥哥考我一个简单的正则都写错了ORZ）。直接用c写就行。但这里有个玄学问题：后期输出内存后发现它不符合预期，到底是那段功能挂了，还是你的调试器挂了呢？…… PA2​ 2完全可以说是PA劝退的开始，从这里开始，要开始写指令，i386的手册翻了又翻，取指、译码、执行、访存、写回，程序运行的每一步自己都会感受到。每个指令都会有每个指令的问题，填表也是，挺玄学的，倾尽所有只为能让指令可以跑通。值得注意的是，这里要尽可能地用rtl语句写，否则无法保证不会影响到后期。值得吐槽的是讲义把diff-test放到了2.2的末尾（好像是这里吧？我记得不是很清楚了），导致很多人一开始没有享受到这个超级好用的调试方法，然而有大佬一开始就在群里说了，我2.2一开始遇到bug后得到大佬的指点马上先去实现了diff，这很大程度上给我调2.2的代码节省了比较多的时间，肉眼调试实在是太……. PA3和PA4​ 从3开始，我划水的浆就抬起来了，我感觉，3主要说的是中断异常处理、系统调用、文件系统等等，4貌似就是进程切换分时多任务了，具体的我完全不清楚，因为从3.3及以后我基本就没怎么碰了，发出咸鱼的声音.jpg。 吐槽​ 项目验收之前，我突然发现了一些比较诡异的行为，在PA2分支下能跑通的代码，在PA3分支下反而跑不通了，由于时间原因也没去调了，最后验收的时候还切了分支跑代码。。。调试确实是件很辛苦的事情，可以说写代码的时间远远低于读文档和调试的时间，找对方法很重要，方法合适可以节省挺多时间。至于有人说到群里总是那几位大佬在发言搞得自己不敢提问？？？emmmmm，我也在群里问过一些白痴问题，也没少块肉呃，再说了，大佬说的大多是自己踩过的坑，不都是好事么？→_→表示无法理解。 ​ 总的来说PA还是一门挺不错的课，难度比较大，与理论课的联系算不上十分密切，10分最多只能给7分，除了对指令的执行过程、中断异常的处理、进程的切换、i386指令的细节有了比较多的了解，其他的好像真没什么了。。。反观理论课，给我的印象大多是机器数与真值的转换，汇编语句，过程调用，符号解析，存储管理（特别是高速缓存）等等，中断异常处理、缓冲区溢出攻击、甚至是动态链接，都只是一带而过，说实话要求真心不高（我好像也是站在学完了的角度后说这种话，一开始学的时候也是各种不懂痛苦不堪，或许这就是所谓的马后炮吧23333），如果真想在cs方面有所建树的话，计组还是要认真学的，pa更应该好好做。最后的最后，谢谢四位助教给的高分。]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10-Ubuntu双系统]]></title>
    <url>%2F2018%2F04%2F04%2FWin10-Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[昨天在@qrz大佬成功安装win10-Ubuntu双系统，把该踩的坑踩了一遍后，我拿着大佬的启动盘也装好了Ubuntu，正所谓，前人栽树后人乘凉，古人诚不欺我23333，双系统并不难装，重点是要清楚自己的电脑实际情况以及安装的方式，我简单说一下我的安装过程。 ​ UEFI启动模式！！！全文重点！！！ 大概步骤 分区。选块有余量多点的盘，分一块出来，理论上来说越多越好，具体视对linux的使用情况而定。建议不少于40G。 启动U盘，把ubuntu的iso文件烧录进去。 关闭windows快速启动，关闭Security Boot ，选择UEFI的USB启动（我的好像默认就是usb）。 插上U盘，重启，选择install ubuntu。 不要选择安装更新和第三方软件，建议断网安装，建议选中文，会舒服的多，不要选择“与其他系统共存这一项”，请直接选最后一项“其他选项（创立自己的分区）”。 找到自己事先准备的那个盘，戳一下那个“-”号，把盘空出来（这样它就会变成空闲状态），然后选中这个空闲盘，戳加号，新建分区。 交换空间。选择主分区和空间起始位置，容量同物理内存就行。 efi系统分区，选择逻辑分区，和空间起始位置，建议给512M。 挂载”/home”，类型为EXT4日志文件，选择逻辑分区和空间起始位置，建议至少8G，类似于win下的user 挂载”/usr”，类型为EXT4日志文件，选择逻辑分区，和空间起始位置，三方软件安装处，现有条件下越大越好。 挂载”/“，类型为EXT4日志文件，选择逻辑分区和空间起始位置，不要低于8G。到这挂载就选择完毕了，如果想仔细了解，可以看这里 选择安装引导启动器的设备！这里很重要，千万不能用默认的，改成刚刚efi系统分区 请仔细确认7-12步合理分区后，点击安装 装完后就可以选择重启然后拔掉U盘了，然后重开win10快速启动和Security Boot。引导界面默认选项1进Ubuntu，如果要进Windows选3就行了。 完结撒花，半个小时装完。 放一下我的桌面 参考链接 在暗影精灵上又装了一遍，之前的那台yogo700已经转给有缘人了，噢对了，这里吹一波笔吧二手交易平台。。。。（不是闲的蛋疼，只是那天机器学习的算法原理实在是听不下去了，就…），跟上次装的最大区别在于这个电脑用的是Nvidia的独显1050ti，而之前的电脑是集显的。不过问题不是很大，重装驱动就行了。具体细节google一通就能找到，就不多谈了，十分容易的活儿。]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言函数调用栈]]></title>
    <url>%2F2018%2F04%2F02%2Fc%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%2F</url>
    <content type="text"><![CDATA[​ 函数调用栈是一个非常重要的过程，也是整个程序运行的关键，下面简单地说一下这个调用过程。 寄存器​ 寄存器是程序运行的重要载体，可以用来存放数据和指令，函数调用过程与其密切相关。首先是几个特殊点的寄存器：%eax ，%ebx ，%ecx ，%edx， 各自都能作为独立的16位寄存器，低16位还能再分成8位的寄存器，这应该是为了向下兼容。在汇编语言中，这些通用寄存器通常以%e（AT&amp;T语法）或直接以e（Intel语法）开头来引用，如，mov $5, %eax，或者mov eax, 5 ，都表示将立即数赋值给寄存器%eax 。 ​ 而x86架构中，EIP是一个比较特殊的寄存器，它被称为指令寄存器，永远指向处理器下一条等待执行的指令地址（有时也用偏移量表示），每次执行完EIP的值就会增加，由于它的特殊性，不能像访问普通寄存器那样访问它，找不到可用来寻址EIP并对其进行读写的操作码（Opcode），EIP可被jmp、call 、ret等指令隐藏式地改变。 ​ 另外要注意的是，寄存器是唯一能被所有函数共享的资源，需要保证A函数调用B函数时，B函数不会修改或覆盖A函数稍后会用到的寄存器值，为此，有这么一些规定：寄存器%eax，%ebx，%ecx，为主调函数保存寄存器（caller-saved registers），函数调用时，如果主调函数想要保存这些寄存器的值，必须在调用前显示地将其保存在栈中，然后被调函数就可以覆盖这些寄存器，这样就不会破坏主调函数所需的数据。寄存器%ebx，%esi，%edi 为被调函数保存寄存器（callee-saved registers），即被调函数在覆盖这些寄存器的值时，必须先把寄存器的原值压入栈中保存起来，并在函数返回前恢复其值，因为主调函数也可能会用到这些寄存器。除此之外，被调函数还必须保持寄存器%ebp，%esp，并在函数返回后将其恢复到调用前的值，即必须恢复主调函数的栈帧。 栈帧​ 刚刚说到了栈帧（stack frame），栈帧是什么呢？栈帧本质上就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息。同样有栈顶和栈底，栈底地址最高，x86-32bit架构中，用%ebp指向栈底，即基址指针，%esp指向栈顶，即栈顶指针。函数调用栈时的内存布局： ​ 注意这个图基于两个假设：第一，函数返回值不是结构体或联合体，否则的话第一个参数将位于12(%ebp)处；第二，每个参数都是4字节大小。 ​ 从这个图也能看出，函数调用时的入栈顺序为：实参（从右到左）-&gt;主调函数的返回地址-&gt;主调函数的帧基指针EBP -&gt;被调函数局部变量1~N。具体来看，主调函数首先将参数按照调用约定依次入栈，然后将指令指针EIP入栈以保存主调函数的返回地址。进入被调函数时，被调函数将主调函数的帧基指针EBP入栈，并将主调函数的栈顶指针ESP值赋给被调函数的EBP（作为被调函数的栈底），接着改变ESP值来为函数局部变量预留空间。此时被调函数帧基指针指向被调函数的栈底。以此地址为基准，向（上）栈底方向可获得主调函数的返回地址和参数值，向（下）栈顶方向可获得被调函数的局部变量值，而该地址又放着上一层主调函数的帧基指针值。本级调用结束后，EBP指针值赋给ESP，使其再次指向被调函数栈底以释放局部变量；再将以压栈的主调函数帧基指针弹出到EBP，并弹出返回地址到EIP。ESP继续上移越过参数，回到调用前的状态，恢复原来主调函数的栈帧，递归便形成了函数调用栈。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客环境迁移]]></title>
    <url>%2F2018%2F03%2F19%2F%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[换电脑了，博客的环境也得跟着搬迁一下。一开始我去搜了搜教程以为这件事情很复杂。 就像某乎里边说的这样： 一、关于搭建的流程 \1. 创建仓库，http://CrazyMilk.github.io；\2. 创建两个分支：master 与 hexo；\3. 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；\4. 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库；\5. 在本地http://CrazyMilk.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;\6. 修改_config.yml中的deploy参数，分支应为master；\7. 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；\8. 执行hexo g -d生成网站并部署到GitHub上。 这样一来，在GitHub上的http://CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！ 但我就是傻傻地认为，所有东西不都在本地博客的文件里边么？既然这样，我把git、node.js、hexo、以及相关依赖装好，配置一个ssh放到github上，然后整个文件夹迁移过来不就行了？？？ 事实证明我是对的！哈哈哈哈哈哈哈]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>hexo迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bomblab-再相遇]]></title>
    <url>%2F2017%2F12%2F02%2Fbomblab-%E5%86%8D%E7%9B%B8%E9%81%87%2F</url>
    <content type="text"><![CDATA[​ 废话不多说，开始。 phase_11234567891011(gdb) disassemble phase_1Dump of assembler code for function phase_1: 0x0000000000400f2d &lt;+0&gt;: sub $0x8,%rsp 0x0000000000400f31 &lt;+4&gt;: mov $0x4026f0,%esi 0x0000000000400f36 &lt;+9&gt;: callq 0x401472 &lt;strings_not_equal&gt; 0x0000000000400f3b &lt;+14&gt;: test %eax,%eax 0x0000000000400f3d &lt;+16&gt;: je 0x400f44 &lt;phase_1+23&gt; 0x0000000000400f3f &lt;+18&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000400f44 &lt;+23&gt;: add $0x8,%rsp 0x0000000000400f48 &lt;+27&gt;: retqEnd of assembler dump. 直接看一下0x4026f0字符串就可以： (gdb) x/s 0x4026f00x4026f0: &quot;I am just a renegade hockey mom.&quot; phase_212345678910111213141516171819202122232425262728293031323334(gdb) disassemble phase_2Dump of assembler code for function phase_2: 0x0000000000400f49 &lt;+0&gt;: push %rbp 0x0000000000400f4a &lt;+1&gt;: push %rbx 0x0000000000400f4b &lt;+2&gt;: sub $0x28,%rsp 0x0000000000400f4f &lt;+6&gt;: mov %fs:0x28,%rax 0x0000000000400f58 &lt;+15&gt;: mov %rax,0x18(%rsp) 0x0000000000400f5d &lt;+20&gt;: xor %eax,%eax 0x0000000000400f5f &lt;+22&gt;: mov %rsp,%rsi 0x0000000000400f62 &lt;+25&gt;: callq 0x401777 &lt;read_six_numbers&gt; 0x0000000000400f67 &lt;+30&gt;: cmpl $0x0,(%rsp) 0x0000000000400f6b &lt;+34&gt;: jns 0x400f72 &lt;phase_2+41&gt; 0x0000000000400f6d &lt;+36&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000400f72 &lt;+41&gt;: mov %rsp,%rbp 0x0000000000400f75 &lt;+44&gt;: mov $0x1,%ebx 0x0000000000400f7a &lt;+49&gt;: mov %ebx,%eax 0x0000000000400f7c &lt;+51&gt;: add 0x0(%rbp),%eax 0x0000000000400f7f &lt;+54&gt;: cmp %eax,0x4(%rbp) 0x0000000000400f82 &lt;+57&gt;: je 0x400f89 &lt;phase_2+64&gt; 0x0000000000400f84 &lt;+59&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000400f89 &lt;+64&gt;: add $0x1,%ebx 0x0000000000400f8c &lt;+67&gt;: add $0x4,%rbp 0x0000000000400f90 &lt;+71&gt;: cmp $0x6,%ebx 0x0000000000400f93 &lt;+74&gt;: jne 0x400f7a &lt;phase_2+49&gt;---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x0000000000400f95 &lt;+76&gt;: mov 0x18(%rsp),%rax 0x0000000000400f9a &lt;+81&gt;: xor %fs:0x28,%rax 0x0000000000400fa3 &lt;+90&gt;: je 0x400faa &lt;phase_2+97&gt; 0x0000000000400fa5 &lt;+92&gt;: callq 0x400b90 &lt;__stack_chk_fail@plt&gt; 0x0000000000400faa &lt;+97&gt;: add $0x28,%rsp 0x0000000000400fae &lt;+101&gt;: pop %rbx 0x0000000000400faf &lt;+102&gt;: pop %rbp 0x0000000000400fb0 &lt;+103&gt;: retqEnd of assembler dump. 输入是6个数，从0x400f93 &lt;+74&gt;: jne 0x400f7a &lt;phase_2+49&gt; 知道主逻辑是个循环，第一个数是必须是0，第二个数必须是1，开始以为是等差数列，然后发现中间还有个+1的过程，所以这个数列的公差是等差数列，那么正确答案是：0 1 3 6 10 15. phase_312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182(gdb) disassemble phase_3Dump of assembler code for function phase_3: 0x0000000000400fb1 &lt;+0&gt;: sub $0x28,%rsp 0x0000000000400fb5 &lt;+4&gt;: mov %fs:0x28,%rax 0x0000000000400fbe &lt;+13&gt;: mov %rax,0x18(%rsp) 0x0000000000400fc3 &lt;+18&gt;: xor %eax,%eax 0x0000000000400fc5 &lt;+20&gt;: lea 0x14(%rsp),%r8 0x0000000000400fca &lt;+25&gt;: lea 0xf(%rsp),%rcx 0x0000000000400fcf &lt;+30&gt;: lea 0x10(%rsp),%rdx 0x0000000000400fd4 &lt;+35&gt;: mov $0x40273e,%esi 0x0000000000400fd9 &lt;+40&gt;: callq 0x400c40 &lt;__isoc99_sscanf@plt&gt; 0x0000000000400fde &lt;+45&gt;: cmp $0x2,%eax 0x0000000000400fe1 &lt;+48&gt;: jg 0x400fe8 &lt;phase_3+55&gt; 0x0000000000400fe3 &lt;+50&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000400fe8 &lt;+55&gt;: cmpl $0x7,0x10(%rsp， 0x0000000000400fed &lt;+60&gt;: ja 0x4010ef &lt;phase_3+318&gt; 0x0000000000400ff3 &lt;+66&gt;: mov 0x10(%rsp),%eax 0x0000000000400ff7 &lt;+70&gt;: jmpq *0x402750(,%rax,8) 0x0000000000400ffe &lt;+77&gt;: mov $0x66,%eax 0x0000000000401003 &lt;+82&gt;: cmpl $0xde,0x14(%rsp) 0x000000000040100b &lt;+90&gt;: je 0x4010f9 &lt;phase_3+328&gt; 0x0000000000401011 &lt;+96&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000401016 &lt;+101&gt;: mov $0x66,%eax 0x000000000040101b &lt;+106&gt;: jmpq 0x4010f9 &lt;phase_3+328&gt;---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x0000000000401020 &lt;+111&gt;: mov $0x74,%eax 0x0000000000401025 &lt;+116&gt;: cmpl $0x288,0x14(%rsp) 0x000000000040102d &lt;+124&gt;: je 0x4010f9 &lt;phase_3+328&gt; 0x0000000000401033 &lt;+130&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000401038 &lt;+135&gt;: mov $0x74,%eax 0x000000000040103d &lt;+140&gt;: jmpq 0x4010f9 &lt;phase_3+328&gt; 0x0000000000401042 &lt;+145&gt;: mov $0x76,%eax 0x0000000000401047 &lt;+150&gt;: cmpl $0x149,0x14(%rsp) 0x000000000040104f &lt;+158&gt;: je 0x4010f9 &lt;phase_3+328&gt; 0x0000000000401055 &lt;+164&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x000000000040105a &lt;+169&gt;: mov $0x76,%eax 0x000000000040105f &lt;+174&gt;: jmpq 0x4010f9 &lt;phase_3+328&gt; 0x0000000000401064 &lt;+179&gt;: mov $0x62,%eax 0x0000000000401069 &lt;+184&gt;: cmpl $0x2a7,0x14(%rsp) 0x0000000000401071 &lt;+192&gt;: je 0x4010f9 &lt;phase_3+328&gt; 0x0000000000401077 &lt;+198&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x000000000040107c &lt;+203&gt;: mov $0x62,%eax 0x0000000000401081 &lt;+208&gt;: jmp 0x4010f9 &lt;phase_3+328&gt; 0x0000000000401083 &lt;+210&gt;: mov $0x73,%eax 0x0000000000401088 &lt;+215&gt;: cmpl $0xc6,0x14(%rsp) 0x0000000000401090 &lt;+223&gt;: je 0x4010f9 &lt;phase_3+328&gt; 0x0000000000401092 &lt;+225&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000401097 &lt;+230&gt;: mov $0x73,%eax---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x000000000040109c &lt;+235&gt;: jmp 0x4010f9 &lt;phase_3+328&gt; 0x000000000040109e &lt;+237&gt;: mov $0x63,%eax 0x00000000004010a3 &lt;+242&gt;: cmpl $0x398,0x14(%rsp) 0x00000000004010ab &lt;+250&gt;: je 0x4010f9 &lt;phase_3+328&gt; 0x00000000004010ad &lt;+252&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x00000000004010b2 &lt;+257&gt;: mov $0x63,%eax 0x00000000004010b7 &lt;+262&gt;: jmp 0x4010f9 &lt;phase_3+328&gt; 0x00000000004010b9 &lt;+264&gt;: mov $0x67,%eax 0x00000000004010be &lt;+269&gt;: cmpl $0x1a5,0x14(%rsp) 0x00000000004010c6 &lt;+277&gt;: je 0x4010f9 &lt;phase_3+328&gt; 0x00000000004010c8 &lt;+279&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x00000000004010cd &lt;+284&gt;: mov $0x67,%eax 0x00000000004010d2 &lt;+289&gt;: jmp 0x4010f9 &lt;phase_3+328&gt; 0x00000000004010d4 &lt;+291&gt;: mov $0x67,%eax 0x00000000004010d9 &lt;+296&gt;: cmpl $0x109,0x14(%rsp) 0x00000000004010e1 &lt;+304&gt;: je 0x4010f9 &lt;phase_3+328&gt; 0x00000000004010e3 &lt;+306&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x00000000004010e8 &lt;+311&gt;: mov $0x67,%eax 0x00000000004010ed &lt;+316&gt;: jmp 0x4010f9 &lt;phase_3+328&gt; 0x00000000004010ef &lt;+318&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x00000000004010f4 &lt;+323&gt;: mov $0x71,%eax 0x00000000004010f9 &lt;+328&gt;: cmp 0xf(%rsp),%al 0x00000000004010fd &lt;+332&gt;: je 0x401104 &lt;phase_3+339&gt;---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x00000000004010ff &lt;+334&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000401104 &lt;+339&gt;: mov 0x18(%rsp),%rax 0x0000000000401109 &lt;+344&gt;: xor %fs:0x28,%rax 0x0000000000401112 &lt;+353&gt;: je 0x401119 &lt;phase_3+360&gt; 0x0000000000401114 &lt;+355&gt;: callq 0x400b90 &lt;__stack_chk_fail@plt&gt; 0x0000000000401119 &lt;+360&gt;: add $0x28,%rsp 0x000000000040111d &lt;+364&gt;: retqEnd of assembler dump. 首先看一下输入格式： (gdb) x/s 0x40273e0x40273e: &quot;%d %c %d&quot; 这里疯狂跳转，而且到处写着explode_bomb，仔细看一下其实就是个case语句，比方说如果输入的第一个数是0，那么就把第三个数和0xde比较，即222，不想等就爆炸，即第三个数为222，再把第二个和0x66，比较，第二个是字符型，转成字符就是f，一个答案：0 f 222. phase_41234567891011121314151617181920212223242526272829303132(gdb) disassemble phase_4Dump of assembler code for function phase_4: 0x0000000000401151 &lt;+0&gt;: sub $0x18,%rsp 0x0000000000401155 &lt;+4&gt;: mov %fs:0x28,%rax 0x000000000040115e &lt;+13&gt;: mov %rax,0x8(%rsp) 0x0000000000401163 &lt;+18&gt;: xor %eax,%eax 0x0000000000401165 &lt;+20&gt;: lea 0x4(%rsp),%rcx 0x000000000040116a &lt;+25&gt;: mov %rsp,%rdx 0x000000000040116d &lt;+28&gt;: mov $0x4029ed,%esi 0x0000000000401172 &lt;+33&gt;: callq 0x400c40 &lt;__isoc99_sscanf@plt&gt; 0x0000000000401177 &lt;+38&gt;: cmp $0x2,%eax 0x000000000040117a &lt;+41&gt;: jne 0x401182 &lt;phase_4+49&gt; 0x000000000040117c &lt;+43&gt;: cmpl $0xe,(%rsp) 0x0000000000401180 &lt;+47&gt;: jbe 0x401187 &lt;phase_4+54&gt; 0x0000000000401182 &lt;+49&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000401187 &lt;+54&gt;: mov $0xe,%edx 0x000000000040118c &lt;+59&gt;: mov $0x0,%esi 0x0000000000401191 &lt;+64&gt;: mov (%rsp),%edi 0x0000000000401194 &lt;+67&gt;: callq 0x40111e &lt;func4&gt; 0x0000000000401199 &lt;+72&gt;: cmp $0x1b,%eax 0x000000000040119c &lt;+75&gt;: jne 0x4011a5 &lt;phase_4+84&gt; 0x000000000040119e &lt;+77&gt;: cmpl $0x1b,0x4(%rsp) 0x00000000004011a3 &lt;+82&gt;: je 0x4011aa &lt;phase_4+89&gt; 0x00000000004011a5 &lt;+84&gt;: callq 0x401741 &lt;explode_bomb&gt;---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x00000000004011aa &lt;+89&gt;: mov 0x8(%rsp),%rax 0x00000000004011af &lt;+94&gt;: xor %fs:0x28,%rax 0x00000000004011b8 &lt;+103&gt;: je 0x4011bf &lt;phase_4+110&gt; 0x00000000004011ba &lt;+105&gt;: callq 0x400b90 &lt;__stack_chk_fail@plt&gt; 0x00000000004011bf &lt;+110&gt;: add $0x18,%rsp 0x00000000004011c3 &lt;+114&gt;: retqEnd of assembler dump. 输入格式是两个整数，然后第一个必须小于等于14，第二个必须是27。再把第一个参数传到fun4里面，如果返回值与27相等，就通过，否则爆炸。那么fun4是啥呢？ 1234567891011121314151617181920212223Dump of assembler code for function func4: 0x000000000040111e &lt;+0&gt;: push %rbx 0x000000000040111f &lt;+1&gt;: mov %edx,%eax 0x0000000000401121 &lt;+3&gt;: sub %esi,%eax 0x0000000000401123 &lt;+5&gt;: mov %eax,%ebx 0x0000000000401125 &lt;+7&gt;: shr $0x1f,%ebx 0x0000000000401128 &lt;+10&gt;: add %ebx,%eax 0x000000000040112a &lt;+12&gt;: sar %eax 0x000000000040112c &lt;+14&gt;: lea (%rax,%rsi,1),%ebx 0x000000000040112f &lt;+17&gt;: cmp %edi,%ebx 0x0000000000401131 &lt;+19&gt;: jle 0x40113f &lt;func4+33&gt; 0x0000000000401133 &lt;+21&gt;: lea -0x1(%rbx),%edx 0x0000000000401136 &lt;+24&gt;: callq 0x40111e &lt;func4&gt; 0x000000000040113b &lt;+29&gt;: add %ebx,%eax 0x000000000040113d &lt;+31&gt;: jmp 0x40114f &lt;func4+49&gt; 0x000000000040113f &lt;+33&gt;: mov %ebx,%eax 0x0000000000401141 &lt;+35&gt;: cmp %edi,%ebx 0x0000000000401143 &lt;+37&gt;: jge 0x40114f &lt;func4+49&gt; 0x0000000000401145 &lt;+39&gt;: lea 0x1(%rbx),%esi 0x0000000000401148 &lt;+42&gt;: callq 0x40111e &lt;func4&gt; 0x000000000040114d &lt;+47&gt;: add %ebx,%eax 0x000000000040114f &lt;+49&gt;: pop %rbx 0x0000000000401150 &lt;+50&gt;: retq 显然是个递归函数，可以把它转成c语言函数然后遍历一下，经队友提示可以把断点打在第二个explode_bomb函数之前，直接输入a 27，这样就能跳过第一个explode_bomb，单步执行到fun4调用完毕，看一下返回值就行了，得到的结果是9，所以答案是9 27 phase_5123456789101112131415161718192021222324252627282930313233343536(gdb) disassemble phase_5Dump of assembler code for function phase_5: 0x00000000004011c4 &lt;+0&gt;: push %rbx 0x00000000004011c5 &lt;+1&gt;: sub $0x10,%rsp 0x00000000004011c9 &lt;+5&gt;: mov %rdi,%rbx 0x00000000004011cc &lt;+8&gt;: mov %fs:0x28,%rax 0x00000000004011d5 &lt;+17&gt;: mov %rax,0x8(%rsp) 0x00000000004011da &lt;+22&gt;: xor %eax,%eax 0x00000000004011dc &lt;+24&gt;: callq 0x401454 &lt;string_length&gt; 0x00000000004011e1 &lt;+29&gt;: cmp $0x6,%eax 0x00000000004011e4 &lt;+32&gt;: je 0x4011eb &lt;phase_5+39&gt; 0x00000000004011e6 &lt;+34&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x00000000004011eb &lt;+39&gt;: mov $0x0,%eax 0x00000000004011f0 &lt;+44&gt;: movzbl (%rbx,%rax,1),%edx 0x00000000004011f4 &lt;+48&gt;: and $0xf,%edx 0x00000000004011f7 &lt;+51&gt;: movzbl 0x402790(%rdx),%edx 0x00000000004011fe &lt;+58&gt;: mov %dl,(%rsp,%rax,1) 0x0000000000401201 &lt;+61&gt;: add $0x1,%rax 0x0000000000401205 &lt;+65&gt;: cmp $0x6,%rax 0x0000000000401209 &lt;+69&gt;: jne 0x4011f0 &lt;phase_5+44&gt; 0x000000000040120b &lt;+71&gt;: movb $0x0,0x6(%rsp) 0x0000000000401210 &lt;+76&gt;: mov $0x402747,%esi 0x0000000000401215 &lt;+81&gt;: mov %rsp,%rdi 0x0000000000401218 &lt;+84&gt;: callq 0x401472 &lt;strings_not_equal&gt;---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x000000000040121d &lt;+89&gt;: test %eax,%eax 0x000000000040121f &lt;+91&gt;: je 0x401226 &lt;phase_5+98&gt; 0x0000000000401221 &lt;+93&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000401226 &lt;+98&gt;: mov 0x8(%rsp),%rax 0x000000000040122b &lt;+103&gt;: xor %fs:0x28,%rax 0x0000000000401234 &lt;+112&gt;: je 0x40123b &lt;phase_5+119&gt; 0x0000000000401236 &lt;+114&gt;: callq 0x400b90 &lt;__stack_chk_fail@plt&gt; 0x000000000040123b &lt;+119&gt;: add $0x10,%rsp 0x000000000040123f &lt;+123&gt;: pop %rbx 0x0000000000401240 &lt;+124&gt;: retqEnd of assembler dump. 看到两个奇怪的地址0x402790，打印一下看看 x/s 0x402790 0x402790 &lt;array.3601&gt;: &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot; x/s 0x402747 0x402747: &quot;devils&quot; 输入格式为1个字符串，长度为6，然后去那句话里面找到这6个字母的偏移，从输入的字符里面依次取低4位与之比较，比如这里的偏移为：2 5 12 4 15 7 ，我对照ascii码表找了一个合格的答案0010-b 0101-e 1100-l 0100-t 1111-o 0111-w ，即beltow，试一下，通过了。 phase_612345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182(gdb) disassemble phase_6Dump of assembler code for function phase_6: 0x0000000000401241 &lt;+0&gt;: push %r13 0x0000000000401243 &lt;+2&gt;: push %r12 0x0000000000401245 &lt;+4&gt;: push %rbp 0x0000000000401246 &lt;+5&gt;: push %rbx 0x0000000000401247 &lt;+6&gt;: sub $0x68,%rsp 0x000000000040124b &lt;+10&gt;: mov %fs:0x28,%rax 0x0000000000401254 &lt;+19&gt;: mov %rax,0x58(%rsp) 0x0000000000401259 &lt;+24&gt;: xor %eax,%eax 0x000000000040125b &lt;+26&gt;: mov %rsp,%rsi 0x000000000040125e &lt;+29&gt;: callq 0x401777 &lt;read_six_numbers&gt; 0x0000000000401263 &lt;+34&gt;: mov %rsp,%r12 0x0000000000401266 &lt;+37&gt;: mov $0x0,%r13d 0x000000000040126c &lt;+43&gt;: mov %r12,%rbp 0x000000000040126f &lt;+46&gt;: mov (%r12),%eax 0x0000000000401273 &lt;+50&gt;: sub $0x1,%eax 0x0000000000401276 &lt;+53&gt;: cmp $0x5,%eax 0x0000000000401279 &lt;+56&gt;: jbe 0x401280 &lt;phase_6+63&gt; 0x000000000040127b &lt;+58&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000401280 &lt;+63&gt;: add $0x1,%r13d 0x0000000000401284 &lt;+67&gt;: cmp $0x6,%r13d 0x0000000000401288 &lt;+71&gt;: je 0x4012c7 &lt;phase_6+134&gt; 0x000000000040128a &lt;+73&gt;: mov %r13d,%ebx 0x000000000040128d &lt;+76&gt;: movslq %ebx,%rax 0x0000000000401290 &lt;+79&gt;: mov (%rsp,%rax,4),%eax 0x0000000000401293 &lt;+82&gt;: cmp %eax,0x0(%rbp) 0x0000000000401296 &lt;+85&gt;: jne 0x40129d &lt;phase_6+92&gt; 0x0000000000401298 &lt;+87&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x000000000040129d &lt;+92&gt;: add $0x1,%ebx 0x00000000004012a0 &lt;+95&gt;: cmp $0x5,%ebx 0x00000000004012a3 &lt;+98&gt;: jle 0x40128d &lt;phase_6+76&gt; 0x00000000004012a5 &lt;+100&gt;: add $0x4,%r12 0x00000000004012a9 &lt;+104&gt;: jmp 0x40126c &lt;phase_6+43&gt; 0x00000000004012ab &lt;+106&gt;: mov 0x8(%rdx),%rdx 0x00000000004012af &lt;+110&gt;: add $0x1,%eax 0x00000000004012b2 &lt;+113&gt;: cmp %ecx,%eax 0x00000000004012b4 &lt;+115&gt;: jne 0x4012ab &lt;phase_6+106&gt; 0x00000000004012b6 &lt;+117&gt;: mov %rdx,0x20(%rsp,%rsi,2) 0x00000000004012bb &lt;+122&gt;: add $0x4,%rsi 0x00000000004012bf &lt;+126&gt;: cmp $0x18,%rsi 0x00000000004012c3 &lt;+130&gt;: jne 0x4012cc &lt;phase_6+139&gt; 0x00000000004012c5 &lt;+132&gt;: jmp 0x4012e0 &lt;phase_6+159&gt; 0x00000000004012c7 &lt;+134&gt;: mov $0x0,%esi 0x00000000004012cc &lt;+139&gt;: mov (%rsp,%rsi,1),%ecx 0x00000000004012cf &lt;+142&gt;: mov $0x1,%eax 0x00000000004012d4 &lt;+147&gt;: mov $0x604300,%edx---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x00000000004012d9 &lt;+152&gt;: cmp $0x1,%ecx 0x00000000004012dc &lt;+155&gt;: jg 0x4012ab &lt;phase_6+106&gt; 0x00000000004012de &lt;+157&gt;: jmp 0x4012b6 &lt;phase_6+117&gt; 0x00000000004012e0 &lt;+159&gt;: mov 0x20(%rsp),%rbx 0x00000000004012e5 &lt;+164&gt;: lea 0x20(%rsp),%rax 0x00000000004012ea &lt;+169&gt;: lea 0x48(%rsp),%rsi 0x00000000004012ef &lt;+174&gt;: mov %rbx,%rcx 0x00000000004012f2 &lt;+177&gt;: mov 0x8(%rax),%rdx 0x00000000004012f6 &lt;+181&gt;: mov %rdx,0x8(%rcx) 0x00000000004012fa &lt;+185&gt;: add $0x8,%rax 0x00000000004012fe &lt;+189&gt;: mov %rdx,%rcx 0x0000000000401301 &lt;+192&gt;: cmp %rsi,%rax 0x0000000000401304 &lt;+195&gt;: jne 0x4012f2 &lt;phase_6+177&gt; 0x0000000000401306 &lt;+197&gt;: movq $0x0,0x8(%rdx) 0x000000000040130e &lt;+205&gt;: mov $0x5,%ebp 0x0000000000401313 &lt;+210&gt;: mov 0x8(%rbx),%rax 0x0000000000401317 &lt;+214&gt;: mov (%rax),%eax 0x0000000000401319 &lt;+216&gt;: cmp %eax,(%rbx) 0x000000000040131b &lt;+218&gt;: jge 0x401322 &lt;phase_6+225&gt; 0x000000000040131d &lt;+220&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000401322 &lt;+225&gt;: mov 0x8(%rbx),%rbx 0x0000000000401326 &lt;+229&gt;: sub $0x1,%ebp 0x0000000000401329 &lt;+232&gt;: jne 0x401313 &lt;phase_6+210&gt; 0x000000000040132b &lt;+234&gt;: mov 0x58(%rsp),%rax 0x0000000000401330 &lt;+239&gt;: xor %fs:0x28,%rax 0x0000000000401339 &lt;+248&gt;: je 0x401340 &lt;phase_6+255&gt; 0x000000000040133b &lt;+250&gt;: callq 0x400b90 &lt;__stack_chk_fail@plt&gt; 0x0000000000401340 &lt;+255&gt;: add $0x68,%rsp 0x0000000000401344 &lt;+259&gt;: pop %rbx 0x0000000000401345 &lt;+260&gt;: pop %rbp 0x0000000000401346 &lt;+261&gt;: pop %r12 0x0000000000401348 &lt;+263&gt;: pop %r13 0x000000000040134a &lt;+265&gt;: retqEnd of assembler dump. 代码贼长，看的心累，慢慢看下去会发现是个链表，而且有编号，而且要对其进行升序排列，而输入的格式又恰好是6个整数，显然就是要输入6个结点的序号了。重点是这个地址：0x604300，很突兀，看一下里面是啥（这个结果要输入一个顺序后才能看到 啊哦，这不就全出来了吗，按照升序排列的话，就是：3 1 6 2 5 4 secret_phase直接搜源码，把里面可疑的地址都打印看一下会发现有一个输入格式是“%d %d %s”，而且找到那个字符串为DrEvil，回忆一下前面那几关，只有第四关的输入格式是%d %d，跟要求的格式的前两个一样，退出重新输入答案，在9 27后面加DrEvil，过了第6关后就进了隐藏关了。 123456789101112131415161718192021222324(gdb) disassemble secret_phaseDump of assembler code for function secret_phase: 0x0000000000401389 &lt;+0&gt;: push %rbx 0x000000000040138a &lt;+1&gt;: callq 0x4017b6 &lt;read_line&gt; 0x000000000040138f &lt;+6&gt;: mov $0xa,%edx 0x0000000000401394 &lt;+11&gt;: mov $0x0,%esi 0x0000000000401399 &lt;+16&gt;: mov %rax,%rdi 0x000000000040139c &lt;+19&gt;: callq 0x400c20 &lt;strtol@plt&gt; 0x00000000004013a1 &lt;+24&gt;: mov %rax,%rbx 0x00000000004013a4 &lt;+27&gt;: lea -0x1(%rax),%eax 0x00000000004013a7 &lt;+30&gt;: cmp $0x3e8,%eax 0x00000000004013ac &lt;+35&gt;: jbe 0x4013b3 &lt;secret_phase+42&gt; 0x00000000004013ae &lt;+37&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x00000000004013b3 &lt;+42&gt;: mov %ebx,%esi 0x00000000004013b5 &lt;+44&gt;: mov $0x604120,%edi 0x00000000004013ba &lt;+49&gt;: callq 0x40134b &lt;fun7&gt; 0x00000000004013bf &lt;+54&gt;: test %eax,%eax 0x00000000004013c1 &lt;+56&gt;: je 0x4013c8 &lt;secret_phase+63&gt; 0x00000000004013c3 &lt;+58&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x00000000004013c8 &lt;+63&gt;: mov $0x402718,%edi 0x00000000004013cd &lt;+68&gt;: callq 0x400b70 &lt;puts@plt&gt; 0x00000000004013d2 &lt;+73&gt;: callq 0x4018dc &lt;phase_defused&gt; 0x00000000004013d7 &lt;+78&gt;: pop %rbx 0x00000000004013d8 &lt;+79&gt;: retq 逻辑似乎很简单，它把你的输入转成10进制数，先与1000(0x3e8)比较，如果大于1000直接炸掉，如果不相等，那么把它作为第二个参数传到fun7，如果返回值大于0，爆炸。看一下fun7 12345678910111213141516171819202122Dump of assembler code for function fun7: 0x000000000040134b &lt;+0&gt;: sub $0x8,%rsp 0x000000000040134f &lt;+4&gt;: test %rdi,%rdi 0x0000000000401352 &lt;+7&gt;: je 0x40137f &lt;fun7+52&gt; 0x0000000000401354 &lt;+9&gt;: mov (%rdi),%edx 0x0000000000401356 &lt;+11&gt;: cmp %esi,%edx 0x0000000000401358 &lt;+13&gt;: jle 0x401367 &lt;fun7+28&gt; 0x000000000040135a &lt;+15&gt;: mov 0x8(%rdi),%rdi 0x000000000040135e &lt;+19&gt;: callq 0x40134b &lt;fun7&gt; 0x0000000000401363 &lt;+24&gt;: add %eax,%eax 0x0000000000401365 &lt;+26&gt;: jmp 0x401384 &lt;fun7+57&gt; 0x0000000000401367 &lt;+28&gt;: mov $0x0,%eax 0x000000000040136c &lt;+33&gt;: cmp %esi,%edx 0x000000000040136e &lt;+35&gt;: je 0x401384 &lt;fun7+57&gt; 0x0000000000401370 &lt;+37&gt;: mov 0x10(%rdi),%rdi 0x0000000000401374 &lt;+41&gt;: callq 0x40134b &lt;fun7&gt; 0x0000000000401379 &lt;+46&gt;: lea 0x1(%rax,%rax,1),%eax 0x000000000040137d &lt;+50&gt;: jmp 0x401384 &lt;fun7+57&gt; 0x000000000040137f &lt;+52&gt;: mov $0xffffffff,%eax 0x0000000000401384 &lt;+57&gt;: add $0x8,%rsp 0x0000000000401388 &lt;+61&gt;: retqEnd of assembler dump. 显然是个递归函数，第一个参数显然很可疑，看一下是啥 12345678910111213141516171819202122232425262728293031(gdb) x/120 0x6041200x604120 &lt;n1&gt;: 36 0 6308160 00x604130 &lt;n1+16&gt;: 6308192 0 0 00x604140 &lt;n21&gt;: 8 0 6308288 00x604150 &lt;n21+16&gt;: 6308224 0 0 00x604160 &lt;n22&gt;: 50 0 6308256 00x604170 &lt;n22+16&gt;: 6308320 0 0 00x604180 &lt;n32&gt;: 22 0 6308512 00x604190 &lt;n32+16&gt;: 6308448 0 0 00x6041a0 &lt;n33&gt;: 45 0 6308352 00x6041b0 &lt;n33+16&gt;: 6308544 0 0 00x6041c0 &lt;n31&gt;: 6 0 6308384 00x6041d0 &lt;n31+16&gt;: 6308480 0 0 00x6041e0 &lt;n34&gt;: 107 0 6308416 00x6041f0 &lt;n34+16&gt;: 6308576 0 0 00x604200 &lt;n45&gt;: 40 0 0 00x604210 &lt;n45+16&gt;: 0 0 0 00x604220 &lt;n41&gt;: 1 0 0 00x604230 &lt;n41+16&gt;: 0 0 0 00x604240 &lt;n47&gt;: 99 0 0 00x604250 &lt;n47+16&gt;: 0 0 0 00x604260 &lt;n44&gt;: 35 0 0 00x604270 &lt;n44+16&gt;: 0 0 0 00x604280 &lt;n42&gt;: 7 0 0 00x604290 &lt;n42+16&gt;: 0 0 0 00x6042a0 &lt;n43&gt;: 20 0 0 00x6042b0 &lt;n43+16&gt;: 0 0 0 00x6042c0 &lt;n46&gt;: 47 0 0 00x6042d0 &lt;n46+16&gt;: 0 0 0 00x6042e0 &lt;n48&gt;: 1001 0 0 00x6042f0 &lt;n48+16&gt;: 0 0 0 0 二叉树。。。。。它结点的命名很有规律，直接画出来都行。 然后fun7的逻辑可疑整理一下，写成c语言大概是这样的： 123456789101112131415161718int fun7(BiTree T,int v)&#123;//v是传入的那个整数 int result; if(T)&#123; if(T-&gt;data &lt;= v)&#123; result = 0; if(T-&gt;data != v)&#123; result = 2 * fun7(T-&gt;right,v) + 1; &#125; &#125; else&#123; result = 2 * fun7(T-&gt;left,v); &#125; &#125; else&#123; result = -1; &#125; return result;&#125; 把那颗二叉树直接保存下来然后爆破一下即可，因为上周刚好写完了树的基本操作，所以自己电脑上有环境直接跑 123456for(int i = 0;i &lt; 1000;i++)&#123; if(!fun7(T,i))&#123; printf("answer: %d ",i); // break; &#125; &#125; 结果竟然只有4个？？？咦，厉害了 通关截图： tips总结了一点技巧（骚姿势）：b explode_bomb（这个应该都会）；如果绕不过检测函数，可以选择让它炸一次，然后看返回值；直接把包拖到本地，把检测host和记录答题状态的函数全部nop掉，这样在本地想怎么玩就怎么玩；IDA！！！！！！！（我就借助了IDA，捂脸φ(&gt;ω&lt;) φ(&gt;ω&lt;)]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>bomblab，csapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mirages-CTF writeup]]></title>
    <url>%2F2017%2F11%2F09%2FMirages-CTF-writeup%2F</url>
    <content type="text"><![CDATA[​ 这次的比赛分为3周，学长说第一周的挺基础，适合我们练手，正好最近离散停课，计算方法也没开，时间还算充足，就进坑了。虽说是个人赛，但实际上是和小队成员开黑做的23333。做出来的题基本是上是web和misc，re。。。。不会，先好好学学汇编以及计算机系统再说。在这稍微总结一下web和misc webWeb第一步打开链接就看到了这么一句话：一看你就不是组织的人,不用组织的ip，还想进组织的网站。23333，意思很明显了，伪造ip。刚开始纳闷了会儿，他们组织的ip到底是啥呀我也不知道哇，然后看到了这个链接的title上写着：110.110.110.110。好吧，修改一下X-Forwarded-For，刷新。然后是另一句话：I like Iphone X. Why don’t you use it? 伪造ua。。。注意这里有个坑，很多人还去搜了Iphone X的ua，其实不用，直接写Iphone X就OK了，题目给了Hint：简体中文。说的就是这个。再刷新：Actually, I’m Chinese,I don’t want to hear any other language。还要改语言。。。一开始我直接改成了Chinese，发现没反应，于是换成了zh-CN，可以了。再刷新：Not a local login. Do you want flag? 改host….其实就是改请求头而已，干嘛还要改4次，有毒。 flag:mctf{_Wh01e_FamilY} PHP加密题目：加油吧，骚年，莫名其妙的字符串，必有其来源 。打开链接一看，发现是一串base64. fTdydHtWOV9gaG5VXDJqPHcxPFxhbHRVfDdpPUV5TlxdQ2hpVWA= 1&#125;\7arltt&#123;UV|97_i`=hEnyUN\\2]jC&lt;hwi1U&lt;` 直接解密显然不对，应该还有一段加密函数。@kurumi扫了下后说有源码，顺便丢给了我们。 1234567891011121314151617181920212223&lt;?php$flag = 'flag&#123;********************************&#125;';$flag= strrev($flag);$key = '*';for($i=0;$i&lt;strlen($flag);$i++)&#123; $str[$i] = ord($flag[$i])+ord($key)*$i; while($str[$i]&gt;125) &#123; $str[$i] = $str[$i]-78; &#125;&#125;$out = "";for($i=0;$i&lt;strlen($flag);$i=$i+2)&#123; $out = $out.chr($str[$i]);&#125;for($i=1;$i&lt;strlen($flag);$i=$i+2)&#123; $out = $out.chr($str[$i]);&#125;echo base64_encode($out);?&gt; 加密流程大概就是，先逆转，然后遍历，令str这个数组的每一位等于对应位置上字符的ascii码值加上下标乘以42，如果这个数值大于125，就减78，直到小于等于125为止，然后再把str这个数组的偶数下标位抽出来，插到后面。大概就是把abcdef变成acebdf这样。 脚本写来写去还是有问题，最后没能跑出来QAQ，借鉴了队友@kurumi的脚本： 1234567891011121314151617181920212223242526272829303132import base64import sysdef decrypto(out, key): t = base64.b64decode(out) #print [ord(x) for x in t] a = t[:(len(t)+1)/2] b = t[(len(t)+1)/2:] t = '' for i in range(min(len(a), len(b))): t += a[0] t += b[0] a = a[1:] b = b[1:] if a: t += a[0] if b: t += b[0] t = [ord(x) for x in t] for i in range(len(t)): while t[i] &lt; i * 42: t[i] += 78 t[i] -= i * 42 if not 32 &lt;= t[i] &lt;= 126: t[i] += 78 print ''.join([chr(x) for x in t])[::-1]def main(): decrypto('fTdydHtWOV9gaG5VXDJqPHcxPFxhbHRVfDdpPUV5TlxdQ2hpVWA=', 42)main() 虽然可能会有点不精确，但最后修正一下就行了。。。(一开始有点死脑筋，但这题应该是可以直接恢复的，逻辑和算法太菜了哎) flag{e20ad328b0aa23210c57c48ac8b6f112} 忘记密码忘了童年的QQ账号以及密码！！这题的title也有提示，md5，而且源码里边也有提示：密码全是字母。一开始以为是md5碰撞，爆破什么的也试过。最后学长发现，这TM就是一个php弱类型比较。找纯数字和纯大写字母的md5值为0e开头的即可。 flag:MCTF{Md5_1s_So_SaD} 喵喵喵喜欢撸猫就一起来吧。title为：听说猫喜欢机器人。显然是robots协议，看一下，果然有源码： 123456789101112131415161718192021222324252627&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=gbk&quot;&gt;&lt;title&gt;听说猫喜欢机器人&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;./aabbcc.jpg&quot;&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php$flag=&apos;********&apos;;if (isset ($_GET[&apos;cat&apos;])) &#123; if (ereg (&quot;^[0-9b-f]+$&quot;, $_GET[&apos;cat&apos;]) === FALSE) echo &apos;喵喵好像特别喜欢小写字母和数字&apos;; else if ($_GET[&apos;cat&apos;]==0) &#123; if(strpos ($_GET[&apos;cat&apos;], &apos;miaomiao&apos;) !==FALSE) &#123; die(&apos;Flag: &apos;.$flag); &#125; else &#123; echo &apos;&lt;p&gt;好像必须要喵喵呢&lt;/p&gt;&apos;;&#125; &#125; else&#123;echo &apos;&lt;p&gt;喵喵迷路了&lt;/p&gt;&apos;;&#125; &#125;?&gt; 传入一个cat，先检测是否在0-9和b-f范围内，再判断是否为零，发现这里是弱类比较，只有两个等号，显然可以用0e绕，然后还要有miaomiao，也就是要有a，那就00截断吧。大概就是这样了构造url：http://116.196.124.92:32769?cat=0e2333%00miaomiao flag:mctf{you_get_ereg} phpbest!!!1php是世界上最好的语言！谁说不是我跟谁急！ 还加了个网易云链接：当初就不该学php。有闲情的话去听听吧23333。这次的title为：Secure Hash Algorithm又是Hash？？而且有这么一句：这货不是SQL，我绝对不骗人。要求输入name 和 pass来登录，试了下注入，好吧，真的不是。根据前面几题的经验，title提示都是有用的，于是开始考虑php的弱类型，用0e也不对。然后直接post数据，用数组试试，。。。！！！！过了？？？？ name[]=2&amp;pass[]=3 flag:mctf{This_is_the_fulage} 投身黑产的b佬1题目类似于一个老虎机，抽到05555就有flag，hint: bp真好用，直接用bp碰撞拿到flag。 flag:{Good_luck_Boy!} (万一是个妹子呢2333333 Misc这有flag下载下来是一张图片，Hint: 萌新温馨提示：使用二进制工具（010 editor, winhex）来查看文件/你听过base64吗。。。这提示约等于wp了吧。。。。16进制打开末尾有base64串，解密即可 flag:MCTF{th1s_ls_fL4g} 这有flag？还是图片，用stegesolve看一下，emmmm，没什么用，LSB也没有什么，binwalk分析一下 123456DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, EXIF standard12 0xC TIFF image data, big-endian, offset of first image directory: 813446 0x3486 Zip archive data, at least v2.0 to extract, compressed size: 17, uncompressed size: 15, name: flag.txt13591 0x3517 End of Zip archive 有压缩包，foremost 2.jpg ，直接解压那个zip包，发现里面有flag.txt，打开得到flag flag:MCTF{Real_F1Ag} 这有flag？？这个题又不小心存进了明文，按理来说应该要去改高度啥的才能看到flag，由于我有先strings的习惯，于是就。。。。 12345678strings 3.png | grep &#123;v/&#123;LSCs&#123;`:&gt;=e &lt;photoshop:LayerName&gt;MCTF&#123;Hhhh_g0t_1t&#125;&lt;/photoshop:LayerName&gt; &lt;photoshop:LayerText&gt;MCTF&#123;Hhhh_g0t_1t&#125;&lt;/photoshop:LayerText&gt;&#123;&amp;hPD &#123;[k&lt;&#123;A$FU 就直接拿到了flag。。。。 flag:MCTF{Hhhh_g0t_1t} 签到题加群，群相册有二维码，关注公众号发送flag即可。 falg:MCTF{We1c0me_2_MCTF} 这有flag？？？这个150分的题，本来脑洞还有点大的，但后来放了这么一个Hint: 萌新温馨提示：LSB/plaintext莫非是出题人怕被打？嗯哼？下载下来是一张图片和一个hint文件，而且hint没有后缀。LSB嘛，把图片提取一下，发现有个zip压缩包，改后缀，解压走起，有密码？？？？试试是不是伪加密，然而并不是。哎，它都已经给了提示了。。。明文攻击（然而我们做的时候并没有，还是qrzbing 提示我做出来的）看一下加密包，里面有flag.txt和一张图片，然后转而分析hint文件，binwalk一下： 1234567891011121314151617binwalk hintDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 Zip archive data, at least v2.0 to extract, compressed size: 346, uncompressed size: 1312, name: [Content_Types].xml915 0x393 Zip archive data, at least v2.0 to extract, compressed size: 239, uncompressed size: 590, name: _rels/.rels1715 0x6B3 Zip archive data, at least v2.0 to extract, compressed size: 244, uncompressed size: 817, name: word/_rels/document.xml.rels2281 0x8E9 Zip archive data, at least v2.0 to extract, compressed size: 854, uncompressed size: 2973, name: word/document.xml3182 0xC6E Zip archive data, at least v2.0 to extract, compressed size: 1761, uncompressed size: 8398, name: word/theme/theme1.xml4994 0x1382 Zip archive data, at least v2.0 to extract, compressed size: 1337, uncompressed size: 3725, name: word/settings.xml6378 0x18EA Zip archive data, at least v2.0 to extract, compressed size: 501, uncompressed size: 1444, name: word/fontTable.xml6927 0x1B0F Zip archive data, at least v2.0 to extract, compressed size: 295, uncompressed size: 655, name: word/webSettings.xml7272 0x1C68 Zip archive data, at least v2.0 to extract, compressed size: 364, uncompressed size: 711, name: docProps/app.xml7946 0x1F0A Zip archive data, at least v2.0 to extract, compressed size: 385, uncompressed size: 757, name: docProps/core.xml8642 0x21C2 Zip archive data, at least v2.0 to extract, compressed size: 2904, uncompressed size: 29103, name: word/styles.xml11591 0x2D47 Zip archive data, at least v2.0 to extract, compressed size: 11906, uncompressed size: 12427, name: docProps/key.xml24346 0x5F1A End of Zip archive 又是一个zip包，改后缀打开，注意到docProps目录下有个key.xml，而且还是2017.10.22修改过的，很明显了，然后分析一下这个key.xml，发现它是一张图片，那么很显然，明文攻击的已知文件就在这了。压缩，直接爆，1分钟不到就爆开了，打开flag.txt，发现里面是这样的： 1VSBmaW5kIG1lLHRoZW4gSSdsbCBnaXZlIHUgbXkgZmxhZzpNQ1RGe0xTQl8mJl9wbEBpblRleHR9LkRvIHUgdGhpbmsgaXMgaXQgc28gZnVja2luZyBlZ2c/bGFpIGRhIHdvIHlhIGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaA== 显然是个base64，但后面那一串重复的什么鬼啊，解密一下看看 1U find me,then I&apos;ll give u my flag:MCTF&#123;LSB_&amp;&amp;_pl@inText&#125;.Do u think is it so fucking egg?lai da wo ya hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 看到了吗？lai da wo ya。。。丫的以为我不敢吗？ flag:MCTF{LSB_&amp;&amp;_pl@inText} 这有flag-ex本来Hint给的是Water，可能出题人觉得太隐晦了，后来就直接改成了水印。。我也不是很懂盲水印这玩意儿，google了一波，在github上找到了这段脚本，装上python的一些第三方库后跑一个命令就OK了。参考链接 （PS：感觉这200分的题比150分的好做，如果都不给Hint的话。 flag:MCTF{W4T3RMark_1s_c00l} 最后来一波霸气的图片5连 话说还是好好学数据机构离散和数电，其余时间写写python，看看二进制，刷刷英语好了，太菜了，肝不动、肝不动。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈与堆]]></title>
    <url>%2F2017%2F10%2F28%2F%E6%A0%88%E4%B8%8E%E5%A0%86%2F</url>
    <content type="text"><![CDATA[​ 昨天参加了Pwn师傅的入门课，嗯，&lt;（我以为大家都是零基础，结果最后发现只有我才是）.png&gt;，（传图好麻烦，偷点懒。）二进制安全对底层的知识要求还是挺高的，也难怪pwn入门难度是最高的233333。今天稍微学习了一下堆和栈的区别，写点笔记。 程序的内存分配一般来说，由c/c++编译的程序（划重点：已经编译！）要占用的内存分为以下几个部分： 1.栈区（stack）：一般由系统自动分配释放、存放函数参数值、局部变量值等，操作方式有点类似于数据结构中的栈（然而要复杂的多，一开始pwn师傅问我们懂不懂栈的时候我还以为是数据结构中的栈，尴尬.png） 2.堆区（heap）：一般由程序员自主分配和释放，没有释放的话OS有可能会回收，而且和数据结构中的堆区别很大。 3.全局（静态）区（static）：初始化的全局变量和静态变量会放在同一块区域，未初始化的则会放在相邻的另一块区域，程序运行结束后空间由系统释放。 4.常量区：比如字符串。程序运行结束后空间由系统释放。 5.代码区：即函数的二进制代码。 示例：（这例子貌似被引用了千万次了23333） 1234567891011121314int a = 0; //全局初始化区char *p1; //全局未初始化区main()&#123; int b; //栈 char s[] = "abc";// 栈 char *p2; 栈 char *p3 = "123456"; //123456\0在常量区，p3在栈上。 static int c =0； //全局（静态）初始化区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区。 strcpy(p1, "123456"); //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。&#125; 堆与栈的比较申请方式栈：系统自动分配。比如在函数里面声明局部变量 int i； 堆：程序员自行分配，并指定大小。c中的malloc ， c++中的 new 申请后系统的响应栈：只要剩余空间大于申请空间，系统即为其提供相应内存，否则会异常。 堆：这里又有一个知识点：OS有一个记录空闲内存的链表，收到堆空间申请时会开始遍历这个链表，找到一个空间大于所要申请的空间后便把这个结点从空闲结点链表里面删掉并将这块空间分给程序，而且大多数系统会自动记录这块空间的首地址以便于正确释放这块空间。多余的空间则会返回给空闲链表。 申请大小的限制栈：在win下，栈的地址是往低地址扩展的，而且是连续的内存区域，所以栈顶的地址以及栈的最大容量，系统都已经固定好了，无法修改，因此栈能够获得的空间较小。 堆：与栈相反，堆是往高地址扩展的数据结构，不连续，显然，因为这是系统在空闲链表里面找到的内存，然后分给你的，当然是各个地方的空间都有。所以堆获得的空间比较灵活，空间大小也就更大了。 申请效率栈：由系统自动分配，速度比较快，但无法控制。 堆：自行分配，一般来说速度比栈要慢，而且很容易产生内存碎片， 但用起来最方便。 存储内容栈：函数调用时，最先进栈的是主函数中后的下一条指令的地址，接着是函数的参数，大部分c的编译器中，参数都是从右到左入栈的，接着是函数的局部变量，但静态变量不会入栈。当函数开始调用时，这时就体现遵循后进先出的原则了，局部变量最先出栈，然后是参数，最后是栈顶指针存的地址，也就是主函数中的下一条指令，程序从这里继续运行。 堆：一般，堆的头部会用一个字节来存放堆的大小，具体由程序员安排。 存取效率示例代码： 12345678910#includeint main()&#123; char a = 1; char c[] = "1234567890"; char *p ="1234567890"; a = c[1]; a = p[1]; return 0;&#125; c[]在运行时刻赋值，而*p在编译时确定，但在以后的存取中，栈上的数组比指针指向的字符串要快。具体原理自己看一下汇编的代码就清楚了。 小结使用栈就像去餐馆吃饭，只要点菜（申请）和吃（使用），吃饱了就可以走人，不必理会切菜、洗菜什么的细节，快捷方便，但是自由度小。 使用堆就是自己动手做了，比较麻烦，要顾细节，但是自由度大。 感想​ pwn的门槛真心比web高了不少，得恶补基础知识才行，都大二的人了，还啥都不懂，怪不得是鶸字辈。 参考出处：一条鱼@博客园]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我就是想试试这个竞赛的名字究竟能打多长多长多长-nuaactf-WriteUp]]></title>
    <url>%2F2017%2F10%2F22%2F%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E8%AF%95%E8%AF%95%E8%BF%99%E4%B8%AA%E7%AB%9E%E8%B5%9B%E7%9A%84%E5%90%8D%E5%AD%97%E7%A9%B6%E7%AB%9F%E8%83%BD%E6%89%93%E5%A4%9A%E9%95%BF%E5%A4%9A%E9%95%BF%E5%A4%9A%E9%95%BF-nuaactf-WriteUp%2F</url>
    <content type="text"><![CDATA[​ 这次准备还算充足，然而题目的难度有点点超乎我们的预料，所以并不是很顺利，但最终凭借着两位队友的carry，最后成绩也还可以。（话说我当初干嘛要提这样一个鬼名字，而且他们两居然还采用了。。。title即队名）以下是wp NUAACTF2017 WriteUp 队名： 我就是想试试这个竞赛的名字究竟能打多长多长多长 队员：秦瑞哲、刘琨奇、程斌 MISC1 ++–看到问题立马想到了BrainFuck，然而打开一看却是各种颜文字… 参考文章: https://qing.su/article/119.html， 注意到BrainFuck的结构，观察前部结构： ‘( ͡° ͜ʖ ͡°)‘由’+‘替代; ‘( ͡°(‘由’[‘替代，对应地，’) ͡°)‘由’]‘替代; ‘ᕦ( ͡°ヮ ͡°)ᕥ‘由’&gt;‘替代。 之后观察后面的结构： ‘(&gt; ͜ʖ(∩ ͡° ͜ʖ ͡°)⊃━☆ﾟ.*)‘由’.‘替代; ‘(♥ ͜ʖ♥)‘由’-‘替代; ‘(∩ ͡° ͜ʖ ͡°)⊃━☆ﾟ.*‘由’&lt;‘替代。 至此，我们可以得到正确的BrainFuck表达式 123456789101112131415161718192021222324++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;++++++++++.+++++++.--------------------..++.+++++++++++++++++.--------------.+++++++++++++++++++++.-------------------------.++++++++++++++++.&lt;------------------.---.&gt;----.--------.+++++++++++++++.------------------.++++++++.------------.+++++++++++++++++.&lt;.&gt;+++++.--.++++++++++. 在网站: https://sange.fi/esoteric/brainfuck/impl/interp/i.html 上解密，得到flag MISC3 recover（吐槽一下，在chrome输flag，没有选中的话是看不见的。。。） 下载后发现是个png图片，但打不开 第一反应是去改文件头，还是选择先strings一下 然后就有了点惊喜 瞄了一眼已解决列表，卧槽，已经7个队伍了，论抢一血的重要性哇 话说300分是不是多了点。。。。。。 web50右键源码，佛祖保佑你不出bug。 web150 题目循环检测alert并删除，试了各种编码无效，去做web300的时候才想到jsfuck，可以绕过检测并且由js执行。 当然要先闭合前边的引号，后边可以闭合或直接注释掉。 web300按照题目意思，只能使用 []!+ 四个字符进行构造，eval(input)可以对input进行js解析，综合题意，只要可以eval(input)构造出’alert’字符串即可。 一开始当然直接jsfuck，然后由于()被过滤掉了就fail。然后各种困惑，各种google之后，get到jsfuck的编码方式，就解开了本题。记录如下： 12345678910111213141516171819202122232425262728以下内容基于[] =&gt; []然后!可以将类型转化为布尔型![] =&gt; false!![] =&gt; true+可以将类型转化为整形+![] =&gt; 0+!![] =&gt; 1!![]+!![] =&gt; 2 然后+[]可以转化为字符串![]+[] =&gt; &apos;false&apos;类似于数组取下标(![]+[])[+!![]] =&gt; &apos;a&apos;然后就可以类似的从&apos;false&apos;, &apos;true&apos;中读出&apos;a&apos;,&apos;l&apos;,&apos;e&apos;,&apos;r&apos;,&apos;t&apos;。em...但是...题目过滤了小括号。需要绕一下![]+[] =&gt; &apos;false&apos;[![]+[]] =&gt; [&apos;false&apos;][![]+[]][+[]] =&gt; &apos;false&apos;[![]+[]][+[]][+!![]] =&gt; &apos;a&apos;最后用加号拼起来即可。这题最后一半靠蒙，\笑哭\笑哭 截图如下：]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>nuaa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四届世安杯酱油记]]></title>
    <url>%2F2017%2F10%2F08%2F%E7%AC%AC%E5%9B%9B%E5%B1%8A%E4%B8%96%E5%AE%89%E6%9D%AF%E9%85%B1%E6%B2%B9%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[​ 给21号的校赛练练手。 @kurum 主攻web，@a-lie-Z 主要负责misc和steganography，我试了下有思路的题，下面是我找到的flag（emmm，为什么不说是我做出来的题呢？）@a-lie-Z 做的题：传送门 ，以及 @kurum 做的题：传送门 ctf入门级题目​ 戳进去看发现有源码，放一下php代码： 12345678if (isset ($_GET['password'])) &#123; if (ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE) echo '&lt;p class="alert"&gt;You password must be alphanumeric&lt;/p&gt;'; else if (strpos ($_GET['password'], '--') !== FALSE) die($flag); else echo '&lt;p class="alert"&gt;Invalid password&lt;/p&gt;';&#125; ​ 第一个if要求password 必须为数字和字母，第二个if要求子串中得有”–”，看上去有点矛盾，而输入数组会使ereg函数发生错误，返回false，因此可以通过第一个if，而字符数组同样会使得strpos函数出错返回Null，与严格的FALSE不符，这样就能通过第二个if判断。于是构造url 为 http://ctf1.shiyanbar.com/shian-rao/password[]=xxx 这样就能绕过了。 曲奇饼​ 嗯，名字貌似提示需要构造cookie。打开题目链接后发现url有点奇怪：http://ctf1.shiyanbar.com/shian-quqi/index.php?line=&amp;file=a2V5LnR4dA== 后面那个 file=a2V5LnR4dA== 有点像base64，解密一下后发现是key.txt，然而这里并没有什么，改了line参数也没什么鸟用。于是考虑获取真正index.php，去掉后面的参数后发现依旧会重定向到这里，然后考虑加参数，受key.txt的提示，我把index.php用base64加密后传了上去 http://ctf1.shiyanbar.com/shian-quqi/index.php?line=&amp;file=aW5kZXgucGhw 发现什么都没有，试着把line改成1，输出了 error_reporting(0); 改成2试试 $file=base64_decode(isset($_GET[&#39;file&#39;])?$_GET[&#39;file&#39;]:&quot;&quot;); 嗯，啥也别说了，写python，获取完整的php代码，如下： 1234567891011121314151617error_reporting(0);$file=base64_decode(isset($_GET['file'])?$_GET['file']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;file=a2V5LnR4dA==");$file_list = array('0' =&gt;'key.txt','1' =&gt;'index.php',);if(isset($_COOKIE['key']) &amp;&amp; $_COOKIE['key']=='li_lr_480')&#123;$file_list[2]='thisis_flag.php';&#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125; ​ 嗯，果然和名称暗示的一样，构造cookie，传入&#39;key&#39;=&#39;li_lr_480&#39;，再把$file改成thisis_flag.php的base64形式即可。python代码如下： 1234567import requests cookie = &#123;'key':'li_lr_480'&#125;for i in range(50): url="http://ctf1.shiyanbar.com/shian-quqi/index.php?line="+str(i)+"&amp;file=dGhpc2lzX2ZsYWcucGhw" ans = requests.get(url, cookies=cookie) print ans.text 拿到flag。 console​ 用PEiD打开后发现是.net框架，用ILSpy，打开，把重要文件的代码整合，核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556internal class MM&#123; private static int C(int A_0, int A_1) &#123; return (new int[] &#123; 2, 3, 5, 7, 11, 13, 0x11, 0x13, 0x17, 0x1d, 0x1f, 0x25, 0x29, 0x2b, 0x2f, 0x35,0x3b, 0x3d, 0x43, 0x47, 0x49, 0x4f, 0x53, 0x59, 0x61, 0x65, 0x67, 0x6b, 0x6d, 0x71 &#125;)[A_1] ^ A_0; &#125; private static string flag(string A_0) &#123; byte[] bytes = Encoding.ASCII.GetBytes(A_0); return &quot;flag&#123;&quot; + BitConverter.ToString(new MD5CryptoServiceProvider().ComputeHash(bytes)).Replace(&quot;-&quot;, &quot;&quot;) + &quot;&#125;&quot;; &#125; private static void count(string A_0, int A_1, ref string A_2) &#123; int num = 0; if (0 &lt; A_0.Length) &#123; do &#123; char c = A_0[num]; int num2 = 1; do &#123; c = Convert.ToChar(MM.C(Convert.ToInt32(c), num2)); num2++; &#125; while (num2 &lt; 15); A_2 += c; num++; &#125; while (num &lt; A_0.Length); &#125; A_2 = MM.flag(A_2); &#125; private static void main(string[] A_0) &#123; string b = null; string value = string.Format(&quot;&#123;0&#125;&quot;, DateTime.Now.Hour + 1); string a_ = &quot;CreateByTenshine&quot;; MM.count(a_, Convert.ToInt32(value), ref b); string a = Console.ReadLine(); if (a == b) &#123; Console.WriteLine(&quot;u got it!&quot;); Console.ReadKey(true); &#125; else &#123; Console.Write(&quot;wrong&quot;); &#125; Console.ReadKey(true); &#125;&#125; c#脚本 123456789101112131415161718using System;using System.Security.Cryptography;using System.Text; namespace ConsoleApplication1&#123; class Program &#123; static void Main(string[] args) &#123; string a = &quot;[j&#125;yl&#125;ZaL&#125;vkpqv&#125;&quot;; byte[] bytes = Encoding.ASCII.GetBytes(a); string b = &quot;flag&#123;&quot; + BitConverter.ToString(new MD5CryptoServiceProvider().ComputeHash(bytes)).Replace(&quot;-&quot;, &quot;&quot;) + &quot;&#125;&quot;; Console.WriteLine(b); Console.ReadLine(); &#125; &#125;&#125; ​ 本机没配c#环境，随便找个在线网站跑就OK。 low​ 打开后发现是一张图片，看通道没什么反应，分析也没什么头绪。但从名字来看，可能是要把低位的0都获取出来，然后拼图，用python跑一下试试（matlab本机没有环境，线上貌似没法上传图片）。 123456789101112131415161718192021import Imagedef foo(): im=Iamge.open('low.bmp') im2=im.copy() pix=im2.load() width,height=im2.size for x in xrange(0,width): for y in xrange(0,height): #LSB if pix[x,y]&amp;0x1==0: pix[x,y]=0 #黑 else: pix[x,y]=255 im2.show() passif __name__ == '__main__': foo() 貌似成功了，可以得到一张图片，左上角有一个二维码，反色扫一下即可。 珍妮的QQ号​ 下载是个压缩包，解压后就是一个txt文件，里面的内容： 1珍妮换了一个新的QQ号码，原来的号码和新的号码都是5位靓号哦；其次，新的号码是原来号码的4倍，并且原来的号码倒着写正好是新的号码，请问，新号码是多少，新号码即为key。 很简单的编程题，直接上c代码。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main ()&#123; int n; for(n = 10001;n &lt;= 25000;n++) &#123; if((n * 4) == MyFunction(n)) printf(" %d ",n * 4); &#125; return 0;&#125;int MyFunction(int number) &#123; int k, fig=0, i, j, num, sum=0; k=number; while(k!=0) &#123; ++fig; //fig用来保存输入的数的位数 k /= 10; &#125; for(i=0; i&lt;fig; i++) &#123; num = number % 10; //求余数 for(j=0; j&lt;fig-i-1; j++) num = num*10; //余数乘上所对应的的10的次方 sum = sum + num; number /= 10; &#125; return sum;&#125; 跑出来结果是87912. RSA​ 打开是一个message.txt文件，里面写着： 12c = 2044619806634581710230401748541393297937319n = 92164540447138944597127069158431585971338721360079328713704210939368383094265948407248342716209676429509660101179587761913570951794712775006017595393099131542462929920832865544705879355440749903797967940767833598657143883346150948256232023103001435628434505839331854097791025034667912357133996133877280328143 RSA的具体原理还不是很懂，大概说的就是公钥私钥什么的，把c复制到google然后。。。就搜出了flag。。。（→_→这线上赛的题也是够了，然后发现，其他有些题也能搜出来，无语了。。。） 贴一下大佬的话： Nietypowa rzecz jest taka, ze wykładnik szyfrujący nie jest podany i c jest bardzo małe w porównaniu do n. To sugeruje że może e było tak małe że m^e nie przekroczyło n, albo tylko nieznacznie. Żeby to sprawdzić postanowiliśmy policzyć k-te pierwiastki całkowite dla c w poszukiwaniu e: 以及求解代码： 1234567891011121314import gmpy2from src.crypto_commons.generic import long_to_bytesdef main(): c = 2044619806634581710230401748541393297937319 n = 92164540447138944597127069158431585971338721360079328713704210939368383094265948407248342716209676429509660101179587761913570951794712775006017595393099131542462929920832865544705879355440749903797967940767833598657143883346150948256232023103001435628434505839331854097791025034667912357133996133877280328143 for i in range(2, 10): root = gmpy2.iroot(c, i)[0] if root**i == c: print(i, long_to_bytes(root))main() 然后flag为so_low ，呃，RSA很low吗？ 喵喵喵？ （比赛虽然有点水，但自己更水，ctf还是适合作为普及知识面的竞赛）]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF传送门]]></title>
    <url>%2F2017%2F09%2F29%2FCTF%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[​ 看到不错的分享，直接码在自己博客上比较方便(其实是chrome不想加那么多的书签QAQ，CTF方面的学习资料会继续在这补)。不过有的貌似挂了，比如我挺喜欢的IDF实验室 http://edu.gooann.com/ 谷安网校http://www.jikexueyuan.com/ 极客学院http://www.hetianlab.com/ 合天http://www.moonsos.com/ 米安网http://www.ichunqiu.com/ i 春秋http://www.honyaedu.com/ -红亚http://www.baimaoxueyuan.com/ 白帽学院http://www.simplexue.com/ctf/index 西普学院http://www.imooc.com/course/list 慕课http://www.secbox.cn/ 安全盒子http://www.freebuf.com/ freebufhttp://bobao.360.cn/ 360安全播报http://www.wooyun.org/ 乌云http://drops.wooyun.org/ 乌云知识库http://wiki.wooyun.org/ WooYun WiKihttps://www.91ri.org/ 91rihttps://www.t00ls[.NET](http://lib.csdn.net/base/dotnet)/toolshttp://www.ijiandao.com/ 爱尖刀http://www.secwk.com/article/index.html 威客众测http://bluereader.org/ 深蓝阅读http://www.shentou.org/ 黑客安全军火库http://netsecurity.51cto.com/ 51ctohttp://security.csdn.net/ csdnhttp://www.80sec.com/ 80sec teamhttps://security.alibaba.com/blog.htm?spm=0.0.0.0.knOqaI 阿里巴巴安全响应中心http://security.tencent.com/index.[PHP](http://lib.csdn.net/base/php)/blog 腾讯安全应急响应中心 博客http://security.360.cn/blog 360安全应急响应中心 博客http://sec.baidu.com/index.php?research/list 百度安全应急响应中心 博客 博客推荐http://security.tencent.com/index.php/bloghttp://217.logdown.com/ 217http://www.blue-lotus.net blue-lotus 蓝莲花http://blog.0ops.net/ 0opshttp://le4f.net/ e4fhttp://www.programlife.net/ 代码疯子http://www.hackdog.me/ redrain’bloghttp://www.syjzwjj.com/ 俊杰http://syclover.sinaapp.com/ 三叶草安全小组http://appleu0.sinaapp.com/ appleU0大大http://bl4ck.in/ tomato表哥http://www.sco4x0.com/ 4叔叔http://laterain.sinaapp.com/ 白神http://0nly3nd.sinaapp.com/ 0nly3ndhttp://hijacks.in/ LateRain’bloghttp://www.waitalone.cn/ 独自等待http://evilcos.me/ 余弦http://www.moonsec.com/ 暗月http://www.cnblogs.com/xuanhun/ 玄魂https://www.leavesongs.com/ 离别歌http://huaidan.org/ 鬼仔http://www.03sec.com/ sky的自留地http://joychou.org/ jc老师http://www.unhonker.com/ 90’s bloghttp://www1.taosay.net/ 道哥的黑板报http://blog.knownsec.com/ 知道创于http://www.sadk.org/ 焠安http://www.cnseay.com/ seay’bloghttp://blog.aptsec.net/ AptSec Teamhttp://lcx.cc/ 网络安全研究中心http://www.kali.org.cn/ kali中文网http://xiao106347.blog.163.com/ xiao106347 kali折腾更多大家推荐 渗透:http://www.wooyun.org/ 乌云http://bbs.blackbap.org/ 习科http://www.1937cn.net/ 1937http://forum.cnsec.org/ 暗组http://www.k33nteam.org/ keen teamhttp://forum.eviloctal.com/ 邪恶八进制http://www.evil0x.com/ 邪恶十六进制http://www.myhack58.com/ 黑吧安全吧http://www.cnhonkerarmy.com/ 中国红客 红盟http://www.chinahacker.com/ 中国黑客联盟http://www.hxhack.com/ 华夏黑客联盟http://www.heikexiehui.com/ 中国黑客协会官网http://www.hackbase.com/ 黑基http://www.2cto.com/ 红黑联盟http://bbs.2cto.com/ 红黑联盟论坛http://www.hackwd.com/http://www.heishou.com.cn/ 黑手安全网https://www.sitedirsec.com/ 非安全中国网http://www.zatokasztuki.com/ 学生技术联盟 逆向http://www.52pojie.cn/ 吾爱破解http://bbs.pediy.com/ 看雪论坛一蓑烟雨貌似被关了，逆向方面了解不多，问问表哥们吧( ?? ω ?? )y 编程http://www.he11oworld.com/ hello wordhttp://www.w3school.com.cn/ w3schoolhttp://www.runoob.com/ 菜鸟http://www.51zxw.net/https://github.com/http://navisec-[Git](http://lib.csdn.net/base/git).qiniudn.com/http://c.biancheng.net/cpp/http://www.liaoxuefeng.com/http://www.php100.com/https://ruby-china.org/wikihttp://bbs.csdn.net/forums/[Java](http://lib.csdn.net/base/javaee)/http://outofmemory.cn/tutorial/ 书籍http://zhuanlan.zhihu.com/Evi1m0/19706178 Evi1m0: 书籍推荐http://www.douban.com/doulist/3339701/ 信息安全必读书单http://www.douban.com/doulist/1363865/ 信息安全经典书籍http://www.zhihu.com/question/21390646http://my.oschina.net/bluefly/blog/335409?utm_source=tuicool&amp;utm_medium=referral Web安全核心书单连载《安全参考》http://www.douban.com/group/topic/72383272/ (2013年第一期–2015年第一期)全集《书安》(更新中)http://www.secbox.cn/hacker/8205.html 书安SecBook 第一期《icloud iOS安全大揭秘》http://www.secbox.cn/hacker/7366.html 书安SecBook 第二期《信息安全攻防赛》渗透实战文章可以看看里的杨凡(http://blog.sina.com.cn/s/articlelist_1758675673_4_1.html)和法克文章（http://pan.baidu.com/share/link?shareid=249629&amp;uk=2198816663） 工具(黑软有分风险，最好在虚拟机里搞)ftp://222.18.158.199/(校园网内网可以访问，不仅仅只有工具哦，有许多总结，各方面的)http://forum.cnsec.org/thread-94330-1-1.html 2015暗组工具包（渗透）http://bbs.secbox.cn/thread-196-1-1.html 2015_安全盒子工具包http://www.secbox.cn/hacker/tools/3552.html 法客论坛2015工具包-第三版http://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=388015 吾爱破解工具包 2015/7/22（逆向）http://down.52pojie.cn/ 爱盘 – 在线破解工具包，教程，http://www.52pojie.cn/thread-341238-1-1.html 吾爱破解论坛专用破解虚拟机ctf常用工具包请看http://tieba.baidu.com/p/3933947157里面群文件 其他http://www.zhihu.com/topic/19558642 黑客知乎话题http://www.zhihu.com/topic/20011446 ctf知乎话题http://www.zhihu.com/topic/19561983 信息安全知乎话题http://zhuanlan.zhihu.com/evilcos/19961466 余弦知乎专栏 CTF方面http://blog.idf.cn/2015/02/ctf-field-guide/http://tieba.baidu.com/p/3933947157 ctf大全https://ctftime.org/event/list/upcoming 各种CTF赛事预告(ps:国内各个高校或企业举办的比赛请进http://tieba.baidu.com/p/3933947157里面的群) 平时ctf练习 ctf逆向:http://reversing.kr/http://pwnable.kr/http://exploit-exercises.com/http://overthewire.orghttp://security.cs.rpi.edu/courses/binexp-spring2015/ bin 干货区http://www.52pojie.cn/forum-67-1.html 『2014CrackMe大赛』 SQL:https://github.com/Audi-1/sqli-labshttp://redtiger.labs.overthewire.org/ ctf XSS:http://prompt.ml/http://xss.pkav.net/xss/http://www.doscn.org/xss/http://xss-quiz.int21h.jp/http://escape.alf.nu/ ctf综合练习： http://hackinglab.cn/ 网络信息安全攻防学习平台http://captf.com/ ctf题目http://cafebabe.cc/nazo/ 脑洞开发，与ctf只有那么一点关系，有85关了( ?? ω ?? )yhttp://1111.segmentfault.com/ 光棍节程序员闯关秀http://www.helloisa.com/test/http://www.fj543.com/hack/ 黑客丛林之旅http://monyer.com/game/game1// 梦之光芒的小游戏http://oj.xctf.org.cn/ XCTF_OJ练习平台http://hackgame.blackbap.org/ 习科黑客游戏http://ctf.3sec.cn/ Jlu.CTFhttp://www.baimaoxueyuan.com/ctf 白帽学院ctf挑战赛http://www.ichunqiu.com/tiaozhans i春秋ctf挑战http://ctf.idf.cn/ idf 实验室http://ctf.moonsos.com/pentest/index.php 米安网ctfhttp://www.hetianlab.com/CTFrace.html 合天ctfhttp://www.shiyanbar.com/ctf/index 实验吧(前名西普学院）http://hkyx.myhack58.com/ 黑吧安全网-红客闯关游戏http://202.108.211.5/ 实训竞赛系统 国外比较好的几个综合练习平台http://www.wechall.nethttp://insight-labs.org/http://wargame.kr/http://canyouhack.it/http://hackit.sinaapp.com/http://webhacking.kr/http://fun.coolshell.cn/http://ringzer0team.com/challengehttps://backdoor.sdslabs.co/http://smashthestack.org/ 漏洞利用练习网站 ctf writeup(WP):直接百度:writeup(一边看一边总结，有道笔记，印象笔记什么的，最好能复现)另外乌云和360安全播报上有些WPhttp://drops.wooyun.org/?s=writeup&amp;submit=%E6%90%9C%E7%B4%A2http://bobao.360.cn/ctf/https://github.com/ctfs/ 各种 writeuphttp://sec.yka.me/ CTF Writeup Summaryhttps://ctf-team.vulnhub.com/ Write Ups ​ 原地址： 链接1 A方向： RE for BeginnersIDA Pro权威指南揭秘家庭路由器0day漏洞挖掘技术自己定操作系统黑客攻防技术宝典：系统实战篇 有各种系统的逆向讲解 B方向： Web应用安全权威指南 最推荐小白，宏观web安全Web前端黑客技术揭秘黑客秘籍——渗透测试实用指南黑客攻防技术宝典 web实战篇 web安全的所有核心基础点，有挑战性，最常规，最全，学好会直线上升代码审计：企业级web代码安全架构 入门—-从基础题目出发（推荐资源）： http://ctf.idf.cn !!!首推 idf实验室：题目非常基础，只1个点www.ichunqiu.com 有线下决赛题目复现http://oj.xctf.org.cn/xctf 题库网站，历年题，练习场，比较难www.wechall.net/challs !!!!!!非常入门的国外ctf题库，很多国内都是从这里刷题成长起来的http://canyouhack.it/ 国外，入门，有移动安全https://microcorruption.com/login A方向 密码，逆向酷炫游戏代http：//smashthestack.org A方向，简洁，国外，wargames，过关http://overthewire.ofg/wargames/ ！！！！推荐A方向 国内资料多，老牌wargamehttps：//exploit-exercises.com A方向 老牌wargame，国内资料多http://pawnable.kr/play.php pwn类游乐场，不到100题http://ctf.moonsoscom/pentest/index.php B方向 米安的Web漏洞靶场，基础，核心知识点http：//prompt.ml/0 B方向 国外的xss测试http://redtiger.labs.overthewire.org/ B方向 国外sql注入挑战网站，10关，过关的形式 不同的注入，循序渐近地练习 工具：https://github.com/truongkma/ctf-toolshttps://github.com/Plkachu/v0lthttps://github.com/zardus/ctf-toolshttps://github.com/TUCTF/Tools 这是原链接 ：链接2。 ​]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT创新区招新酱油记]]></title>
    <url>%2F2017%2F09%2F26%2FIT%E5%88%9B%E6%96%B0%E5%8C%BA%E6%8B%9B%E6%96%B0%E9%85%B1%E6%B2%B9%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[​ 一直觉得自己很菜，但具体程度不知道，直到…….南航IT创新区招新，本着为以后的技术面积累经验的目的，就去报名参加了。 虽然通知上说IT创新区的合作组织比如纸飞机技术部、微软技术部、科协宣企等技术部门可以不参加面试，后期考核一下合格后直接转入，但别人认可的是技术部的水平，感觉自己离那个水平有点远，所以还是老老实实去走流程。 ​ 先笔试，前面有数据结构与算法、Web大前端、网络后端、逻辑思维能力这几个板块，有多项选择题，填空题。然后后面就是这几个板块的面试题，自行准备有把握或者有思路的题，做完前面会做的就可以去排队面试了。有印象的题不多，因为大部分完全不会，稍微整理一下还有点印象的题。 逻辑思维题​ 填空题里有好几个印象挺深的题，先来看第一个吧。 火车运煤问题​ 题目是这样的： 你是山西的一个煤老板，你在矿区开采了有3000吨煤需要运送到市场上去卖，从你的矿区到市场有1000公里，你手里有一列烧煤的火车，这个火车最多只能装1000吨煤，且其能耗比较大——每一公里需要耗一吨煤。请问最后能运到集市上卖多少吨煤？ ​ 当时脑子里一片混乱，被前端的知识点和数据结构的东西弄的有点晕，心里想着反正答案不是零，但要分段运的话。。。在草稿本上画了画图，算来算去有点不清晰，懒得算了。后来去网上搜索了一下，才发现这是有名的”火车运煤问题“，(此处更新一条消息。我正写到这里，IT创新区发来了机考的通知。。。呃，一面要求这么低的吗。。。。还以为被刷定了)看了看别人的解法，再想了会，其实也不是很难，但要在短时间内做很多这样的题目，我就感觉有点变态了。 ​ 3000吨煤初步设想肯定是要运3次的，因为一次最多只能运1000吨，大概思路就是：在中间设两个暂存点1和2，第一次运到1，留下返程的煤然后回去，装满1000后到1处将煤补满至1000，到2位置，然后卸掉一些煤，留下返回到1的煤，到1后再装上回到矿区的煤，接着再把最后的1000吨煤全装上，到1时将这里剩下的煤都装上（应该是刚好凑成1000的），然后到2后再装上2处剩下的煤（同理应该恰好装满），最后运到市区。方程最后算出来的结果应该是533.3t，有兴趣的自己解下方程试试。其实这里有一个 突破点，每运1公里是要耗1吨煤的，所以一开始就能确定只需要从起点运3次，即每次都装满1000t。 这个解法直接把此问题转为了线性规划，需要一定的数学能力，不是我等数学渣渣可以轻易做到的。。。。 海盗分金​ 这个问题是经济学上有名的模型（甚至还给它建了百度百科。。。），以前没怎么思考过，还好上次离散课上老师稍微提了一下，就说了一下逆推法，不过要注意的是这个题目说的是方案必须大于半数才能通过。找到了方法其实并不难，如果最后剩下4号和5号，5号投反对票，就可以独得金币，所以3号只需要给4号一点金币让他投赞成票就行了(其实就算3号不给4号，他也只能投赞成票，不然他就得死)，然后2号就只需要给4号和5号一点点金币就可以了，同理，1号只需要给3号一点好处，然后4号或5号选一个给一点就行了，这样就能保证自己的利益最大化。重点就是后面的那个人一定会投反对票，以及，逆推 前端后端canvas和svg的区别​ svg，这玩意我听说的很少，查了下后才知道，svg年代久远，已经十几年了，可以自定义标签或属性，用来描述二维图形，canvas倒是看过一些大佬们写的博客，有些许了解。 ​ 从功能上来讲，canvas是画布，画出来的图形为标量图形，所以，canvas可以直接引入jpg或者png类的图片，在实际开发中，canvas也很受欢迎，而且现在canvas的技术也比较成熟了。而svg则是用来描绘矢量图的，所以不支持直接引入普通的图片，但svg的矢量图不会失真，所以可以用来做一些动态的小图标，由于svg的图片不会失真，很适合用来做地图，不管怎么放大都很清晰，比如百度地图。 ​ 在技术层面，canvas绘制的图片是不能被引擎抓取的，一般用javascript，而svg更多是通过标签来实现的，并且支持事件绑定。 javascript中this的用法​ 我印象中，this就是指向当前函数的直接调用者来着，别的没了。。。呃，查了一下，简单点说就是这样： 有对象就指向调用对象 没调用对象就指向全局对象 用new构造就指向新对象 通过 apply 或 call 或 bind 来改变 this 的所指。 具体解释 http/https tcp/udp socket​ 首先说下tcp和udp，两者都是超文本传输协议，属于传输层，但区别是，在IP环境下TCP比UDP传输数据的可靠性更强，所以tcp/ip协议对应的是数据可靠性更高的应用，tcp协议支持的应用层协议主要有：Telent、FTP、SMTP等，而UDP支持的应用层协议主要有：NFS(网络文件系统)、SNMP(简单网络管理协议)、DNS(主域名称系统)、TFTP(通用文件传输协议)等。 ​ socket简单点说就是网络上的两个程序通过一个双向的通信连接实现数据的交换，连接的一端就称为一个socket。而建立网络通信连接至少要一对端口号(socket)，其本质就是API，对TCP/IP的封装，而TCP/IP也要提供可供程序猿做网络开发所用的借口，即socket编程接口。 ​ http与https的区别就在于有无一层加密模块(SSL)，http传输的数据都是明文，很不安全，于是诞生了https，一开始用的版本是SSL，但现在基本上换成了TLS。有一个问题经常会被问到：在浏览器地址栏输入https开头的URL，到整个网页界面显示完毕，发生了什么？其实问的就是https的原理。上个图 ​ 1.客户端输入URL后，发起了一个https的请求，把自身支持的一系列Cipoer Suite(密钥算法套件)发给服务端 ​ 2.服务端接受到客户端所有的Cipher后与自身支持的对比，如果不支持就断开连接，支持的话就从中选出一种加密算法，以证书的形式返回给客户端，证书中会包含公钥、颁证的机构、网址、失效日期等等。 ​ 3、客户端收到服务器响应后会做的事： ​ 3.1 验证证书的合法性。即机构是否合法、是否过期，证书中包含的网站地址是否与正在访问的的地址一致等，证书验证通过后，在浏览器的地址栏会加上一把小锁(Chrome的亲测有效) ​ 3.2 生成随机密码。如果证书验证通过，或者用户接受不了授信的证书，此时浏览器会生成一串随机数，然后用证书中的公钥加密。 ​ 3.3 HASH握手信息。用最开始约定好的HASH方式，把握手消息取HASH值，然后用随机数加密“握手消息+握手消息HASH值(签名)”并一起发给服务端。这里之所以要取握手消息的HASH值，是为了把握手消息做一个签名，用于验证握手消息在传输过程中有没有被修改过。 ​ 4、 服务端拿到客户端传来的密文，用自己的私钥来解密握手消息去除随机数密码，再用随机密码解密握手消息与HASH值，并与传过来的HASH值做对比确认是否一致。然后用随机密码加密一段握手消息(握手消息+握手消息的HASH值)给客户端。 ​ 5、 客户端用随机数解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密，因为这串密钥只有客户端和服务端知道，即使在中间被拦截也无法破解。 非对称加密算法：RSA，DSA/DSS，客户端与服务端相互验证的过程是对称加密 对称加密算法：AES，RC4，3DES 验证通过后，以随机数作为密钥，就是对称加密 HASH算法： MD5，SHA1，SHA256 确认握手消息没有被篡改时 后来​ 今天按照通知去机考，然后被PM发现是技术部的(但实际上我比技术部的平均水平差太多，所以不好意思说自己是技术部的…)最后提前走了，因为想做的板块自身基础的确不好，被告知等技术成熟了，随时接受内推。。。。(被小小地照顾了一下自尊心)]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python爬虫系统学习笔记]]></title>
    <url>%2F2017%2F09%2F16%2Fpython%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在中国大学MOOC那发现了python的爬虫专题系列，可以说是非常非常开心了 Requests库入门​ 在前两次的爬虫体验里面已经用到了这个牛X的库，现在开始对它进行系统点的学习（emmm，个人不是很喜欢看文档，喜欢视频），嵩天老师讲的超级好，之前python入门也看过一点他的视频，感觉超级赞。废话貌似说的有点多。。。。 Requests库安装及七个基本方法​ python提供了安装包管理工具pip，有点类似于Sublime text的Package Control，pip安装的时候注意版本的兼容，建议选择源码编译安装，解压的个人觉得容易出问题，具体请自行百度。有了pip以后就简单了，打开cmd直接输入键入命令pip install requests(此处针对的是windows环境，mac什么的应该更加方便就不说了)。然后检查一下是否已经成功安装。 1234import requestsr = requests.get("http://www.baidu.com")print(r.status_code)print(r.text) 这里我用的是Sublime Text，其实用python自带的idle也挺方便的，但我个人不习惯呃。 如果打印出状态码为200而且输出的百度的文本内容，说明已经requests库已经到位，否则请回去检查一下安装是否出了问题。 其中requests.request()是基础，构造请求。然后其他6个分别是： get：获取HTML网页的主要方法 head: 获取HTML头部信息。 这是最为重要的两个，还有post, put, patch, delete。这6个方法均对应着HTTP协议的操作(可以说requests库就是为HTTP而生的)。 requests.request()​ 标准形式是：requests.request(method, url, **kwargs)，method对应上面的post, put等方法，而**keargs是控制参数。比如这样写： 123kv = &#123;'key1': 'value1','key2': 'value2'&#125;r = requests.request('GET', 'url', params = kv)print(r.url) 会打印出url?key1=value1&amp;key2=value2。最重要的是伪造header，这样写： 12hd = &#123;'user-agent':'Mozilla/5.0'&#125;r = requests.request('GET', 'url', heaers = hd) 其他还有json，data, cookies, auth, timeout等。 requests.get()​ 最常见的写法：r = requests.get(url),r表示的是服务器返回的一个Response对象，url即目标网页，完整的写法是这样的：r = requests.get(url, params = None, **kwargs)，后面两个为选填参数，其中params表示字典或者字节流格式，**keargs表示12个控制的参数。 ​ 有意思的是，response(下面简称r)对象不仅包括服务器返回的信息，也包括requests请求的信息。r的属性主要有这么5个： r.status_code: 200表示成功，404表示失败，更多状态码自己查查看。 r.text: HTTP响应内容的字符串形式。 r.encoding: 编码方式 r.apparent_encoding: 备选编码方式 r.content: HTTP响应内容的二进制形式 其中encoding是根据header里面的charset字段来判断的，如果没有，会默认为ISO-8859-1，此编码下中文会乱码，备选编码方式一般是utf-8。 Requests库的异常​ 嵩老师说了一句：网络连接有风险，异常处理很重要。错误有很多种，DNS查询失败，HTTP 错误，URL错误，超过最大重定向次数导致重定向异常，超时错误等等。只要状态不是200就可以认为是HTTP错误了。 通用代码框架1234567891011121314import requestsdef getHTMLText(url): try: r = requests.get(url) r.raise_for_status()#不是200就会引发异常 r.encoding = r.apparent_encoding return r.text except: return "异常"if __name__ == "__main__": url = "" print(getHTMLText(url)) ​ 不得不说，这代码比较严谨，不像我前面两次的那样，哈哈哈，从开始就养成好习惯。 盗亦有道——robots协议爬虫尺度分类与可能带来的问题​ 网络爬虫是有尺度的，大概可以分为这么三种： 规模小，数据量小，速度不敏感，用requests库即能完成，用来玩转网页的。 中等规模，爬取速度敏感，用scrapy库，爬取系列网站。 大规模，用搜索引擎，定制开发。爬取全网 网络爬虫会带来的三个问题： 性能骚扰：水平太烂的话会给服务器资源造成巨大的压力 法律风险：如果爬来的数据用于商业用途可能要面对法律风险 隐私泄露；爬到正常情况下无权限获取的数据可能会造成个人隐私泄露 网络爬虫的限制来源审查：判断User-Agent，只允许友好爬虫和浏览器访问 发布公告：robots协议，告知爬虫，要求遵守。 robots协议全名叫：Robots Exclusion Standard，网络爬虫排除标准。以协议约定的形式告知爬虫爬取权限，一般在网站的根目录下。来看一下京东的robots协议： 12345678910111213&gt;User-agent: * &gt;Disallow: /?* &gt;Disallow: /pop/*.html &gt;Disallow: /pinpai/*.html?* &gt;User-agent: EtaoSpider &gt;Disallow: / &gt;User-agent: HuihuiSpider &gt;Disallow: / &gt;User-agent: GwdangSpider &gt;Disallow: / &gt;User-agent: WochachaSpider &gt;Disallow: /&gt; *代表所有，/代表根目录 原则上是应该要遵守robots协议的，但如果访问量很小，类似人的上网行为，可以不考虑遵守robots协议。但是！！！如果是商业用途或者爬取全网，必须遵守robots协议，不然出了问题是真的要背法律责任的。 举个栗子保存一张图片： 12345678910111213141516171819import requestsimport osurl = "https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1832529435,1519198910&amp;fm=11&amp;gp=0.jpg"root = "D://pics//"path = root + url.split('/')[-1]try: if not os.path.exists(root): os.mkdir(root) if not os.path.exists(path): r = requests.get(url) with open(path, 'wb') as f: f.write(r.content) f.close() print("文件保存成功") else: print("文件已存在")except: print("爬取失败") root是目录，先检测目录是否存在，如果没有，建一个，然后路径同理，接着打开一个个文件，然后写入r.content(因为content属性是二进制形式的) 嗯？保存一张图片也许没有右键另存为来的快，但成百上千张图片可就无能为力了，特别是还要对图片进行筛选的情况下。(我存的图片男生可以参考，女生可以换一张，哈哈哈哈哈哈哈) Beautiful Soup库入门​ 懒得再新建文章了，直接继续第二章的内容。这次是学习Beautiful Soup库，(形象地称之为煲汤。。。。是的，没错，老师也用了这个词。。。。)自行安装 测试是否安装成功： 1234567import requestsfrom bs4 import BeautifulSoupr = requests.get("http://python123.io/ws/demo.html")demo = r.textsoup = BeautifulSoup(demo, 'html.parser')print(soup.prettify()) 如果打印出来的内容和HTML文档排版一样就OK。 ##Beautiful Soup库的基本元素 ​ 首先，Beautiful Soup库是解析、遍历、维护“标签树”的功能库，这里会对应HTML的框架(Requests库对应HTTP操作)。 ​ Beautiful Soup库的引用一般是BeautifulSoup类，有意思的是，真正用的时候只要写bs4就好，from bs4 import BeautifulSoup,就是这样奇葩。而上面代码中soup = BeautifulSoup(demo, &#39;html.parser&#39;),html.parser则指的是html解析器。用来解析demo的HTML结构。 ​ Beautiful Soup库有如下5个基本元素： Tag: 最基本的信息单元 Name: 标签的名字，格式：.name Attributes: 标签的属性。格式：.attrs NavigableString: 标签内非属性字符串。格式：.string Comment: 标签内部的注释信息，一种特殊的comment类型 Tag 标签​ 任何HTML语法中的标签都可以通过soup.tag访问，比如，soup.title，soup.a等等当存在多个相同的tag时，返回第一个 ​ 每个标签都有自己的名字，可以这样来访问：soup.a.name，还可以查看其上一级标签名字soup.a.parent.name，父亲的父亲同理，儿子的话用children就行. ​ 标签属性是字典形式，可以这样来访问：tag = soup.a,tag.attrs，打印出一个字典后，还可以查看具体的某一个属性，比如tag.attrs[&#39;class&#39;]。 ​ NavigableString 和 Comment不再细说，原理和这个一样。 基于bs4库的HTML内容遍历方法​ 贴一下HTML的基本结构 123456789101112131415161718192021222324&lt;html&gt; &lt;head&gt; &lt;title&gt; This is a python demo page &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class="title"&gt; &lt;b&gt; The demo python introduces several python courses. &lt;/b&gt; &lt;/p&gt; &lt;p class="course"&gt; Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses: &lt;a class="py1" href="http://www.icourse163.org/course/BIT-268001" id="link1"&gt; Basic Python &lt;/a&gt; and &lt;a class="py2" href="http://www.icourse163.org/course/BIT-1001870001" id="link2"&gt; Advanced Python &lt;/a&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 标签树的三个属性可以做到下行遍历： .contents：将tag的所有子节点都存入列表 .children：子节点的迭代类型，用循环遍历子节点 .descendants：子孙节点的迭代烈性，包括所有子孙节点，用循环遍历 遍历子节点和子孙节点： 12345for child in soup.body.children: print(child) for child in soup.body.descendants: print(child) ​ 上行遍历： .parent：节点的父节点 .parents：节点父辈的迭代类型，循环遍历 上行遍历示例： 12345for parent in soup.a.parents: if parent is None: print(parent) else: print(parent.name) 考虑到会遍历到根节点(即soup本身)，所以做了一个判断。 平行遍历： .next_sibling：按照顺序遍历下一个平行节点 .previous_sibling：按照顺序遍历上一个平行节点 .next_siblings：迭代，循环遍历后面所有平行节点 .previous_siblings：迭代，循环遍历前面所有平行节点 注意一个问题：在同一个父节点下才算是平行节点。 比如，这是遍历后续节点： 12for sibling in soup.a.next_sibling: print(sibling) 友好输出：Prettify()​ 很简单，直接print(soup.prettify())，而且支持utf-8编码. 信息标记与提取信息标记上表就好： XML：最早的通用信息标记语言，可扩展性强但是繁琐 JSON：信息有类型，键值对显示，超级适合js的处理，比XML简洁 YAML：信息无类型，文本信息比例高，可读性很好。 作用： XML：Internet上的信息交互与传递 JSON：移动应用端与节点的信息通信 YAML：系统的配置文件 信息提取​ 最好的方法当然是形式解析与关键字内容搜索融合。 ​ 比如，要提取所有的URL链接，只需要这样： 12for link in soup.find_all('a'): print(link.get('href')) ​ find_all(name, attrs, recursive, string, **kwargs)，参数分别是标签名字，标签属性，是否对子孙全部检索(默认为True)，检索区域，及控制参数，既然是匹配，肯定是正则大法好咯。TIPS：(…) 等价于 .find_all()，soup(…) 等价于 soup.find_all() 再举个栗子​ 爬取中国大学排名，很简单的栗子，直接上代码好了： 1234567891011121314151617181920212223242526272829303132333435import requestsfrom bs4 import BeautifulSoupimport bs4def getHTMLText(url): try: r = requests.get(url, timeout = 30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return ""def fillUnivList(ulist, html): soup = BeautifulSoup(html, "html.parser") for tr in soup.find('tbody').children: if isinstance(tr, bs4.element.Tag): tds = tr('td') ulist.append([tds[0].string, tds[1].string, tds[3].string])def printUnivList(ulist, num): tplt = "&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;" print(tplt.format("排名", "学校名称", "总分",chr(12288))) for i in range(num): u = ulist[i] print(tplt.format(u[0], u[1], u[2], chr(12288)))def main(): unifo = [] url = 'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html' html = getHTMLText(url) fillUnivList(unifo, html) printUnivList(unifo, 30)#30所大学main() ​ tplt和chr(12288)是为了使输出稍微美观一点而做的一点小优化。中间要判断是否是bs4.element.tag类型，所以引用了bs4库。(吐槽一下python的format是真的强，还有，南航居然排到了29诶。。。) Re(正则表达式)入门​ 前面已经有过接触，正则表达式是一种针对字符串表达“简洁”和“特征”思想的工具，用来判断某字符串的的特征归属，可以用来替换或者匹配字符串。我决定直接贴图… ​ 调用方式：import re，re库一般匹配raw string(原生字符串类型r’text’)，即不包括对转义符再次转义的字符串。re库也可以直接用string类型来表示，但会更繁琐，如果正则包含转义符时，用raw string类型更好。 ​ 主要函数： ​ 大部分函数都是三个参数：pattern, string, flags。pattern即为构造的正则表达式，string为待匹配字符串，flags为控制参数，其中split函数还有一个maxsplit(最大切割次数)，放在string和flags中间。sub函数更特殊，re.sub(pattern, repl, string, count = 0, flags = 0), 另外常用的正则可以经过编译使用：pat = re.compile(pattern, flags), rst = pat.search(&#39;string&#39;),可以提升运行速度。返回的是match对象，它的属性如下： ​ ​ 属性的方法： ​ 另外，在默认返回一个对象而又能同时匹配多个字符串时，默认返回最长的那个(贪婪匹配)，如果有 需要，作最短匹配，加一个?就可以了。 ​ 定向爬取淘宝商品(不要不加限制地爬，robots协议不允许….) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsimport redef getHTMLText(url): try: r = requests.get(url, timeout = 30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return ""def parsePage(ilt, html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"', html) tlt = re.findall(r'\"raw_title\"\:\".*?\"', html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price, title]) except: print("")def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号", "价格", "商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1]))def main(): goods = '书包' depth = 3 start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] for i in range(depth): try: url = start_url + '&amp;s=' + str(44 * i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList)main() ​ 上一段比较优美的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import requestsfrom bs4 import BeautifulSoupimport tracebackimport re def getHTMLText(url, code="utf-8"): try: r = requests.get(url) r.raise_for_status() r.encoding = code return r.text except: return "" def getStockList(lst, stockURL): html = getHTMLText(stockURL, "GB2312") soup = BeautifulSoup(html, 'html.parser') a = soup.find_all('a') for i in a: try: href = i.attrs['href'] lst.append(re.findall(r"[s][hz]\d&#123;6&#125;", href)[0]) except: continue def getStockInfo(lst, stockURL, fpath): count = 0 for stock in lst: url = stockURL + stock + ".html" html = getHTMLText(url) try: if html=="": continue infoDict = &#123;&#125; soup = BeautifulSoup(html, 'html.parser') stockInfo = soup.find('div',attrs=&#123;'class':'stock-bets'&#125;) name = stockInfo.find_all(attrs=&#123;'class':'bets-name'&#125;)[0] infoDict.update(&#123;'股票名称': name.text.split()[0]&#125;) keyList = stockInfo.find_all('dt') valueList = stockInfo.find_all('dd') for i in range(len(keyList)): key = keyList[i].text val = valueList[i].text infoDict[key] = val with open(fpath, 'a', encoding='utf-8') as f: f.write( str(infoDict) + '\n' ) count = count + 1 print("\r当前进度: &#123;:.2f&#125;%".format(count*100/len(lst)),end="") except: count = count + 1 print("\r当前进度: &#123;:.2f&#125;%".format(count*100/len(lst)),end="") continue def main(): stock_list_url = 'http://quote.eastmoney.com/stocklist.html' stock_info_url = 'https://gupiao.baidu.com/stock/' output_file = 'D:/BaiduStockInfo.txt' slist=[] getStockList(slist, stock_list_url) getStockInfo(slist, stock_info_url, output_file) main() ​ 动态优化好评。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取网易云热评]]></title>
    <url>%2F2017%2F09%2F14%2F%E7%88%AC%E5%8F%96%E7%BD%91%E6%98%93%E4%BA%91%E7%83%AD%E8%AF%84%2F</url>
    <content type="text"><![CDATA[爬取网易云热评，用python上手真心简单，怪不得有人总说“人生苦短，我用python“。 ​ 爬网页数据的话一般是解析html的结构，这种适合抓取html里面多种元素的情况，而我只是想看个热评而已，可以另辟蹊径：直接搞到评论的API，然后获取json返回，最后解析就行了。((￣▽￣)~所以说很简单咦) 找到API​ 打开网易云网页版，输入自己想抓取热评的歌曲，然后用开发者工具，输入comments就能找到评论API的url了，点response就能看到json格式的评论了。 那个数字代表的应该就是这首歌的id了，后面有一个叫csrf_tocken的参数，显示为空，那就不管它了。请求方式依然是post，然后表单那里还有两个加密过的参数，分别是params和encSecKey，一开始以为是每首歌都会对应这么一个参数，后来发现并不是，刷新了页面后却发现这个参数变了，可能是对应评论页码加密的？ 获取json​ 再一次慨叹一下python库的强大，不信？那你看代码长度咯。 1234567import requestsimport jsonurl = 'http://music.163.com/weapi/v1/resource/comments/R_SO_4_63650?csrf_token='param = &#123;'params':'', 'encSecKey':''&#125;r = requests.post(url, param)data = r.text #拿到json 这样就拿到评论的json格式了(PS：那两个参数实在是太长了，贴出来看的我不舒服，写的时候自行粘贴上去就好)。 解析json拿到了json后自然要解析一波，python的json库可以很轻易地帮我们解决这个问题。首先从开发者工具那直接复制json，拿到这里在线json校验格式化工具,看一下json的具体形式(直接那么长一串简直反人类没法看)。 舒服多了23333。主要信息有nickname，content，likedCount把这三个拎出来就差不多了。(id, 内容, 点赞量)json库不会用的话去查一下就好，上手很容易的，然后直接解析后打印就好了。(就一页热评，懒得写入文件了。)稍微完整的代码： 1234567891011121314151617import requestsimport jsonurl = 'http://music.163.com/weapi/v1/resource/comments/R_SO_4_63650?csrf_token='param = &#123;'params':'', 'encSecKey':''&#125;r = requests.post(url, param)data = r.text #拿到jsonjsOb = json.loads(data)hotComments = jsOb['hotComments']for i in range(len(hotComments)): user_nickname = hotComments[i]['user']['nickname'] likedCount = hotComments[i]['likedCount'] content = hotComments[i]['content'] print('评论',str(i+1),' 用户名:',user_nickname,'喜 欢：',str(likedCount)) print('-----------------------------') print(content) 这样就OK咯。贴一下我抓的《独家记忆》第一页热评。 emmmmm，后期再更新一下抓全部评论和整个歌单的热评好了。不过那样数据会比较大，时间相应也挺长的，不太敢多开线程加快速度，怕触发反爬虫机制ip被封了就GG了。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫初体验]]></title>
    <url>%2F2017%2F09%2F11%2Fpython%E7%88%AC%E8%99%AB%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[python基础部分看了一遍后，感觉需要找点乐子，于是想到去学一点爬虫批量抓图片，嘿嘿嘿 先介绍一下python的两大利器(库)：requests和re(emmmm，可别以为后面那个是前者的缩写，其实半毛钱关系都没有)。requests库有多厉害呢？简单地说就是python 的http库，可以帮开发人员省很多代码，具体有多厉害呢？戳这里 。而re库则是regexp的缩写，python提供了相当强大的正则表达式引擎，很大程度上简化了python代码，稍微详细一点的介绍在这里 。好了以下是正文 获取网页12345import requestsheader = &#123;'User-Agent':'xxx'&#125;url='https://www.xxxxx'r = requests.get(url,headers = header)txt = r.text 先引入 requests模块，然后header是用来伪造浏览器UA的，用Chrom的话直接去开发者工具那找一下自己的Request Headers就好，url则是要抓取的网页地址，传入这两个参数给.get函数后，就能拿到初步结果 解析图片嗯，别忘了自己是来抠图的，上面那个函数写完后，一个print(text)出来的却是一大坨HTML，这当然不是我要的，去网上找了一下发现Python还有个叫Beautiful Soup的东西(→_→我第一反应是煲汤)，这个库是用来解析HTML结构的，看了几眼觉得有点复杂，这时候想起了正则大法，图片链接不都是有明显特征的嘛，于是考虑正则。匹配以https://开头以.jpg类结尾的，并作最短匹配，然后全部累塞进数组。 12345678910jpg = re.compile(r'https://[^\s]*?\.jpg')jpeg = re.compile(r'https://[^\s]*?\.jpeg')gif = re.compile(r'https://[^\s]*?\.gif')png = re.compile(r'https://[^\s]*?\.png')imgs=[]imgs+=jpg.findall(txt)imgs+=jpeg.findall(txt)imgs+=gif.findall(txt)imgs+=png.findall(txt) 下载图片request用来存储get的url，判断状态码是否正常，如果正常就写入文件。 12345678910def download(url): request = requests.get(url) if req.status_code == requests.codes.ok: name = url.split('/')[-1] f = open("./"+name,'wb') f.write(req.content) f.close() return True else: return False 写好下载函数后就可以写循环来挨个下载了 12345678errors = []for img_url in imgs: if download(img_url): print("download :"+img_url) else: errors.append(img_url)print("error urls:")print(errors) 还可以设置一个urls数组，同时下载多个网页的图，download函数也可以加个文件夹名，这样就可以了。 最后我干了什么呢？上个图，自己体会 以上代码需要优化，直接用的话还有些不完善，需要根据实际的网站来调整。 多说一句​ 想起一位厉害小姐姐的训示：少年的你的梦想应该是拯救世界，怎么能每天爬一些日韩女人啊爆照贴妹子什么的。 ​ (逃：]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10改掉C盘下的中文用户名]]></title>
    <url>%2F2017%2F09%2F11%2Fwin10%E6%94%B9%E6%8E%89C%E7%9B%98%E4%B8%8B%E7%9A%84%E4%B8%AD%E6%96%87%E7%94%A8%E6%88%B7%E5%90%8D%2F</url>
    <content type="text"><![CDATA[昨天早上一起来，正愉快地折腾着，突然发现有些报错无论如何都解决不了，有的虽然影响不大但看起来很烦，搜索一波后发现其实是我c盘下中文路径搞的鬼， 嗯，话不多说就是干。 搜了一会儿后发现这个世界上的误解还真多，居然有这么多人以为是改本地的管理员账号，毫不客气地给了一个”踩”。终于在知乎下面找到了一点眉目。（还是比百度强） 懒得传图，直接复制一下第一个答案： 假设原用户名为 小明，需改为 xiaoming。 1.先新建一个管理员账户，然后注销当前用户，以新建的管理员账户登录； 2.重命名 c:\Users\小明 为 c:\Users\xiaoming； 3.打开注册表编辑器（win+R 输入 regedit），定位到 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList 的某一子项（S-1-5-21… 开头的），将“数据名称”为 ProfileImagePath 的“数值数据”内容 C:\Users\小明 改为 C:\Users\xiaoming ； 4.改后以原账户登录并删除新建账户。 咦，下面有80+评论，去瞄了一眼，虽然成功的人也有，但失败的也不少，我还是没有直接按照这个方法改，但大概思路已经清楚了，即临时存一下当前中文名下的东西，拿到改名权限后改掉中文名，再换回来。 在下面的回答中找到了一位小姐姐的博客园链接，给链接的人称此方法很成功，嗯，大概说一下这个方法的步骤： 改注册表用win+r打开命令窗口，输入regedit，把系统注册表调出来，然后去这个地方 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList 依次点开那些以S-1-5-开头的项，找到ProfileImagePath，把C：\Users\中文名 改成C：\Users\English name 记得把所有的Path都改掉，确认后关掉注册表。 改文件名打开cmd后发现依旧是中文名，这个当然，因为只是改完了注册表，文件权限还没转移，于是重启电脑。 启动后发现壁纸什么的都不一样了，这是因为当前Users 已经变成了TEMP，即临时系统账户。这时候系统会提醒你无法连接到你的账户，嗯，因为你的注册表已经改了，点击隐藏， 别点注销，然后按ctrl + e 打开我的电脑，找到C：\Users\中文名，修改文件名，点击给予权限。然后重启电脑就大功告成啦 可能有的问题更改之前就已经安装的软件可能依旧会显示中文路径，如果不报错的话就没关系，（强迫症选手请重装软件）。其他的问题好像没了，那个小姐姐还给了测试。 这是小姐姐的文章链接]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大和子序列]]></title>
    <url>%2F2017%2F09%2F10%2F%E6%9C%80%E5%A4%A7%E5%92%8C%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[今天来看一个简单的问题，求最大的和子序列/求最大和子数组 题目是这样的：已知序列：-2, 11, -4, 13, -5, 2, -5, -3, 12, -9，求此序列的最大子序列和 ​ 其实题目很简单，但智障的我一开始弄错了，直接把所有负数提出去然后把剩下的相加，这也太简单了点吧。。。。后来想想，貌似不太对，于是，重来。一共用了三种方法。(名字都是我瞎写的) 方法一：暴力法​ 没错，就是直接把这个数组的所有子序列的和都算一遍，跟初始最大值比较，代码如下： 12345678910111213141516171819int main()&#123; int a[] = &#123;-2,11,-4,13,-5,2,-5,-3,12,-9&#125;; int maxSum = a[0],n = sizeof(a)/sizeof(a[0]); for(int i = 0;i &lt; n;i++)//子数组长度 &#123; for(int j = 0;j &lt; n;j++)//子数组开始的位置，数组下标 &#123; int sum = 0;//记录当前子数组和 for(int k = j;k &lt; n&amp;&amp;k &lt; j + i;k++)//求和 &#123; sum += a[k]; &#125; if(sum &gt; maxSum) maxSum = sum; &#125; &#125; cout &lt;&lt; "子序列的最大和是："&lt;&lt; maxSum &lt;&lt; endl; return 0;&#125; 对，就是这么暴力，效率很低，时间复杂度：O(n³) 方法二：递进求和​ 不断求出以a[i]开头的子序列的和，并在求的过程中记录好最大的子序列的和，函数代码如下： 1234567891011121314int maxSubArraySum(int *arr,int n)&#123; int i,j,maxSum = 0,sum; for(i = 0;i &lt; n;i++)//子数组开始位置 &#123; sum = 0; for(j = i;j &lt; n;j++) &#123; sum += arr[j]; if(sum &gt; maxSum) maxSum = sum;//求和并比较 &#125; &#125; return maxSum; &#125; 相对方法一来说，方法二减少了一次遍历，时间复杂度为：O(n²) 方法三：判断求和​ 仔细想一下，一个数，加上一个负数会变小，加上零不变，加上正数才会变大，对，就是这么简单的道理，就可以用来优化这个题的算法了。从a[0]开始累加，如果大于初始值，就替换，如果和小于零，直接舍弃，然后是a[1]，函数代码如下： 1234567891011int maxSubArraySum_2(int *arr,int n)&#123; int i,maxSum = arr[0],sum = 0; for(i = 0;i &lt; n;i++)//子数组开始位置 &#123; sum += arr[i]; if(sum &gt; maxSum) maxSum = sum;//记录最大累加和 if(sum &lt; 0) sum = 0;//累加和小于零的不要 &#125; return maxSum;&#125; 这样的话，只要对数组遍历一次就能解决了，时间复杂度降为O(n)，最简单道理往往有意想不到的效果，哈哈哈哈。 另外，加个tips: n = sizeof(a)/sizeof(a[0])，Strlen()函数不适用于整数数组]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于排序]]></title>
    <url>%2F2017%2F09%2F10%2F%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[我目前已经学会的排序以及理解（会不断更新） 先贴个交换函数： 123456void Swap(int A[],int i,int j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp;&#125; 冒泡排序这是进大学后c语言课本上介绍的第一个排序，也是最简单，最容易理解的一个排序，顾名思义，就像冒泡一样，一次一次把最值往最后面放，完成排序。函数代码如下： 12345678910111213void BubbleSort(int A[],int n)&#123; for(int j = 0;j &lt; n - 1;j++) &#123; for(int i = 0;i &lt; n - 1 - j;i++) &#123; if(A[i] &gt; A[i + 1]) //从小到大排序 &#123; Swap(A,i,i + 1); &#125; &#125; &#125;&#125; 冒泡排序是稳定的，因为即使有相同的数也不会打乱原来是次序，平均时间复杂度：O(n²)。 选择排序​ 相比于相邻交换的冒牌排序，选择排序是通过从未排序的数据元素中选出最值放在该序列的起始位置，直到所有元素排完，同样需要循环两次，无法优化时间。代码如下： 123456789101112131415161718void SelectionSort(int A[],int n)&#123; for(int i = 0;i &lt; n - 1;i++) &#123; int min = i; for(int j = i + 1;j &lt; n;j++) &#123; if(A[j] &lt; A[min]) &#123; min = j; &#125; &#125; if(min != i) &#123; Swap(A,min,i); &#125; &#125;&#125; 选择排序是不稳定的，因为如果有相同的数的话是可以改变原来次序的，平均时间复杂度：O(n²)。 插入排序​ 看到这个方法，我的第一反应便是抓扑克牌，原理和抓牌原理一样，即，左手上的牌是已经排好序了的，将左手上的牌依次和抓到的牌比较，如果大于抓到的牌便把这张牌左移，然后插入抓到的牌。函数代码如下: 1234567891011121314void InsertionSort(int A[],int n)&#123; for(int i = 1;i &lt; n;i++) &#123; int get = A[i]; int j = i - 1; while(j &gt;= 0 &amp;&amp; A[j] &gt; get) &#123; A[j + 1] = A[j]; j--; &#125; A[j + 1] = get; &#125;&#125; 相同的牌不影响顺序，插入排序是稳定的，平均时间复杂度：O(n²)。 快速排序​ 快速排序基于一种二分的思想，即以一个数为基准数，不断将数组二分，最终当所有基准数都归位后，排序也就完成了。快速排序之所以较快，是因为每次交换都是跳跃式的。函数代码如下：(千万注意下标是从0开始的 ) 12345678910111213141516171819202122void quicksort(int arr[],int left,int right)&#123; if(left &gt; right) return; int i,j,temp; temp = arr[left];//temp为基准数 i = left; j = right; while(i != j) &#123; //基准数在左边，所以要从右边开始找 while(arr[j] &gt;= temp &amp;&amp; i &lt; j)j--; //再从左往右找 while(arr[i] &lt;= temp &amp;&amp; i &lt; j)i++; //如果没有相遇。就交换 if(i &lt; j) Swap(arr,i,j); &#125; arr[left] = arr[i]; arr[i] = temp; quicksort(arr,left,i - 1);//继续处理左边 quicksort(arr,i + 1,right);//继续处理右边 &#125; 归并排序归并排序的原理是分治法，简单点说就是把一个序列拆成多个子序列，将子序列排好序后，再将其合并为一个序列。归并排序的效率也比较可观，达到了o(NlogN)。 1234567891011121314void mergeArray(int a[], int first, int mid, int last, int temp[])&#123; int i = first, j = mid + 1; int m = mid, n = last, k = 0; while(i &lt;= m &amp;&amp; j &lt;= n) &#123; if(a[i] &lt;= a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; &#125; while(i &lt;= m) temp[k++] = a[i++]; while(j &lt;= n) temp[k++] = a[j++]; for(i = 0;i &lt; k;i++) a[first + i] = temp[i];&#125; 12345678910void mergeSort(int a[], int first, int last, int temp[])&#123; if(first &lt; last) &#123; int mid = (first + last) / 2; mergeSort(a, first, mid, temp);//处理左边 mergeSort(a, mid + 1,last, temp);//处理右边 mergeArray(a, first, mid, last, temp);//合并 &#125;&#125; 堆排序1234567891011121314151617181920212223242526void max_heapify(int array[], int start, int end)&#123; int dad = start; int son = dad * 2 + 1; while(son &lt;= end)&#123;//子节点在范围内 if(son + 1 &lt;= end &amp;&amp; array[son] &lt; array[son+1])&#123; son++; &#125; if(array[dad] &gt; array[son])&#123; return;//父亲节点大于子节点说明已经调整完毕 &#125; else&#123; swap(array[dad],array[son]); dad = son; son = dad * 2 + 1; &#125; &#125;&#125;void heapSort(int array[], int len)&#123; for(int i = len/2 - 1;i &gt;= 0;i--)&#123; max_heapify(array, i, len-1); &#125; for(int i = len-1;i &gt; 0;i--)&#123; swap(array[0], array[i]); max_heapify(array, 0, i-1); &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将Sublime配置成python环境]]></title>
    <url>%2F2017%2F07%2F19%2F%E5%B0%86Sublime%E9%85%8D%E7%BD%AE%E6%88%90pythona%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[刚开始学python的时候，用的是python自带的IDLE.bat，总感觉太简陋，字体很小，也没有自动补全的东西，之前有段时间在写网页玩，一直用着Sublime text 3——这款轻量而且扩展性很强而且颜值高的编辑器，想着在St3上写python岂不是美滋滋了，于是搜索了一波，最后发现了St3直接提供了一个强大的插件——Anaconda，可以将St3打造成一个python IDE。 下载好python和Sublime text 3打开安装包管理工具（这个还不会的小白请自行百度，不太好截图），输入Install Package，然后输入Anaconda，回车安装保存文件名为.py后缀后就会发现写python会有高亮和自动补全了。可能遇到的问题 用ST3一打开python文件就有这个问题，发现后面写着try to set the ‘swallow_startup_errors’ to ‘true’ 然后发现这个json的设置居然是在SublimeREPL里面而不是Anaconda。。。 好吧不管了 先试试再说 进入Preferences–package settings–&gt;SublimeRPEL–&gt;settings user 键入： “swallow_startup_errors”: true, 保存后重启。然鹅并没有什么卵用…能解决这个问题的大佬可以来教一下 还有可能遇到这种情况： 大白框和小白点，猜想可能是因为python的缩进？ （你自己喜欢的话就没关系，不用改了） 我个人看着很不舒服，搜索后发现这个是默认开启的功能，点开Preferences-Pacakage Settings-Anaconda-Settings user 加上如下一句： 即可解决这个问题. 然后就可以愉快地用St3写Python了。（ctrl + B 即可运行） 嗯，故事就这么结束了么？当然没有 然后就遇到了第一个坑：Input无效 Sublime似乎无法完成input这种交互式命令 解决方法请参考此链接]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Sublime</tag>
      </tags>
  </entry>
</search>
