<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bomblab-再相遇]]></title>
    <url>%2F2017%2F12%2F02%2Fbomblab-%E5%86%8D%E7%9B%B8%E9%81%87%2F</url>
    <content type="text"><![CDATA[​ 废话不多说，开始。 phase_11234567891011(gdb) disassemble phase_1Dump of assembler code for function phase_1: 0x0000000000400f2d &lt;+0&gt;: sub $0x8,%rsp 0x0000000000400f31 &lt;+4&gt;: mov $0x4026f0,%esi 0x0000000000400f36 &lt;+9&gt;: callq 0x401472 &lt;strings_not_equal&gt; 0x0000000000400f3b &lt;+14&gt;: test %eax,%eax 0x0000000000400f3d &lt;+16&gt;: je 0x400f44 &lt;phase_1+23&gt; 0x0000000000400f3f &lt;+18&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000400f44 &lt;+23&gt;: add $0x8,%rsp 0x0000000000400f48 &lt;+27&gt;: retqEnd of assembler dump. 直接看一下0x4026f0字符串就可以： (gdb) x/s 0x4026f00x4026f0: &quot;I am just a renegade hockey mom.&quot; phase_212345678910111213141516171819202122232425262728293031323334(gdb) disassemble phase_2Dump of assembler code for function phase_2: 0x0000000000400f49 &lt;+0&gt;: push %rbp 0x0000000000400f4a &lt;+1&gt;: push %rbx 0x0000000000400f4b &lt;+2&gt;: sub $0x28,%rsp 0x0000000000400f4f &lt;+6&gt;: mov %fs:0x28,%rax 0x0000000000400f58 &lt;+15&gt;: mov %rax,0x18(%rsp) 0x0000000000400f5d &lt;+20&gt;: xor %eax,%eax 0x0000000000400f5f &lt;+22&gt;: mov %rsp,%rsi 0x0000000000400f62 &lt;+25&gt;: callq 0x401777 &lt;read_six_numbers&gt; 0x0000000000400f67 &lt;+30&gt;: cmpl $0x0,(%rsp) 0x0000000000400f6b &lt;+34&gt;: jns 0x400f72 &lt;phase_2+41&gt; 0x0000000000400f6d &lt;+36&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000400f72 &lt;+41&gt;: mov %rsp,%rbp 0x0000000000400f75 &lt;+44&gt;: mov $0x1,%ebx 0x0000000000400f7a &lt;+49&gt;: mov %ebx,%eax 0x0000000000400f7c &lt;+51&gt;: add 0x0(%rbp),%eax 0x0000000000400f7f &lt;+54&gt;: cmp %eax,0x4(%rbp) 0x0000000000400f82 &lt;+57&gt;: je 0x400f89 &lt;phase_2+64&gt; 0x0000000000400f84 &lt;+59&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000400f89 &lt;+64&gt;: add $0x1,%ebx 0x0000000000400f8c &lt;+67&gt;: add $0x4,%rbp 0x0000000000400f90 &lt;+71&gt;: cmp $0x6,%ebx 0x0000000000400f93 &lt;+74&gt;: jne 0x400f7a &lt;phase_2+49&gt;---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x0000000000400f95 &lt;+76&gt;: mov 0x18(%rsp),%rax 0x0000000000400f9a &lt;+81&gt;: xor %fs:0x28,%rax 0x0000000000400fa3 &lt;+90&gt;: je 0x400faa &lt;phase_2+97&gt; 0x0000000000400fa5 &lt;+92&gt;: callq 0x400b90 &lt;__stack_chk_fail@plt&gt; 0x0000000000400faa &lt;+97&gt;: add $0x28,%rsp 0x0000000000400fae &lt;+101&gt;: pop %rbx 0x0000000000400faf &lt;+102&gt;: pop %rbp 0x0000000000400fb0 &lt;+103&gt;: retqEnd of assembler dump. 输入是6个数，从0x400f93 &lt;+74&gt;: jne 0x400f7a &lt;phase_2+49&gt; 知道主逻辑是个循环，第一个数是必须是0，第二个数必须是1，开始以为是等差数列，然后发现中间还有个+1的过程，所以这个数列的公差是等差数列，那么正确答案是：0 1 3 6 10 15. phase_312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182(gdb) disassemble phase_3Dump of assembler code for function phase_3: 0x0000000000400fb1 &lt;+0&gt;: sub $0x28,%rsp 0x0000000000400fb5 &lt;+4&gt;: mov %fs:0x28,%rax 0x0000000000400fbe &lt;+13&gt;: mov %rax,0x18(%rsp) 0x0000000000400fc3 &lt;+18&gt;: xor %eax,%eax 0x0000000000400fc5 &lt;+20&gt;: lea 0x14(%rsp),%r8 0x0000000000400fca &lt;+25&gt;: lea 0xf(%rsp),%rcx 0x0000000000400fcf &lt;+30&gt;: lea 0x10(%rsp),%rdx 0x0000000000400fd4 &lt;+35&gt;: mov $0x40273e,%esi 0x0000000000400fd9 &lt;+40&gt;: callq 0x400c40 &lt;__isoc99_sscanf@plt&gt; 0x0000000000400fde &lt;+45&gt;: cmp $0x2,%eax 0x0000000000400fe1 &lt;+48&gt;: jg 0x400fe8 &lt;phase_3+55&gt; 0x0000000000400fe3 &lt;+50&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000400fe8 &lt;+55&gt;: cmpl $0x7,0x10(%rsp， 0x0000000000400fed &lt;+60&gt;: ja 0x4010ef &lt;phase_3+318&gt; 0x0000000000400ff3 &lt;+66&gt;: mov 0x10(%rsp),%eax 0x0000000000400ff7 &lt;+70&gt;: jmpq *0x402750(,%rax,8) 0x0000000000400ffe &lt;+77&gt;: mov $0x66,%eax 0x0000000000401003 &lt;+82&gt;: cmpl $0xde,0x14(%rsp) 0x000000000040100b &lt;+90&gt;: je 0x4010f9 &lt;phase_3+328&gt; 0x0000000000401011 &lt;+96&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000401016 &lt;+101&gt;: mov $0x66,%eax 0x000000000040101b &lt;+106&gt;: jmpq 0x4010f9 &lt;phase_3+328&gt;---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x0000000000401020 &lt;+111&gt;: mov $0x74,%eax 0x0000000000401025 &lt;+116&gt;: cmpl $0x288,0x14(%rsp) 0x000000000040102d &lt;+124&gt;: je 0x4010f9 &lt;phase_3+328&gt; 0x0000000000401033 &lt;+130&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000401038 &lt;+135&gt;: mov $0x74,%eax 0x000000000040103d &lt;+140&gt;: jmpq 0x4010f9 &lt;phase_3+328&gt; 0x0000000000401042 &lt;+145&gt;: mov $0x76,%eax 0x0000000000401047 &lt;+150&gt;: cmpl $0x149,0x14(%rsp) 0x000000000040104f &lt;+158&gt;: je 0x4010f9 &lt;phase_3+328&gt; 0x0000000000401055 &lt;+164&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x000000000040105a &lt;+169&gt;: mov $0x76,%eax 0x000000000040105f &lt;+174&gt;: jmpq 0x4010f9 &lt;phase_3+328&gt; 0x0000000000401064 &lt;+179&gt;: mov $0x62,%eax 0x0000000000401069 &lt;+184&gt;: cmpl $0x2a7,0x14(%rsp) 0x0000000000401071 &lt;+192&gt;: je 0x4010f9 &lt;phase_3+328&gt; 0x0000000000401077 &lt;+198&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x000000000040107c &lt;+203&gt;: mov $0x62,%eax 0x0000000000401081 &lt;+208&gt;: jmp 0x4010f9 &lt;phase_3+328&gt; 0x0000000000401083 &lt;+210&gt;: mov $0x73,%eax 0x0000000000401088 &lt;+215&gt;: cmpl $0xc6,0x14(%rsp) 0x0000000000401090 &lt;+223&gt;: je 0x4010f9 &lt;phase_3+328&gt; 0x0000000000401092 &lt;+225&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000401097 &lt;+230&gt;: mov $0x73,%eax---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x000000000040109c &lt;+235&gt;: jmp 0x4010f9 &lt;phase_3+328&gt; 0x000000000040109e &lt;+237&gt;: mov $0x63,%eax 0x00000000004010a3 &lt;+242&gt;: cmpl $0x398,0x14(%rsp) 0x00000000004010ab &lt;+250&gt;: je 0x4010f9 &lt;phase_3+328&gt; 0x00000000004010ad &lt;+252&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x00000000004010b2 &lt;+257&gt;: mov $0x63,%eax 0x00000000004010b7 &lt;+262&gt;: jmp 0x4010f9 &lt;phase_3+328&gt; 0x00000000004010b9 &lt;+264&gt;: mov $0x67,%eax 0x00000000004010be &lt;+269&gt;: cmpl $0x1a5,0x14(%rsp) 0x00000000004010c6 &lt;+277&gt;: je 0x4010f9 &lt;phase_3+328&gt; 0x00000000004010c8 &lt;+279&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x00000000004010cd &lt;+284&gt;: mov $0x67,%eax 0x00000000004010d2 &lt;+289&gt;: jmp 0x4010f9 &lt;phase_3+328&gt; 0x00000000004010d4 &lt;+291&gt;: mov $0x67,%eax 0x00000000004010d9 &lt;+296&gt;: cmpl $0x109,0x14(%rsp) 0x00000000004010e1 &lt;+304&gt;: je 0x4010f9 &lt;phase_3+328&gt; 0x00000000004010e3 &lt;+306&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x00000000004010e8 &lt;+311&gt;: mov $0x67,%eax 0x00000000004010ed &lt;+316&gt;: jmp 0x4010f9 &lt;phase_3+328&gt; 0x00000000004010ef &lt;+318&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x00000000004010f4 &lt;+323&gt;: mov $0x71,%eax 0x00000000004010f9 &lt;+328&gt;: cmp 0xf(%rsp),%al 0x00000000004010fd &lt;+332&gt;: je 0x401104 &lt;phase_3+339&gt;---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x00000000004010ff &lt;+334&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000401104 &lt;+339&gt;: mov 0x18(%rsp),%rax 0x0000000000401109 &lt;+344&gt;: xor %fs:0x28,%rax 0x0000000000401112 &lt;+353&gt;: je 0x401119 &lt;phase_3+360&gt; 0x0000000000401114 &lt;+355&gt;: callq 0x400b90 &lt;__stack_chk_fail@plt&gt; 0x0000000000401119 &lt;+360&gt;: add $0x28,%rsp 0x000000000040111d &lt;+364&gt;: retqEnd of assembler dump. 首先看一下输入格式： (gdb) x/s 0x40273e0x40273e: &quot;%d %c %d&quot; 这里疯狂跳转，而且到处写着explode_bomb，仔细看一下其实就是个case语句，比方说如果输入的第一个数是0，那么就把第三个数和0xde比较，即222，不想等就爆炸，即第三个数为222，再把第二个和0x66，比较，第二个是字符型，转成字符就是f，一个答案：0 f 222. phase_41234567891011121314151617181920212223242526272829303132(gdb) disassemble phase_4Dump of assembler code for function phase_4: 0x0000000000401151 &lt;+0&gt;: sub $0x18,%rsp 0x0000000000401155 &lt;+4&gt;: mov %fs:0x28,%rax 0x000000000040115e &lt;+13&gt;: mov %rax,0x8(%rsp) 0x0000000000401163 &lt;+18&gt;: xor %eax,%eax 0x0000000000401165 &lt;+20&gt;: lea 0x4(%rsp),%rcx 0x000000000040116a &lt;+25&gt;: mov %rsp,%rdx 0x000000000040116d &lt;+28&gt;: mov $0x4029ed,%esi 0x0000000000401172 &lt;+33&gt;: callq 0x400c40 &lt;__isoc99_sscanf@plt&gt; 0x0000000000401177 &lt;+38&gt;: cmp $0x2,%eax 0x000000000040117a &lt;+41&gt;: jne 0x401182 &lt;phase_4+49&gt; 0x000000000040117c &lt;+43&gt;: cmpl $0xe,(%rsp) 0x0000000000401180 &lt;+47&gt;: jbe 0x401187 &lt;phase_4+54&gt; 0x0000000000401182 &lt;+49&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000401187 &lt;+54&gt;: mov $0xe,%edx 0x000000000040118c &lt;+59&gt;: mov $0x0,%esi 0x0000000000401191 &lt;+64&gt;: mov (%rsp),%edi 0x0000000000401194 &lt;+67&gt;: callq 0x40111e &lt;func4&gt; 0x0000000000401199 &lt;+72&gt;: cmp $0x1b,%eax 0x000000000040119c &lt;+75&gt;: jne 0x4011a5 &lt;phase_4+84&gt; 0x000000000040119e &lt;+77&gt;: cmpl $0x1b,0x4(%rsp) 0x00000000004011a3 &lt;+82&gt;: je 0x4011aa &lt;phase_4+89&gt; 0x00000000004011a5 &lt;+84&gt;: callq 0x401741 &lt;explode_bomb&gt;---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x00000000004011aa &lt;+89&gt;: mov 0x8(%rsp),%rax 0x00000000004011af &lt;+94&gt;: xor %fs:0x28,%rax 0x00000000004011b8 &lt;+103&gt;: je 0x4011bf &lt;phase_4+110&gt; 0x00000000004011ba &lt;+105&gt;: callq 0x400b90 &lt;__stack_chk_fail@plt&gt; 0x00000000004011bf &lt;+110&gt;: add $0x18,%rsp 0x00000000004011c3 &lt;+114&gt;: retqEnd of assembler dump. 输入格式是两个整数，然后第一个必须小于等于14，第二个必须是27。再把第一个参数传到fun4里面，如果返回值与27相等，就通过，否则爆炸。那么fun4是啥呢？ 1234567891011121314151617181920212223Dump of assembler code for function func4: 0x000000000040111e &lt;+0&gt;: push %rbx 0x000000000040111f &lt;+1&gt;: mov %edx,%eax 0x0000000000401121 &lt;+3&gt;: sub %esi,%eax 0x0000000000401123 &lt;+5&gt;: mov %eax,%ebx 0x0000000000401125 &lt;+7&gt;: shr $0x1f,%ebx 0x0000000000401128 &lt;+10&gt;: add %ebx,%eax 0x000000000040112a &lt;+12&gt;: sar %eax 0x000000000040112c &lt;+14&gt;: lea (%rax,%rsi,1),%ebx 0x000000000040112f &lt;+17&gt;: cmp %edi,%ebx 0x0000000000401131 &lt;+19&gt;: jle 0x40113f &lt;func4+33&gt; 0x0000000000401133 &lt;+21&gt;: lea -0x1(%rbx),%edx 0x0000000000401136 &lt;+24&gt;: callq 0x40111e &lt;func4&gt; 0x000000000040113b &lt;+29&gt;: add %ebx,%eax 0x000000000040113d &lt;+31&gt;: jmp 0x40114f &lt;func4+49&gt; 0x000000000040113f &lt;+33&gt;: mov %ebx,%eax 0x0000000000401141 &lt;+35&gt;: cmp %edi,%ebx 0x0000000000401143 &lt;+37&gt;: jge 0x40114f &lt;func4+49&gt; 0x0000000000401145 &lt;+39&gt;: lea 0x1(%rbx),%esi 0x0000000000401148 &lt;+42&gt;: callq 0x40111e &lt;func4&gt; 0x000000000040114d &lt;+47&gt;: add %ebx,%eax 0x000000000040114f &lt;+49&gt;: pop %rbx 0x0000000000401150 &lt;+50&gt;: retq 显然是个递归函数，可以把它转成c语言函数然后遍历一下，经队友提示可以把断点打在第二个explode_bomb函数之前，直接输入a 27，这样就能跳过第一个explode_bomb，单步执行到fun4调用完毕，看一下返回值就行了，得到的结果是9，所以答案是9 27 phase_5123456789101112131415161718192021222324252627282930313233343536(gdb) disassemble phase_5Dump of assembler code for function phase_5: 0x00000000004011c4 &lt;+0&gt;: push %rbx 0x00000000004011c5 &lt;+1&gt;: sub $0x10,%rsp 0x00000000004011c9 &lt;+5&gt;: mov %rdi,%rbx 0x00000000004011cc &lt;+8&gt;: mov %fs:0x28,%rax 0x00000000004011d5 &lt;+17&gt;: mov %rax,0x8(%rsp) 0x00000000004011da &lt;+22&gt;: xor %eax,%eax 0x00000000004011dc &lt;+24&gt;: callq 0x401454 &lt;string_length&gt; 0x00000000004011e1 &lt;+29&gt;: cmp $0x6,%eax 0x00000000004011e4 &lt;+32&gt;: je 0x4011eb &lt;phase_5+39&gt; 0x00000000004011e6 &lt;+34&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x00000000004011eb &lt;+39&gt;: mov $0x0,%eax 0x00000000004011f0 &lt;+44&gt;: movzbl (%rbx,%rax,1),%edx 0x00000000004011f4 &lt;+48&gt;: and $0xf,%edx 0x00000000004011f7 &lt;+51&gt;: movzbl 0x402790(%rdx),%edx 0x00000000004011fe &lt;+58&gt;: mov %dl,(%rsp,%rax,1) 0x0000000000401201 &lt;+61&gt;: add $0x1,%rax 0x0000000000401205 &lt;+65&gt;: cmp $0x6,%rax 0x0000000000401209 &lt;+69&gt;: jne 0x4011f0 &lt;phase_5+44&gt; 0x000000000040120b &lt;+71&gt;: movb $0x0,0x6(%rsp) 0x0000000000401210 &lt;+76&gt;: mov $0x402747,%esi 0x0000000000401215 &lt;+81&gt;: mov %rsp,%rdi 0x0000000000401218 &lt;+84&gt;: callq 0x401472 &lt;strings_not_equal&gt;---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x000000000040121d &lt;+89&gt;: test %eax,%eax 0x000000000040121f &lt;+91&gt;: je 0x401226 &lt;phase_5+98&gt; 0x0000000000401221 &lt;+93&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000401226 &lt;+98&gt;: mov 0x8(%rsp),%rax 0x000000000040122b &lt;+103&gt;: xor %fs:0x28,%rax 0x0000000000401234 &lt;+112&gt;: je 0x40123b &lt;phase_5+119&gt; 0x0000000000401236 &lt;+114&gt;: callq 0x400b90 &lt;__stack_chk_fail@plt&gt; 0x000000000040123b &lt;+119&gt;: add $0x10,%rsp 0x000000000040123f &lt;+123&gt;: pop %rbx 0x0000000000401240 &lt;+124&gt;: retqEnd of assembler dump. 看到两个奇怪的地址0x402790，打印一下看看 x/s 0x402790 0x402790 &lt;array.3601&gt;: &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot; x/s 0x402747 0x402747: &quot;devils&quot; 输入格式为1个字符串，长度为6，然后去那句话里面找到这6个字母的偏移，从输入的字符里面依次取低4位与之比较，比如这里的偏移为：2 5 12 4 15 7 ，我对照ascii码表找了一个合格的答案0010-b 0101-e 1100-l 0100-t 1111-o 0111-w ，即beltow，试一下，通过了。 phase_612345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182(gdb) disassemble phase_6Dump of assembler code for function phase_6: 0x0000000000401241 &lt;+0&gt;: push %r13 0x0000000000401243 &lt;+2&gt;: push %r12 0x0000000000401245 &lt;+4&gt;: push %rbp 0x0000000000401246 &lt;+5&gt;: push %rbx 0x0000000000401247 &lt;+6&gt;: sub $0x68,%rsp 0x000000000040124b &lt;+10&gt;: mov %fs:0x28,%rax 0x0000000000401254 &lt;+19&gt;: mov %rax,0x58(%rsp) 0x0000000000401259 &lt;+24&gt;: xor %eax,%eax 0x000000000040125b &lt;+26&gt;: mov %rsp,%rsi 0x000000000040125e &lt;+29&gt;: callq 0x401777 &lt;read_six_numbers&gt; 0x0000000000401263 &lt;+34&gt;: mov %rsp,%r12 0x0000000000401266 &lt;+37&gt;: mov $0x0,%r13d 0x000000000040126c &lt;+43&gt;: mov %r12,%rbp 0x000000000040126f &lt;+46&gt;: mov (%r12),%eax 0x0000000000401273 &lt;+50&gt;: sub $0x1,%eax 0x0000000000401276 &lt;+53&gt;: cmp $0x5,%eax 0x0000000000401279 &lt;+56&gt;: jbe 0x401280 &lt;phase_6+63&gt; 0x000000000040127b &lt;+58&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000401280 &lt;+63&gt;: add $0x1,%r13d 0x0000000000401284 &lt;+67&gt;: cmp $0x6,%r13d 0x0000000000401288 &lt;+71&gt;: je 0x4012c7 &lt;phase_6+134&gt; 0x000000000040128a &lt;+73&gt;: mov %r13d,%ebx 0x000000000040128d &lt;+76&gt;: movslq %ebx,%rax 0x0000000000401290 &lt;+79&gt;: mov (%rsp,%rax,4),%eax 0x0000000000401293 &lt;+82&gt;: cmp %eax,0x0(%rbp) 0x0000000000401296 &lt;+85&gt;: jne 0x40129d &lt;phase_6+92&gt; 0x0000000000401298 &lt;+87&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x000000000040129d &lt;+92&gt;: add $0x1,%ebx 0x00000000004012a0 &lt;+95&gt;: cmp $0x5,%ebx 0x00000000004012a3 &lt;+98&gt;: jle 0x40128d &lt;phase_6+76&gt; 0x00000000004012a5 &lt;+100&gt;: add $0x4,%r12 0x00000000004012a9 &lt;+104&gt;: jmp 0x40126c &lt;phase_6+43&gt; 0x00000000004012ab &lt;+106&gt;: mov 0x8(%rdx),%rdx 0x00000000004012af &lt;+110&gt;: add $0x1,%eax 0x00000000004012b2 &lt;+113&gt;: cmp %ecx,%eax 0x00000000004012b4 &lt;+115&gt;: jne 0x4012ab &lt;phase_6+106&gt; 0x00000000004012b6 &lt;+117&gt;: mov %rdx,0x20(%rsp,%rsi,2) 0x00000000004012bb &lt;+122&gt;: add $0x4,%rsi 0x00000000004012bf &lt;+126&gt;: cmp $0x18,%rsi 0x00000000004012c3 &lt;+130&gt;: jne 0x4012cc &lt;phase_6+139&gt; 0x00000000004012c5 &lt;+132&gt;: jmp 0x4012e0 &lt;phase_6+159&gt; 0x00000000004012c7 &lt;+134&gt;: mov $0x0,%esi 0x00000000004012cc &lt;+139&gt;: mov (%rsp,%rsi,1),%ecx 0x00000000004012cf &lt;+142&gt;: mov $0x1,%eax 0x00000000004012d4 &lt;+147&gt;: mov $0x604300,%edx---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x00000000004012d9 &lt;+152&gt;: cmp $0x1,%ecx 0x00000000004012dc &lt;+155&gt;: jg 0x4012ab &lt;phase_6+106&gt; 0x00000000004012de &lt;+157&gt;: jmp 0x4012b6 &lt;phase_6+117&gt; 0x00000000004012e0 &lt;+159&gt;: mov 0x20(%rsp),%rbx 0x00000000004012e5 &lt;+164&gt;: lea 0x20(%rsp),%rax 0x00000000004012ea &lt;+169&gt;: lea 0x48(%rsp),%rsi 0x00000000004012ef &lt;+174&gt;: mov %rbx,%rcx 0x00000000004012f2 &lt;+177&gt;: mov 0x8(%rax),%rdx 0x00000000004012f6 &lt;+181&gt;: mov %rdx,0x8(%rcx) 0x00000000004012fa &lt;+185&gt;: add $0x8,%rax 0x00000000004012fe &lt;+189&gt;: mov %rdx,%rcx 0x0000000000401301 &lt;+192&gt;: cmp %rsi,%rax 0x0000000000401304 &lt;+195&gt;: jne 0x4012f2 &lt;phase_6+177&gt; 0x0000000000401306 &lt;+197&gt;: movq $0x0,0x8(%rdx) 0x000000000040130e &lt;+205&gt;: mov $0x5,%ebp 0x0000000000401313 &lt;+210&gt;: mov 0x8(%rbx),%rax 0x0000000000401317 &lt;+214&gt;: mov (%rax),%eax 0x0000000000401319 &lt;+216&gt;: cmp %eax,(%rbx) 0x000000000040131b &lt;+218&gt;: jge 0x401322 &lt;phase_6+225&gt; 0x000000000040131d &lt;+220&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x0000000000401322 &lt;+225&gt;: mov 0x8(%rbx),%rbx 0x0000000000401326 &lt;+229&gt;: sub $0x1,%ebp 0x0000000000401329 &lt;+232&gt;: jne 0x401313 &lt;phase_6+210&gt; 0x000000000040132b &lt;+234&gt;: mov 0x58(%rsp),%rax 0x0000000000401330 &lt;+239&gt;: xor %fs:0x28,%rax 0x0000000000401339 &lt;+248&gt;: je 0x401340 &lt;phase_6+255&gt; 0x000000000040133b &lt;+250&gt;: callq 0x400b90 &lt;__stack_chk_fail@plt&gt; 0x0000000000401340 &lt;+255&gt;: add $0x68,%rsp 0x0000000000401344 &lt;+259&gt;: pop %rbx 0x0000000000401345 &lt;+260&gt;: pop %rbp 0x0000000000401346 &lt;+261&gt;: pop %r12 0x0000000000401348 &lt;+263&gt;: pop %r13 0x000000000040134a &lt;+265&gt;: retqEnd of assembler dump. 代码贼长，看的心累，慢慢看下去会发现是个链表，而且有编号，而且要对其进行升序排列，而输入的格式又恰好是6个整数，显然就是要输入6个结点的序号了。重点是这个地址：0x604300，很突兀，看一下里面是啥（这个结果要输入一个顺序后才能看到 啊哦，这不就全出来了吗，按照升序排列的话，就是：3 1 6 2 5 4 secret_phase直接搜源码，把里面可疑的地址都打印看一下会发现有一个输入格式是“%d %d %s”，而且找到那个字符串为DrEvil，回忆一下前面那几关，只有第四关的输入格式是%d %d，跟要求的格式的前两个一样，退出重新输入答案，在9 27后面加DrEvil，过了第6关后就进了隐藏关了。 123456789101112131415161718192021222324(gdb) disassemble secret_phaseDump of assembler code for function secret_phase: 0x0000000000401389 &lt;+0&gt;: push %rbx 0x000000000040138a &lt;+1&gt;: callq 0x4017b6 &lt;read_line&gt; 0x000000000040138f &lt;+6&gt;: mov $0xa,%edx 0x0000000000401394 &lt;+11&gt;: mov $0x0,%esi 0x0000000000401399 &lt;+16&gt;: mov %rax,%rdi 0x000000000040139c &lt;+19&gt;: callq 0x400c20 &lt;strtol@plt&gt; 0x00000000004013a1 &lt;+24&gt;: mov %rax,%rbx 0x00000000004013a4 &lt;+27&gt;: lea -0x1(%rax),%eax 0x00000000004013a7 &lt;+30&gt;: cmp $0x3e8,%eax 0x00000000004013ac &lt;+35&gt;: jbe 0x4013b3 &lt;secret_phase+42&gt; 0x00000000004013ae &lt;+37&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x00000000004013b3 &lt;+42&gt;: mov %ebx,%esi 0x00000000004013b5 &lt;+44&gt;: mov $0x604120,%edi 0x00000000004013ba &lt;+49&gt;: callq 0x40134b &lt;fun7&gt; 0x00000000004013bf &lt;+54&gt;: test %eax,%eax 0x00000000004013c1 &lt;+56&gt;: je 0x4013c8 &lt;secret_phase+63&gt; 0x00000000004013c3 &lt;+58&gt;: callq 0x401741 &lt;explode_bomb&gt; 0x00000000004013c8 &lt;+63&gt;: mov $0x402718,%edi 0x00000000004013cd &lt;+68&gt;: callq 0x400b70 &lt;puts@plt&gt; 0x00000000004013d2 &lt;+73&gt;: callq 0x4018dc &lt;phase_defused&gt; 0x00000000004013d7 &lt;+78&gt;: pop %rbx 0x00000000004013d8 &lt;+79&gt;: retq 逻辑似乎很简单，它把你的输入转成10进制数，先与1000(0x3e8)比较，如果大于1000直接炸掉，如果不相等，那么把它作为第二个参数传到fun7，如果返回值大于0，爆炸。看一下fun7 12345678910111213141516171819202122Dump of assembler code for function fun7: 0x000000000040134b &lt;+0&gt;: sub $0x8,%rsp 0x000000000040134f &lt;+4&gt;: test %rdi,%rdi 0x0000000000401352 &lt;+7&gt;: je 0x40137f &lt;fun7+52&gt; 0x0000000000401354 &lt;+9&gt;: mov (%rdi),%edx 0x0000000000401356 &lt;+11&gt;: cmp %esi,%edx 0x0000000000401358 &lt;+13&gt;: jle 0x401367 &lt;fun7+28&gt; 0x000000000040135a &lt;+15&gt;: mov 0x8(%rdi),%rdi 0x000000000040135e &lt;+19&gt;: callq 0x40134b &lt;fun7&gt; 0x0000000000401363 &lt;+24&gt;: add %eax,%eax 0x0000000000401365 &lt;+26&gt;: jmp 0x401384 &lt;fun7+57&gt; 0x0000000000401367 &lt;+28&gt;: mov $0x0,%eax 0x000000000040136c &lt;+33&gt;: cmp %esi,%edx 0x000000000040136e &lt;+35&gt;: je 0x401384 &lt;fun7+57&gt; 0x0000000000401370 &lt;+37&gt;: mov 0x10(%rdi),%rdi 0x0000000000401374 &lt;+41&gt;: callq 0x40134b &lt;fun7&gt; 0x0000000000401379 &lt;+46&gt;: lea 0x1(%rax,%rax,1),%eax 0x000000000040137d &lt;+50&gt;: jmp 0x401384 &lt;fun7+57&gt; 0x000000000040137f &lt;+52&gt;: mov $0xffffffff,%eax 0x0000000000401384 &lt;+57&gt;: add $0x8,%rsp 0x0000000000401388 &lt;+61&gt;: retqEnd of assembler dump. 显然是个递归函数，第一个参数显然很可疑，看一下是啥 12345678910111213141516171819202122232425262728293031(gdb) x/120 0x6041200x604120 &lt;n1&gt;: 36 0 6308160 00x604130 &lt;n1+16&gt;: 6308192 0 0 00x604140 &lt;n21&gt;: 8 0 6308288 00x604150 &lt;n21+16&gt;: 6308224 0 0 00x604160 &lt;n22&gt;: 50 0 6308256 00x604170 &lt;n22+16&gt;: 6308320 0 0 00x604180 &lt;n32&gt;: 22 0 6308512 00x604190 &lt;n32+16&gt;: 6308448 0 0 00x6041a0 &lt;n33&gt;: 45 0 6308352 00x6041b0 &lt;n33+16&gt;: 6308544 0 0 00x6041c0 &lt;n31&gt;: 6 0 6308384 00x6041d0 &lt;n31+16&gt;: 6308480 0 0 00x6041e0 &lt;n34&gt;: 107 0 6308416 00x6041f0 &lt;n34+16&gt;: 6308576 0 0 00x604200 &lt;n45&gt;: 40 0 0 00x604210 &lt;n45+16&gt;: 0 0 0 00x604220 &lt;n41&gt;: 1 0 0 00x604230 &lt;n41+16&gt;: 0 0 0 00x604240 &lt;n47&gt;: 99 0 0 00x604250 &lt;n47+16&gt;: 0 0 0 00x604260 &lt;n44&gt;: 35 0 0 00x604270 &lt;n44+16&gt;: 0 0 0 00x604280 &lt;n42&gt;: 7 0 0 00x604290 &lt;n42+16&gt;: 0 0 0 00x6042a0 &lt;n43&gt;: 20 0 0 00x6042b0 &lt;n43+16&gt;: 0 0 0 00x6042c0 &lt;n46&gt;: 47 0 0 00x6042d0 &lt;n46+16&gt;: 0 0 0 00x6042e0 &lt;n48&gt;: 1001 0 0 00x6042f0 &lt;n48+16&gt;: 0 0 0 0 二叉树。。。。。它结点的命名很有规律，直接画出来都行。 然后fun7的逻辑可疑整理一下，写成c语言大概是这样的： 123456789101112131415161718int fun7(BiTree T,int v)&#123;//v是传入的那个整数 int result; if(T)&#123; if(T-&gt;data &lt;= v)&#123; result = 0; if(T-&gt;data != v)&#123; result = 2 * fun7(T-&gt;right,v) + 1; &#125; &#125; else&#123; result = 2 * fun7(T-&gt;left,v); &#125; &#125; else&#123; result = -1; &#125; return result;&#125; 把那颗二叉树直接保存下来然后爆破一下即可，因为上周刚好写完了树的基本操作，所以自己电脑上有环境直接跑 123456for(int i = 0;i &lt; 1000;i++)&#123; if(!fun7(T,i))&#123; printf("answer: %d ",i); // break; &#125; &#125; 结果竟然只有4个？？？咦，厉害了 通关截图： tips总结了一点技巧（骚姿势）：b explode_bomb（这个应该都会）；如果绕不过检测函数，可以选择让它炸一次，然后看返回值；直接把包拖到本地，把检测host和记录答题状态的函数全部nop掉，这样在本地想怎么玩就怎么玩；IDA！！！！！！！（我就借助了IDA，捂脸φ(&gt;ω&lt;) φ(&gt;ω&lt;)]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>bomblab，csapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mirages-CTF writeup]]></title>
    <url>%2F2017%2F11%2F09%2FMirages-CTF-writeup%2F</url>
    <content type="text"><![CDATA[​ 这次的比赛分为3周，学长说第一周的挺基础，适合我们练手，正好最近离散停课，计算方法也没开，时间还算充足，就进坑了。虽说是个人赛，但实际上是和小队成员开黑做的23333。做出来的题基本是上是web和misc，re。。。。不会，先好好学学汇编以及计算机系统再说。在这稍微总结一下web和misc webWeb第一步打开链接就看到了这么一句话：一看你就不是组织的人,不用组织的ip，还想进组织的网站。23333，意思很明显了，伪造ip。刚开始纳闷了会儿，他们组织的ip到底是啥呀我也不知道哇，然后看到了这个链接的title上写着：110.110.110.110。好吧，修改一下X-Forwarded-For，刷新。然后是另一句话：I like Iphone X. Why don’t you use it? 伪造ua。。。注意这里有个坑，很多人还去搜了Iphone X的ua，其实不用，直接写Iphone X就OK了，题目给了Hint：简体中文。说的就是这个。再刷新：Actually, I’m Chinese,I don’t want to hear any other language。还要改语言。。。一开始我直接改成了Chinese，发现没反应，于是换成了zh-CN，可以了。再刷新：Not a local login. Do you want flag? 改host….其实就是改请求头而已，干嘛还要改4次，有毒。 flag:mctf{_Wh01e_FamilY} PHP加密题目：加油吧，骚年，莫名其妙的字符串，必有其来源 。打开链接一看，发现是一串base64. fTdydHtWOV9gaG5VXDJqPHcxPFxhbHRVfDdpPUV5TlxdQ2hpVWA= 1&#125;\7arltt&#123;UV|97_i`=hEnyUN\\2]jC&lt;hwi1U&lt;` 直接解密显然不对，应该还有一段加密函数。@kurumi扫了下后说有源码，顺便丢给了我们。 1234567891011121314151617181920212223&lt;?php$flag = 'flag&#123;********************************&#125;';$flag= strrev($flag);$key = '*';for($i=0;$i&lt;strlen($flag);$i++)&#123; $str[$i] = ord($flag[$i])+ord($key)*$i; while($str[$i]&gt;125) &#123; $str[$i] = $str[$i]-78; &#125;&#125;$out = "";for($i=0;$i&lt;strlen($flag);$i=$i+2)&#123; $out = $out.chr($str[$i]);&#125;for($i=1;$i&lt;strlen($flag);$i=$i+2)&#123; $out = $out.chr($str[$i]);&#125;echo base64_encode($out);?&gt; 加密流程大概就是，先逆转，然后遍历，令str这个数组的每一位等于对应位置上字符的ascii码值加上下标乘以42，如果这个数值大于125，就减78，直到小于等于125为止，然后再把str这个数组的偶数下标位抽出来，插到后面。大概就是把abcdef变成acebdf这样。 脚本写来写去还是有问题，最后没能跑出来QAQ，借鉴了队友@kurumi的脚本： 1234567891011121314151617181920212223242526272829303132import base64import sysdef decrypto(out, key): t = base64.b64decode(out) #print [ord(x) for x in t] a = t[:(len(t)+1)/2] b = t[(len(t)+1)/2:] t = '' for i in range(min(len(a), len(b))): t += a[0] t += b[0] a = a[1:] b = b[1:] if a: t += a[0] if b: t += b[0] t = [ord(x) for x in t] for i in range(len(t)): while t[i] &lt; i * 42: t[i] += 78 t[i] -= i * 42 if not 32 &lt;= t[i] &lt;= 126: t[i] += 78 print ''.join([chr(x) for x in t])[::-1]def main(): decrypto('fTdydHtWOV9gaG5VXDJqPHcxPFxhbHRVfDdpPUV5TlxdQ2hpVWA=', 42)main() 虽然可能会有点不精确，但最后修正一下就行了。。。(一开始有点死脑筋，但这题应该是可以直接恢复的，逻辑和算法太菜了哎) flag{e20ad328b0aa23210c57c48ac8b6f112} 忘记密码忘了童年的QQ账号以及密码！！这题的title也有提示，md5，而且源码里边也有提示：密码全是字母。一开始以为是md5碰撞，爆破什么的也试过。最后学长发现，这TM就是一个php弱类型比较。找纯数字和纯大写字母的md5值为0e开头的即可。 flag:MCTF{Md5_1s_So_SaD} 喵喵喵喜欢撸猫就一起来吧。title为：听说猫喜欢机器人。显然是robots协议，看一下，果然有源码： 123456789101112131415161718192021222324252627&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=gbk&quot;&gt;&lt;title&gt;听说猫喜欢机器人&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;./aabbcc.jpg&quot;&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php$flag=&apos;********&apos;;if (isset ($_GET[&apos;cat&apos;])) &#123; if (ereg (&quot;^[0-9b-f]+$&quot;, $_GET[&apos;cat&apos;]) === FALSE) echo &apos;喵喵好像特别喜欢小写字母和数字&apos;; else if ($_GET[&apos;cat&apos;]==0) &#123; if(strpos ($_GET[&apos;cat&apos;], &apos;miaomiao&apos;) !==FALSE) &#123; die(&apos;Flag: &apos;.$flag); &#125; else &#123; echo &apos;&lt;p&gt;好像必须要喵喵呢&lt;/p&gt;&apos;;&#125; &#125; else&#123;echo &apos;&lt;p&gt;喵喵迷路了&lt;/p&gt;&apos;;&#125; &#125;?&gt; 传入一个cat，先检测是否在0-9和b-f范围内，再判断是否为零，发现这里是弱类比较，只有两个等号，显然可以用0e绕，然后还要有miaomiao，也就是要有a，那就00截断吧。大概就是这样了构造url：http://116.196.124.92:32769?cat=0e2333%00miaomiao flag:mctf{you_get_ereg} phpbest!!!1php是世界上最好的语言！谁说不是我跟谁急！ 还加了个网易云链接：当初就不该学php。有闲情的话去听听吧23333。这次的title为：Secure Hash Algorithm又是Hash？？而且有这么一句：这货不是SQL，我绝对不骗人。要求输入name 和 pass来登录，试了下注入，好吧，真的不是。根据前面几题的经验，title提示都是有用的，于是开始考虑php的弱类型，用0e也不对。然后直接post数据，用数组试试，。。。！！！！过了？？？？ name[]=2&amp;pass[]=3 flag:mctf{This_is_the_fulage} 投身黑产的b佬1题目类似于一个老虎机，抽到05555就有flag，hint: bp真好用，直接用bp碰撞拿到flag。 flag:{Good_luck_Boy!} (万一是个妹子呢2333333 Misc这有flag下载下来是一张图片，Hint: 萌新温馨提示：使用二进制工具（010 editor, winhex）来查看文件/你听过base64吗。。。这提示约等于wp了吧。。。。16进制打开末尾有base64串，解密即可 flag:MCTF{th1s_ls_fL4g} 这有flag？还是图片，用stegesolve看一下，emmmm，没什么用，LSB也没有什么，binwalk分析一下 123456DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, EXIF standard12 0xC TIFF image data, big-endian, offset of first image directory: 813446 0x3486 Zip archive data, at least v2.0 to extract, compressed size: 17, uncompressed size: 15, name: flag.txt13591 0x3517 End of Zip archive 有压缩包，foremost 2.jpg ，直接解压那个zip包，发现里面有flag.txt，打开得到flag flag:MCTF{Real_F1Ag} 这有flag？？这个题又不小心存进了明文，按理来说应该要去改高度啥的才能看到flag，由于我有先strings的习惯，于是就。。。。 12345678strings 3.png | grep &#123;v/&#123;LSCs&#123;`:&gt;=e &lt;photoshop:LayerName&gt;MCTF&#123;Hhhh_g0t_1t&#125;&lt;/photoshop:LayerName&gt; &lt;photoshop:LayerText&gt;MCTF&#123;Hhhh_g0t_1t&#125;&lt;/photoshop:LayerText&gt;&#123;&amp;hPD &#123;[k&lt;&#123;A$FU 就直接拿到了flag。。。。 flag:MCTF{Hhhh_g0t_1t} 签到题加群，群相册有二维码，关注公众号发送flag即可。 falg:MCTF{We1c0me_2_MCTF} 这有flag？？？这个150分的题，本来脑洞还有点大的，但后来放了这么一个Hint: 萌新温馨提示：LSB/plaintext莫非是出题人怕被打？嗯哼？下载下来是一张图片和一个hint文件，而且hint没有后缀。LSB嘛，把图片提取一下，发现有个zip压缩包，改后缀，解压走起，有密码？？？？试试是不是伪加密，然而并不是。哎，它都已经给了提示了。。。明文攻击（然而我们做的时候并没有，还是qrzbing 提示我做出来的）看一下加密包，里面有flag.txt和一张图片，然后转而分析hint文件，binwalk一下： 1234567891011121314151617binwalk hintDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 Zip archive data, at least v2.0 to extract, compressed size: 346, uncompressed size: 1312, name: [Content_Types].xml915 0x393 Zip archive data, at least v2.0 to extract, compressed size: 239, uncompressed size: 590, name: _rels/.rels1715 0x6B3 Zip archive data, at least v2.0 to extract, compressed size: 244, uncompressed size: 817, name: word/_rels/document.xml.rels2281 0x8E9 Zip archive data, at least v2.0 to extract, compressed size: 854, uncompressed size: 2973, name: word/document.xml3182 0xC6E Zip archive data, at least v2.0 to extract, compressed size: 1761, uncompressed size: 8398, name: word/theme/theme1.xml4994 0x1382 Zip archive data, at least v2.0 to extract, compressed size: 1337, uncompressed size: 3725, name: word/settings.xml6378 0x18EA Zip archive data, at least v2.0 to extract, compressed size: 501, uncompressed size: 1444, name: word/fontTable.xml6927 0x1B0F Zip archive data, at least v2.0 to extract, compressed size: 295, uncompressed size: 655, name: word/webSettings.xml7272 0x1C68 Zip archive data, at least v2.0 to extract, compressed size: 364, uncompressed size: 711, name: docProps/app.xml7946 0x1F0A Zip archive data, at least v2.0 to extract, compressed size: 385, uncompressed size: 757, name: docProps/core.xml8642 0x21C2 Zip archive data, at least v2.0 to extract, compressed size: 2904, uncompressed size: 29103, name: word/styles.xml11591 0x2D47 Zip archive data, at least v2.0 to extract, compressed size: 11906, uncompressed size: 12427, name: docProps/key.xml24346 0x5F1A End of Zip archive 又是一个zip包，改后缀打开，注意到docProps目录下有个key.xml，而且还是2017.10.22修改过的，很明显了，然后分析一下这个key.xml，发现它是一张图片，那么很显然，明文攻击的已知文件就在这了。压缩，直接爆，1分钟不到就爆开了，打开flag.txt，发现里面是这样的： 1VSBmaW5kIG1lLHRoZW4gSSdsbCBnaXZlIHUgbXkgZmxhZzpNQ1RGe0xTQl8mJl9wbEBpblRleHR9LkRvIHUgdGhpbmsgaXMgaXQgc28gZnVja2luZyBlZ2c/bGFpIGRhIHdvIHlhIGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaA== 显然是个base64，但后面那一串重复的什么鬼啊，解密一下看看 1U find me,then I&apos;ll give u my flag:MCTF&#123;LSB_&amp;&amp;_pl@inText&#125;.Do u think is it so fucking egg?lai da wo ya hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 看到了吗？lai da wo ya。。。丫的以为我不敢吗？ flag:MCTF{LSB_&amp;&amp;_pl@inText} 这有flag-ex本来Hint给的是Water，可能出题人觉得太隐晦了，后来就直接改成了水印。。我也不是很懂盲水印这玩意儿，google了一波，在github上找到了这段脚本，装上python的一些第三方库后跑一个命令就OK了。参考链接 （PS：感觉这200分的题比150分的好做，如果都不给Hint的话。 flag:MCTF{W4T3RMark_1s_c00l} 最后来一波霸气的图片5连 话说还是好好学数据机构离散和数电，其余时间写写python，看看二进制，刷刷英语好了，太菜了，肝不动、肝不动。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈与堆]]></title>
    <url>%2F2017%2F10%2F28%2F%E6%A0%88%E4%B8%8E%E5%A0%86%2F</url>
    <content type="text"><![CDATA[​ 昨天参加了Pwn师傅的入门课，嗯，&lt;（我以为大家都是零基础，结果最后发现只有我才是）.png&gt;，（传图好麻烦，偷点懒。）二进制安全对底层的知识要求还是挺高的，也难怪pwn入门难度是最高的233333。今天稍微学习了一下堆和栈的区别，写点笔记。 程序的内存分配一般来说，由c/c++编译的程序（划重点：已经编译！）要占用的内存分为以下几个部分： 1.栈区（stack）：一般由系统自动分配释放、存放函数参数值、局部变量值等，操作方式有点类似于数据结构中的栈（然而要复杂的多，一开始pwn师傅问我们懂不懂栈的时候我还以为是数据结构中的栈，尴尬.png） 2.堆区（heap）：一般由程序员自主分配和释放，没有释放的话OS有可能会回收，而且和数据结构中的堆区别很大。 3.全局（静态）区（static）：初始化的全局变量和静态变量会放在同一块区域，未初始化的则会放在相邻的另一块区域，程序运行结束后空间由系统释放。 4.常量区：比如字符串。程序运行结束后空间由系统释放。 5.代码区：即函数的二进制代码。 示例：（这例子貌似被引用了千万次了23333） 1234567891011121314int a = 0; //全局初始化区char *p1; //全局未初始化区main()&#123; int b; //栈 char s[] = "abc";// 栈 char *p2; 栈 char *p3 = "123456"; //123456\0在常量区，p3在栈上。 static int c =0； //全局（静态）初始化区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区。 strcpy(p1, "123456"); //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。&#125; 堆与栈的比较申请方式栈：系统自动分配。比如在函数里面声明局部变量 int i； 堆：程序员自行分配，并指定大小。c中的malloc ， c++中的 new 申请后系统的响应栈：只要剩余空间大于申请空间，系统即为其提供相应内存，否则会异常。 堆：这里又有一个知识点：OS有一个记录空闲内存的链表，收到堆空间申请时会开始遍历这个链表，找到一个空间大于所要申请的空间后便把这个结点从空闲结点链表里面删掉并将这块空间分给程序，而且大多数系统会自动记录这块空间的首地址以便于正确释放这块空间。多余的空间则会返回给空闲链表。 申请大小的限制栈：在win下，栈的地址是往地位扩展的，而且是连续的内存区域，所以栈顶的地址以及栈的最大容量，系统都已经固定好了，无法修改，因此栈能够获得的空间较小。 堆：与栈相反，堆是往高地址扩展的数据结构，不连续，显然，因为这是系统在空闲链表里面找到的内存，然后分给你的，当然是各个地方的空间都有。所以堆获得的空间比较灵活，空间大小也就更大了。 申请效率栈：由系统自动分配，速度比较快，但无法控制。 堆：自行分配，一般来说速度比栈要慢，而且很容易产生内存碎片， 但用起来最方便。 存储内容栈：函数调用时，最先进栈的是主函数中后的下一条指令的地址，接着是函数的参数，大部分c的编译器中，参数都是从右到左入栈的，接着是函数的局部变量，但静态变量不会入栈。当函数开始调用时，这时就体现遵循后进先出的原则了，局部变量最先出栈，然后是参数，最后是栈顶指针存的地址，也就是主函数中的下一条指令，程序从这里继续运行。 堆：一般，堆的头部会用一个字节来存放堆的大小，具体由程序员安排。 存取效率示例代码： 12345678910#includeint main()&#123; char a = 1; char c[] = "1234567890"; char *p ="1234567890"; a = c[1]; a = p[1]; return 0;&#125; c[]在运行时刻赋值，而*p在编译时确定，但在以后的存取中，栈上的数组比指针指向的字符串要快。具体原理自己看一下汇编的代码就清楚了。 小结使用栈就像去餐馆吃饭，只要点菜（申请）和吃（使用），吃饱了就可以走人，不必理会切菜、洗菜什么的细节，快捷方便，但是自由度小。 使用堆就是自己动手做了，比较麻烦，要顾细节，但是自由度大。 感想​ pwn的门槛真心比web高了不少，得恶补基础知识才行，都大二的人了，还啥都不懂，怪不得是鶸字辈。 参考出处：一条鱼@博客园]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中华人民共和国网络安全法]]></title>
    <url>%2F2017%2F10%2F25%2F%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[​ 都说不懂法的人是没法搞安全的，仔细想想有那么几分道理，说不定CTF就从入门到入狱了23333。嗯，好好学习一波。 目录 第一章 总则 第二章 网络安全支持与促进 第三章 网络运行安全 第一节 一般规定 第二节 关键信息基础设施的运行安全 第四章 网络信息安全 第五章 监测预警与应急处置 第六章 法律责任 第七章 附 则 条文 第一章 总 则 第一条 为了保障网络安全，维护网络空间主权和国家安全、社会公共利益，保护公民、法人和其他组织的合法权益，促进经济社会信息化健康发展，制定本法。 第二条 在中华人民共和国境内建设、运营、维护和使用网络，以及网络安全的监督管理，适用本法。 第三条 国家坚持网络安全与信息化发展并重，遵循积极利用、科学发展、依法管理、确保安全的方针，推进网络基础设施建设和互联互通，鼓励网络技术创新和应用，支持培养网络安全人才，建立健全网络安全保障体系，提高网络安全保护能力。 第四条 国家制定并不断完善网络安全战略，明确保障网络安全的基本要求和主要目标，提出重点领域的网络安全政策、工作任务和措施。 第五条 国家采取措施，监测、防御、处置来源于中华人民共和国境内外的网络安全风险和威胁，保护关键信息基础设施免受攻击、侵入、干扰和破坏，依法惩治网络违法犯罪活动，维护网络空间安全和秩序。 第六条 国家倡导诚实守信、健康文明的网络行为，推动传播社会主义核心价值观，采取措施提高全社会的网络安全意识和水平，形成全社会共同参与促进网络安全的良好环境。 第七条 国家积极开展网络空间治理、网络技术研发和标准制定、打击网络违法犯罪等方面的国际交流与合作，推动构建和平、安全、开放、合作的网络空间，建立多边、民主、透明的网络治理体系。 第八条 国家网信部门负责统筹协调网络安全工作和相关监督管理工作。国务院电信主管部门、公安部门和其他有关机关依照本法和有关法律、行政法规的规定，在各自职责范围内负责网络安全保护和监督管理工作。 县级以上地方人民政府有关部门的网络安全保护和监督管理职责，按照国家有关规定确定。 第九条 网络运营者开展经营和服务活动，必须遵守法律、行政法规，尊重社会公德，遵守商业道德，诚实信用，履行网络安全保护义务，接受政府和社会的监督，承担社会责任。 第十条 建设、运营网络或者通过网络提供服务，应当依照法律、行政法规的规定和国家标准的强制性要求，采取技术措施和其他必要措施，保障网络安全、稳定运行，有效应对网络安全事件，防范网络违法犯罪活动，维护网络数据的完整性、保密性和可用性。 第十一条 网络相关行业组织按照章程，加强行业自律，制定网络安全行为规范，指导会员加强网络安全保护，提高网络安全保护水平，促进行业健康发展。 第十二条 国家保护公民、法人和其他组织依法使用网络的权利，促进网络接入普及，提升网络服务水平，为社会提供安全、便利的网络服务，保障网络信息依法有序自由流动。 任何个人和组织使用网络应当遵守宪法法律，遵守公共秩序，尊重社会公德，不得危害网络安全，不得利用网络从事危害国家安全、荣誉和利益，煽动颠覆国家政权、推翻社会主义制度，煽动分裂国家、破坏国家统一，宣扬恐怖主义、极端主义，宣扬民族仇恨、民族歧视，传播暴力、淫秽色情信息，编造、传播虚假信息扰乱经济秩序和社会秩序，以及侵害他人名誉、隐私、知识产权和其他合法权益等活动。 第十三条 国家支持研究开发有利于未成年人健康成长的网络产品和服务，依法惩治利用网络从事危害未成年人身心健康的活动，为未成年人提供安全、健康的网络环境。 第十四条 任何个人和组织有权对危害网络安全的行为向网信、电信、公安等部门举报。收到举报的部门应当及时依法作出处理；不属于本部门职责的，应当及时移送有权处理的部门。 有关部门应当对举报人的相关信息予以保密，保护举报人的合法权益。 第二章 网络安全支持与促进 第十五条 国家建立和完善网络安全标准体系。国务院标准化行政主管部门和国务院其他有关部门根据各自的职责，组织制定并适时修订有关网络安全管理以及网络产品、服务和运行安全的国家标准、行业标准。 国家支持企业、研究机构、高等学校、网络相关行业组织参与网络安全国家标准、行业标准的制定。 第十六条 国务院和省、自治区、直辖市人民政府应当统筹规划，加大投入，扶持重点网络安全技术产业和项目，支持网络安全技术的研究开发和应用，推广安全可信的网络产品和服务，保护网络技术知识产权，支持企业、研究机构和高等学校等参与国家网络安全技术创新项目。 第十七条 国家推进网络安全社会化服务体系建设，鼓励有关企业、机构开展网络安全认证、检测和风险评估等安全服务。 第十八条 国家鼓励开发网络数据安全保护和利用技术，促进公共数据资源开放，推动技术创新和经济社会发展。 国家支持创新网络安全管理方式，运用网络新技术，提升网络安全保护水平。 第十九条 各级人民政府及其有关部门应当组织开展经常性的网络安全宣传教育，并指导、督促有关单位做好网络安全宣传教育工作。 大众传播媒介应当有针对性地面向社会进行网络安全宣传教育。 第二十条 国家支持企业和高等学校、职业学校等教育培训机构开展网络安全相关教育与培训，采取多种方式培养网络安全人才，促进网络安全人才交流。 第三章 网络运行安全 第一节 一般规定 第二十一条 国家实行网络安全等级保护制度。网络运营者应当按照网络安全等级保护制度的要求，履行下列安全保护义务，保障网络免受干扰、破坏或者未经授权的访问，防止网络数据泄露或者被窃取、篡改： （一）制定内部安全管理制度和操作规程，确定网络安全负责人，落实网络安全保护责任； （二）采取防范计算机病毒和网络攻击、网络侵入等危害网络安全行为的技术措施； （三）采取监测、记录网络运行状态、网络安全事件的技术措施，并按照规定留存相关的网络日志不少于六个月； （四）采取数据分类、重要数据备份和加密等措施； （五）法律、行政法规规定的其他义务。 第二十二条 网络产品、服务应当符合相关国家标准的强制性要求。网络产品、服务的提供者不得设置恶意程序；发现其网络产品、服务存在安全缺陷、漏洞等风险时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。 网络产品、服务的提供者应当为其产品、服务持续提供安全维护；在规定或者当事人约定的期限内，不得终止提供安全维护。 网络产品、服务具有收集用户信息功能的，其提供者应当向用户明示并取得同意；涉及用户个人信息的，还应当遵守本法和有关法律、行政法规关于个人信息保护的规定。 第二十三条 网络关键设备和网络安全专用产品应当按照相关国家标准的强制性要求，由具备资格的机构安全认证合格或者安全检测符合要求后，方可销售或者提供。国家网信部门会同国务院有关部门制定、公布网络关键设备和网络安全专用产品目录，并推动安全认证和安全检测结果互认，避免重复认证、检测。 第二十四条 网络运营者为用户办理网络接入、域名注册服务，办理固定电话、移动电话等入网手续，或者为用户提供信息发布、即时通讯等服务，在与用户签订协议或者确认提供服务时，应当要求用户提供真实身份信息。用户不提供真实身份信息的，网络运营者不得为其提供相关服务。 国家实施网络可信身份战略，支持研究开发安全、方便的电子身份认证技术，推动不同电子身份认证之间的互认。 第二十五条 网络运营者应当制定网络安全事件应急预案，及时处置系统漏洞、计算机病毒、网络攻击、网络侵入等安全风险；在发生危害网络安全的事件时，立即启动应急预案，采取相应的补救措施，并按照规定向有关主管部门报告。 第二十六条 开展网络安全认证、检测、风险评估等活动，向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息，应当遵守国家有关规定。 第二十七条 任何个人和组织不得从事非法侵入他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动；不得提供专门用于从事侵入网络、干扰网络正常功能及防护措施、窃取网络数据等危害网络安全活动的程序、工具；明知他人从事危害网络安全的活动的，不得为其提供技术支持、广告推广、支付结算等帮助。 第二十八条 网络运营者应当为公安机关、国家安全机关依法维护国家安全和侦查犯罪的活动提供技术支持和协助。 第二十九条 国家支持网络运营者之间在网络安全信息收集、分析、通报和应急处置等方面进行合作，提高网络运营者的安全保障能力。 有关行业组织建立健全本行业的网络安全保护规范和协作机制，加强对网络安全风险的分析评估，定期向会员进行风险警示，支持、协助会员应对网络安全风险。 第三十条 网信部门和有关部门在履行网络安全保护职责中获取的信息，只能用于维护网络安全的需要，不得用于其他用途。 第二节 关键信息基础设施的运行安全 第三十一条 国家对公共通信和信息服务、能源、交通、水利、金融、公共服务、电子政务等重要行业和领域，以及其他一旦遭到破坏、丧失功能或者数据泄露，可能严重危害国家安全、国计民生、公共利益的关键信息基础设施，在网络安全等级保护制度的基础上，实行重点保护。关键信息基础设施的具体范围和安全保护办法由国务院制定。 国家鼓励关键信息基础设施以外的网络运营者自愿参与关键信息基础设施保护体系。 第三十二条 按照国务院规定的职责分工，负责关键信息基础设施安全保护工作的部门分别编制并组织实施本行业、本领域的关键信息基础设施安全规划，指导和监督关键信息基础设施运行安全保护工作。 第三十三条 建设关键信息基础设施应当确保其具有支持业务稳定、持续运行的性能，并保证安全技术措施同步规划、同步建设、同步使用。 第三十四条 除本法第二十一条的规定外，关键信息基础设施的运营者还应当履行下列安全保护义务： （一）设置专门安全管理机构和安全管理负责人，并对该负责人和关键岗位的人员进行安全背景审查； （二）定期对从业人员进行网络安全教育、技术培训和技能考核； （三）对重要系统和数据库进行容灾备份； （四）制定网络安全事件应急预案，并定期进行演练； （五）法律、行政法规规定的其他义务。 第三十五条 关键信息基础设施的运营者采购网络产品和服务，可能影响国家安全的，应当通过国家网信部门会同国务院有关部门组织的国家安全审查。 第三十六条 关键信息基础设施的运营者采购网络产品和服务，应当按照规定与提供者签订安全保密协议，明确安全和保密义务与责任。 第三十七条 关键信息基础设施的运营者在中华人民共和国境内运营中收集和产生的个人信息和重要数据应当在境内存储。因业务需要，确需向境外提供的，应当按照国家网信部门会同国务院有关部门制定的办法进行安全评估；法律、行政法规另有规定的，依照其规定。 第三十八条 关键信息基础设施的运营者应当自行或者委托网络安全服务机构对其网络的安全性和可能存在的风险每年至少进行一次检测评估，并将检测评估情况和改进措施报送相关负责关键信息基础设施安全保护工作的部门。 第三十九条 国家网信部门应当统筹协调有关部门对关键信息基础设施的安全保护采取下列措施： （一）对关键信息基础设施的安全风险进行抽查检测，提出改进措施，必要时可以委托网络安全服务机构对网络存在的安全风险进行检测评估； （二）定期组织关键信息基础设施的运营者进行网络安全应急演练，提高应对网络安全事件的水平和协同配合能力； （三）促进有关部门、关键信息基础设施的运营者以及有关研究机构、网络安全服务机构等之间的网络安全信息共享； （四）对网络安全事件的应急处置与网络功能的恢复等，提供技术支持和协助。 第四章 网络信息安全 第四十条 网络运营者应当对其收集的用户信息严格保密，并建立健全用户信息保护制度。 第四十一条 网络运营者收集、使用个人信息，应当遵循合法、正当、必要的原则，公开收集、使用规则，明示收集、使用信息的目的、方式和范围，并经被收集者同意。 网络运营者不得收集与其提供的服务无关的个人信息，不得违反法律、行政法规的规定和双方的约定收集、使用个人信息，并应当依照法律、行政法规的规定和与用户的约定，处理其保存的个人信息。 第四十二条 网络运营者不得泄露、篡改、毁损其收集的个人信息；未经被收集者同意，不得向他人提供个人信息。但是，经过处理无法识别特定个人且不能复原的除外。 网络运营者应当采取技术措施和其他必要措施，确保其收集的个人信息安全，防止信息泄露、毁损、丢失。在发生或者可能发生个人信息泄露、毁损、丢失的情况时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。 第四十三条 个人发现网络运营者违反法律、行政法规的规定或者双方的约定收集、使用其个人信息的，有权要求网络运营者删除其个人信息；发现网络运营者收集、存储的其个人信息有错误的，有权要求网络运营者予以更正。网络运营者应当采取措施予以删除或者更正。 第四十四条 任何个人和组织不得窃取或者以其他非法方式获取个人信息，不得非法出售或者非法向他人提供个人信息。 第四十五条 依法负有网络安全监督管理职责的部门及其工作人员，必须对在履行职责中知悉的个人信息、隐私和商业秘密严格保密，不得泄露、出售或者非法向他人提供。 第四十六条 任何个人和组织应当对其使用网络的行为负责，不得设立用于实施诈骗，传授犯罪方法，制作或者销售违禁物品、管制物品等违法犯罪活动的网站、通讯群组，不得利用网络发布涉及实施诈骗，制作或者销售违禁物品、管制物品以及其他违法犯罪活动的信息。 第四十七条 网络运营者应当加强对其用户发布的信息的管理，发现法律、行政法规禁止发布或者传输的信息的，应当立即停止传输该信息，采取消除等处置措施，防止信息扩散，保存有关记录，并向有关主管部门报告。 第四十八条 任何个人和组织发送的电子信息、提供的应用软件，不得设置恶意程序，不得含有法律、行政法规禁止发布或者传输的信息。 电子信息发送服务提供者和应用软件下载服务提供者，应当履行安全管理义务，知道其用户有前款规定行为的，应当停止提供服务，采取消除等处置措施，保存有关记录，并向有关主管部门报告。 第四十九条 网络运营者应当建立网络信息安全投诉、举报制度，公布投诉、举报方式等信息，及时受理并处理有关网络信息安全的投诉和举报。 网络运营者对网信部门和有关部门依法实施的监督检查，应当予以配合。 第五十条 国家网信部门和有关部门依法履行网络信息安全监督管理职责，发现法律、行政法规禁止发布或者传输的信息的，应当要求网络运营者停止传输，采取消除等处置措施，保存有关记录；对来源于中华人民共和国境外的上述信息，应当通知有关机构采取技术措施和其他必要措施阻断传播。 第五章 监测预警与应急处置 第五十一条 国家建立网络安全监测预警和信息通报制度。国家网信部门应当统筹协调有关部门加强网络安全信息收集、分析和通报工作，按照规定统一发布网络安全监测预警信息。 第五十二条 负责关键信息基础设施安全保护工作的部门，应当建立健全本行业、本领域的网络安全监测预警和信息通报制度，并按照规定报送网络安全监测预警信息。 第五十三条 国家网信部门协调有关部门建立健全网络安全风险评估和应急工作机制，制定网络安全事件应急预案，并定期组织演练。 负责关键信息基础设施安全保护工作的部门应当制定本行业、本领域的网络安全事件应急预案，并定期组织演练。 网络安全事件应急预案应当按照事件发生后的危害程度、影响范围等因素对网络安全事件进行分级，并规定相应的应急处置措施。 第五十四条 网络安全事件发生的风险增大时，省级以上人民政府有关部门应当按照规定的权限和程序，并根据网络安全风险的特点和可能造成的危害，采取下列措施： （一）要求有关部门、机构和人员及时收集、报告有关信息，加强对网络安全风险的监测； （二）组织有关部门、机构和专业人员，对网络安全风险信息进行分析评估，预测事件发生的可能性、影响范围和危害程度； （三）向社会发布网络安全风险预警，发布避免、减轻危害的措施。 第五十五条 发生网络安全事件，应当立即启动网络安全事件应急预案，对网络安全事件进行调查和评估，要求网络运营者采取技术措施和其他必要措施，消除安全隐患，防止危害扩大，并及时向社会发布与公众有关的警示信息。 第五十六条 省级以上人民政府有关部门在履行网络安全监督管理职责中，发现网络存在较大安全风险或者发生安全事件的，可以按照规定的权限和程序对该网络的运营者的法定代表人或者主要负责人进行约谈。网络运营者应当按照要求采取措施，进行整改，消除隐患。 第五十七条 因网络安全事件，发生突发事件或者生产安全事故的，应当依照《中华人民共和国突发事件应对法》、《中华人民共和国安全生产法》等有关法律、行政法规的规定处置。 第五十八条 因维护国家安全和社会公共秩序，处置重大突发社会安全事件的需要，经国务院决定或者批准，可以在特定区域对网络通信采取限制等临时措施。 第六章 法律责任 第五十九条 网络运营者不履行本法第二十一条、第二十五条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处一万元以上十万元以下罚款，对直接负责的主管人员处五千元以上五万元以下罚款。 关键信息基础设施的运营者不履行本法第三十三条、第三十四条、第三十六条、第三十八条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处十万元以上一百万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款。 第六十条 违反本法第二十二条第一款、第二款和第四十八条第一款规定，有下列行为之一的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处五万元以上五十万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款： （一）设置恶意程序的； （二）对其产品、服务存在的安全缺陷、漏洞等风险未立即采取补救措施，或者未按照规定及时告知用户并向有关主管部门报告的； （三）擅自终止为其产品、服务提供安全维护的。 第六十一条 网络运营者违反本法第二十四条第一款规定，未要求用户提供真实身份信息，或者对不提供真实身份信息的用户提供相关服务的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 第六十二条 违反本法第二十六条规定，开展网络安全认证、检测、风险评估等活动，或者向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息的，由有关主管部门责令改正，给予警告；拒不改正或者情节严重的，处一万元以上十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处五千元以上五万元以下罚款。 第六十三条 违反本法第二十七条规定，从事危害网络安全的活动，或者提供专门用于从事危害网络安全活动的程序、工具，或者为他人从事危害网络安全的活动提供技术支持、广告推广、支付结算等帮助，尚不构成犯罪的，由公安机关没收违法所得，处五日以下拘留，可以并处五万元以上五十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处十万元以上一百万元以下罚款。 单位有前款行为的，由公安机关没收违法所得，处十万元以上一百万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。 违反本法第二十七条规定，受到治安管理处罚的人员，五年内不得从事网络安全管理和网络运营关键岗位的工作；受到刑事处罚的人员，终身不得从事网络安全管理和网络运营关键岗位的工作。 第六十四条 网络运营者、网络产品或者服务的提供者违反本法第二十二条第三款、第四十一条至第四十三条规定，侵害个人信息依法得到保护的权利的，由有关主管部门责令改正，可以根据情节单处或者并处警告、没收违法所得、处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款；情节严重的，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照。 违反本法第四十四条规定，窃取或者以其他非法方式获取、非法出售或者非法向他人提供个人信息，尚不构成犯罪的，由公安机关没收违法所得，并处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款。 第六十五条 关键信息基础设施的运营者违反本法第三十五条规定，使用未经安全审查或者安全审查未通过的网络产品或者服务的，由有关主管部门责令停止使用，处采购金额一倍以上十倍以下罚款；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 第六十六条 关键信息基础设施的运营者违反本法第三十七条规定，在境外存储网络数据，或者向境外提供网络数据的，由有关主管部门责令改正，给予警告，没收违法所得，处五万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 第六十七条 违反本法第四十六条规定，设立用于实施违法犯罪活动的网站、通讯群组，或者利用网络发布涉及实施违法犯罪活动的信息，尚不构成犯罪的，由公安机关处五日以下拘留，可以并处一万元以上十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处五万元以上五十万元以下罚款。关闭用于实施违法犯罪活动的网站、通讯群组。 单位有欠款行为的，由公安机关处十万元以上五十万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。 第六十八条 网络运营者违反本法第四十七条规定，对法律、行政法规禁止发布或者传输的信息未停止传输、采取消除等处置措施、保存有关记录的，由有关主管部门责令改正，给予警告，没收违法所得；拒不改正或者情节严重的，处十万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 电子信息发送服务提供者、应用软件下载服务提供者，不履行本法第四十八条第二款规定的安全管理义务的，依照前款规定处罚。 第六十九条 网络运营者违反本法规定，有下列行为之一的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，对直接负责的主管人员和其他直接责任人员，处一万元以上十万元以下罚款： （一）不按照有关部门的要求对法律、行政法规禁止发布或者传输的信息，采取停止传输、消除等处置措施的； （二）拒绝、阻碍有关部门依法实施的监督检查的； （三）拒不向公安机关、国家安全机关提供技术支持和协助的。 第七十条 发布或者传输本法第十二条第二款和其他法律、行政法规禁止发布或者传输的信息的，依照有关法律、行政法规的规定处罚。 第七十一条 有本法规定的违法行为的，依照有关法律、行政法规的规定记入信用档案，并予以公示。 第七十二条 国家机关政务网络的运营者不履行本法规定的网络安全保护义务的，由其上级机关或者有关机关责令改正；对直接负责的主管人员和其他直接责任人员依法给予处分。 第七十三条 网信部门和有关部门违反本法第三十条规定，将在履行网络安全保护职责中获取的信息用于其他用途的，对直接负责的主管人员和其他直接责任人员依法给予处分。 网信部门和有关部门的工作人员玩忽职守、滥用职权、徇私舞弊，尚不构成犯罪的，依法给予处分。 第七十四条 违反本法规定，给他人造成损害的，依法承担民事责任。 违反本法规定，构成违反治安管理行为的，依法给予治安管理处罚；构成犯罪的，依法追究刑事责任。 第七十五条 境外的机构、组织、个人从事攻击、侵入、干扰、破坏等危害中华人民共和国的关键信息基础设施的活动，造成严重后果的，依法追究法律责任；国务院公安部门和有关部门并可以决定对该机构、组织、个人采取冻结财产或者其他必要的制裁措施。 第七章附 则 第七十六条 本法下列用语的含义： （一）网络，是指由计算机或者其他信息终端及相关设备组成的按照一定的规则和程序对信息进行收集、存储、传输、交换、处理的系统。 （二）网络安全，是指通过采取必要措施，防范对网络的攻击、侵入、干扰、破坏和非法使用以及意外事故，使网络处于稳定可靠运行的状态，以及保障网络数据的完整性、保密性、可用性的能力。 （三）网络运营者，是指网络的所有者、管理者和网络服务提供者。 （四）网络数据，是指通过网络收集、存储、传输、处理和产生的各种电子数据。 （五）个人信息，是指以电子或者其他方式记录的能够单独或者与其他信息结合识别自然人个人身份的各种信息，包括但不限于自然人的姓名、出生日期、身份证件号码、个人生物识别信息、住址、电话号码等。 第七十七条 存储、处理涉及国家秘密信息的网络的运行安全保护，除应当遵守本法外，还应当遵守保密法律、行政法规的规定。 第七十八条 军事网络的安全保护，由中央军事委员会另行规定。 第七十九条 本法自2017年6月1日起施行。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>法律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我就是想试试这个竞赛的名字究竟能打多长多长多长-nuaactf-WriteUp]]></title>
    <url>%2F2017%2F10%2F22%2F%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E8%AF%95%E8%AF%95%E8%BF%99%E4%B8%AA%E7%AB%9E%E8%B5%9B%E7%9A%84%E5%90%8D%E5%AD%97%E7%A9%B6%E7%AB%9F%E8%83%BD%E6%89%93%E5%A4%9A%E9%95%BF%E5%A4%9A%E9%95%BF%E5%A4%9A%E9%95%BF-nuaactf-WriteUp%2F</url>
    <content type="text"><![CDATA[​ 这次准备还算充足，然而题目的难度有点点超乎我们的预料，所以并不是很顺利，但最终凭借着两位队友的carry，最后成绩也还可以。（话说我当初干嘛要提这样一个鬼名字，而且他们两居然还采用了。。。title即队名）以下是wp NUAACTF2017 WriteUp 队名： 我就是想试试这个竞赛的名字究竟能打多长多长多长 队员：秦瑞哲、刘琨奇、程斌 MISC1 ++–看到问题立马想到了BrainFuck，然而打开一看却是各种颜文字… 参考文章: https://qing.su/article/119.html， 注意到BrainFuck的结构，观察前部结构： ‘( ͡° ͜ʖ ͡°)‘由’+‘替代; ‘( ͡°(‘由’[‘替代，对应地，’) ͡°)‘由’]‘替代; ‘ᕦ( ͡°ヮ ͡°)ᕥ‘由’&gt;‘替代。 之后观察后面的结构： ‘(&gt; ͜ʖ(∩ ͡° ͜ʖ ͡°)⊃━☆ﾟ.*)‘由’.‘替代; ‘(♥ ͜ʖ♥)‘由’-‘替代; ‘(∩ ͡° ͜ʖ ͡°)⊃━☆ﾟ.*‘由’&lt;‘替代。 至此，我们可以得到正确的BrainFuck表达式 123456789101112131415161718192021222324++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;++++++++++.+++++++.--------------------..++.+++++++++++++++++.--------------.+++++++++++++++++++++.-------------------------.++++++++++++++++.&lt;------------------.---.&gt;----.--------.+++++++++++++++.------------------.++++++++.------------.+++++++++++++++++.&lt;.&gt;+++++.--.++++++++++. 在网站: https://sange.fi/esoteric/brainfuck/impl/interp/i.html 上解密，得到flag MISC3 recover（吐槽一下，在chrome输flag，没有选中的话是看不见的。。。） 下载后发现是个png图片，但打不开 第一反应是去改文件头，还是选择先strings一下 然后就有了点惊喜 瞄了一眼已解决列表，卧槽，已经7个队伍了，论抢一血的重要性哇 话说300分是不是多了点。。。。。。 web50右键源码，佛祖保佑你不出bug。 web150 题目循环检测alert并删除，试了各种编码无效，去做web300的时候才想到jsfuck，可以绕过检测并且由js执行。 当然要先闭合前边的引号，后边可以闭合或直接注释掉。 web300按照题目意思，只能使用 []!+ 四个字符进行构造，eval(input)可以对input进行js解析，综合题意，只要可以eval(input)构造出’alert’字符串即可。 一开始当然直接jsfuck，然后由于()被过滤掉了就fail。然后各种困惑，各种google之后，get到jsfuck的编码方式，就解开了本题。记录如下： 12345678910111213141516171819202122232425262728以下内容基于[] =&gt; []然后!可以将类型转化为布尔型![] =&gt; false!![] =&gt; true+可以将类型转化为整形+![] =&gt; 0+!![] =&gt; 1!![]+!![] =&gt; 2 然后+[]可以转化为字符串![]+[] =&gt; &apos;false&apos;类似于数组取下标(![]+[])[+!![]] =&gt; &apos;a&apos;然后就可以类似的从&apos;false&apos;, &apos;true&apos;中读出&apos;a&apos;,&apos;l&apos;,&apos;e&apos;,&apos;r&apos;,&apos;t&apos;。em...但是...题目过滤了小括号。需要绕一下![]+[] =&gt; &apos;false&apos;[![]+[]] =&gt; [&apos;false&apos;][![]+[]][+[]] =&gt; &apos;false&apos;[![]+[]][+[]][+!![]] =&gt; &apos;a&apos;最后用加号拼起来即可。这题最后一半靠蒙，\笑哭\笑哭 截图如下：]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>nuaa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四届世安杯酱油记]]></title>
    <url>%2F2017%2F10%2F08%2F%E7%AC%AC%E5%9B%9B%E5%B1%8A%E4%B8%96%E5%AE%89%E6%9D%AF%E9%85%B1%E6%B2%B9%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[​ 给21号的校赛练练手。 @kurum 主攻web，@a-lie-Z 主要负责misc和steganography，我试了下有思路的题，下面是我找到的flag（emmm，为什么不说是我做出来的题呢？）@a-lie-Z 做的题：传送门 ，以及 @kurum 做的题：传送门 ctf入门级题目​ 戳进去看发现有源码，放一下php代码： 12345678if (isset ($_GET['password'])) &#123; if (ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE) echo '&lt;p class="alert"&gt;You password must be alphanumeric&lt;/p&gt;'; else if (strpos ($_GET['password'], '--') !== FALSE) die($flag); else echo '&lt;p class="alert"&gt;Invalid password&lt;/p&gt;';&#125; ​ 第一个if要求password 必须为数字和字母，第二个if要求子串中得有”–”，看上去有点矛盾，而输入数组会使ereg函数发生错误，返回false，因此可以通过第一个if，而字符数组同样会使得strpos函数出错返回Null，与严格的FALSE不符，这样就能通过第二个if判断。于是构造url 为 http://ctf1.shiyanbar.com/shian-rao/password[]=xxx 这样就能绕过了。 曲奇饼​ 嗯，名字貌似提示需要构造cookie。打开题目链接后发现url有点奇怪：http://ctf1.shiyanbar.com/shian-quqi/index.php?line=&amp;file=a2V5LnR4dA== 后面那个 file=a2V5LnR4dA== 有点像base64，解密一下后发现是key.txt，然而这里并没有什么，改了line参数也没什么鸟用。于是考虑获取真正index.php，去掉后面的参数后发现依旧会重定向到这里，然后考虑加参数，受key.txt的提示，我把index.php用base64加密后传了上去 http://ctf1.shiyanbar.com/shian-quqi/index.php?line=&amp;file=aW5kZXgucGhw 发现什么都没有，试着把line改成1，输出了 error_reporting(0); 改成2试试 $file=base64_decode(isset($_GET[&#39;file&#39;])?$_GET[&#39;file&#39;]:&quot;&quot;); 嗯，啥也别说了，写python，获取完整的php代码，如下： 1234567891011121314151617error_reporting(0);$file=base64_decode(isset($_GET['file'])?$_GET['file']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;file=a2V5LnR4dA==");$file_list = array('0' =&gt;'key.txt','1' =&gt;'index.php',);if(isset($_COOKIE['key']) &amp;&amp; $_COOKIE['key']=='li_lr_480')&#123;$file_list[2]='thisis_flag.php';&#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125; ​ 嗯，果然和名称暗示的一样，构造cookie，传入&#39;key&#39;=&#39;li_lr_480&#39;，再把$file改成thisis_flag.php的base64形式即可。python代码如下： 1234567import requests cookie = &#123;'key':'li_lr_480'&#125;for i in range(50): url="http://ctf1.shiyanbar.com/shian-quqi/index.php?line="+str(i)+"&amp;file=dGhpc2lzX2ZsYWcucGhw" ans = requests.get(url, cookies=cookie) print ans.text 拿到flag。 console​ 用PEiD打开后发现是.net框架，用ILSpy，打开，把重要文件的代码整合，核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556internal class MM&#123; private static int C(int A_0, int A_1) &#123; return (new int[] &#123; 2, 3, 5, 7, 11, 13, 0x11, 0x13, 0x17, 0x1d, 0x1f, 0x25, 0x29, 0x2b, 0x2f, 0x35,0x3b, 0x3d, 0x43, 0x47, 0x49, 0x4f, 0x53, 0x59, 0x61, 0x65, 0x67, 0x6b, 0x6d, 0x71 &#125;)[A_1] ^ A_0; &#125; private static string flag(string A_0) &#123; byte[] bytes = Encoding.ASCII.GetBytes(A_0); return &quot;flag&#123;&quot; + BitConverter.ToString(new MD5CryptoServiceProvider().ComputeHash(bytes)).Replace(&quot;-&quot;, &quot;&quot;) + &quot;&#125;&quot;; &#125; private static void count(string A_0, int A_1, ref string A_2) &#123; int num = 0; if (0 &lt; A_0.Length) &#123; do &#123; char c = A_0[num]; int num2 = 1; do &#123; c = Convert.ToChar(MM.C(Convert.ToInt32(c), num2)); num2++; &#125; while (num2 &lt; 15); A_2 += c; num++; &#125; while (num &lt; A_0.Length); &#125; A_2 = MM.flag(A_2); &#125; private static void main(string[] A_0) &#123; string b = null; string value = string.Format(&quot;&#123;0&#125;&quot;, DateTime.Now.Hour + 1); string a_ = &quot;CreateByTenshine&quot;; MM.count(a_, Convert.ToInt32(value), ref b); string a = Console.ReadLine(); if (a == b) &#123; Console.WriteLine(&quot;u got it!&quot;); Console.ReadKey(true); &#125; else &#123; Console.Write(&quot;wrong&quot;); &#125; Console.ReadKey(true); &#125;&#125; c#脚本 123456789101112131415161718using System;using System.Security.Cryptography;using System.Text; namespace ConsoleApplication1&#123; class Program &#123; static void Main(string[] args) &#123; string a = &quot;[j&#125;yl&#125;ZaL&#125;vkpqv&#125;&quot;; byte[] bytes = Encoding.ASCII.GetBytes(a); string b = &quot;flag&#123;&quot; + BitConverter.ToString(new MD5CryptoServiceProvider().ComputeHash(bytes)).Replace(&quot;-&quot;, &quot;&quot;) + &quot;&#125;&quot;; Console.WriteLine(b); Console.ReadLine(); &#125; &#125;&#125; ​ 本机没配c#环境，随便找个在线网站跑就OK。 low​ 打开后发现是一张图片，看通道没什么反应，分析也没什么头绪。但从名字来看，可能是要把低位的0都获取出来，然后拼图，用python跑一下试试（matlab本机没有环境，线上貌似没法上传图片）。 123456789101112131415161718192021import Imagedef foo(): im=Iamge.open('low.bmp') im2=im.copy() pix=im2.load() width,height=im2.size for x in xrange(0,width): for y in xrange(0,height): #LSB if pix[x,y]&amp;0x1==0: pix[x,y]=0 #黑 else: pix[x,y]=255 im2.show() passif __name__ == '__main__': foo() 貌似成功了，可以得到一张图片，左上角有一个二维码，反色扫一下即可。 珍妮的QQ号​ 下载是个压缩包，解压后就是一个txt文件，里面的内容： 1珍妮换了一个新的QQ号码，原来的号码和新的号码都是5位靓号哦；其次，新的号码是原来号码的4倍，并且原来的号码倒着写正好是新的号码，请问，新号码是多少，新号码即为key。 很简单的编程题，直接上c代码。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main ()&#123; int n; for(n = 10001;n &lt;= 25000;n++) &#123; if((n * 4) == MyFunction(n)) printf(" %d ",n * 4); &#125; return 0;&#125;int MyFunction(int number) &#123; int k, fig=0, i, j, num, sum=0; k=number; while(k!=0) &#123; ++fig; //fig用来保存输入的数的位数 k /= 10; &#125; for(i=0; i&lt;fig; i++) &#123; num = number % 10; //求余数 for(j=0; j&lt;fig-i-1; j++) num = num*10; //余数乘上所对应的的10的次方 sum = sum + num; number /= 10; &#125; return sum;&#125; 跑出来结果是87912. RSA​ 打开是一个message.txt文件，里面写着： 12c = 2044619806634581710230401748541393297937319n = 92164540447138944597127069158431585971338721360079328713704210939368383094265948407248342716209676429509660101179587761913570951794712775006017595393099131542462929920832865544705879355440749903797967940767833598657143883346150948256232023103001435628434505839331854097791025034667912357133996133877280328143 RSA的具体原理还不是很懂，大概说的就是公钥私钥什么的，把c复制到google然后。。。就搜出了flag。。。（→_→这线上赛的题也是够了，然后发现，其他有些题也能搜出来，无语了。。。） 贴一下大佬的话： Nietypowa rzecz jest taka, ze wykładnik szyfrujący nie jest podany i c jest bardzo małe w porównaniu do n. To sugeruje że może e było tak małe że m^e nie przekroczyło n, albo tylko nieznacznie. Żeby to sprawdzić postanowiliśmy policzyć k-te pierwiastki całkowite dla c w poszukiwaniu e: 以及求解代码： 1234567891011121314import gmpy2from src.crypto_commons.generic import long_to_bytesdef main(): c = 2044619806634581710230401748541393297937319 n = 92164540447138944597127069158431585971338721360079328713704210939368383094265948407248342716209676429509660101179587761913570951794712775006017595393099131542462929920832865544705879355440749903797967940767833598657143883346150948256232023103001435628434505839331854097791025034667912357133996133877280328143 for i in range(2, 10): root = gmpy2.iroot(c, i)[0] if root**i == c: print(i, long_to_bytes(root))main() 然后flag为so_low ，呃，RSA很low吗？ 喵喵喵？ （比赛虽然有点水，但自己更水，ctf还是适合作为普及知识面的竞赛）]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客加https && google收录]]></title>
    <url>%2F2017%2F10%2F03%2Fhexo%E5%8D%9A%E5%AE%A2%E5%8A%A0https%20%26%26%20google%E6%94%B6%E5%BD%95%2F</url>
    <content type="text"><![CDATA[​ 讲讲上https和让谷歌收录个人博客的过程。 前言​ 戳友链的时候发现好多博客都上了全站https，而且https已经是大势所趋，特别是谷歌，对https的网站收录极其友好(至于百度，emmmmm，我已经放弃它了)，而谷歌搜索是当今最好用的引擎，可惜在中国大陆无法正常访问，需要科学上网，方法很多，免费的不太稳有限制而且需要多折腾，花钱的省事而且稳定，在这我安利一下 ACGPOWER，十分好用，而且只要6块一个月。(PS：自从用过了这个，我的地址栏默认搜索引擎换成了Google。。。妈妈再也不用担心我科学上网不稳了)。好了废话就说到这，下面是正文。 https​ 关于https，全称为：Hypertext Transfer Protocol Secure，比http多了个S，顾名思义，多了一层保护，即TLS/SSL协议，早些年，SSL证书基本上是要花大价钱买的，很难看到免费的，而现在随着https越来越普及，免费的SSL证书也很多，可以自行选择适合自己的SSL证书。全站的https网站会将要传递的信息进行加密后传输，可以避免信息窃听、信息篡改、信息劫持等问题。具体原理可以参考这里。 Cloudflare介绍与https正式部署​ Cloudflare 是一家可以给全球用户提供网站访问加速、DNS解析、阻止网站攻击等众多服务的公司，具体介绍自行去官网。那么我要的就是Cloudflare的SSL服务了，方法很简单。大概就是一下几个步骤：(讲真Cloudflare给的引导过程挺清楚的) 1、去Cloudflare注册，添加自己的个人网站，扫描过程大概1分钟。 2、验证域名所有权后，等待status变成active状态。 3、拿到Cloudflare的Domin Name Server后，去域名提供商那修改自己域名的Domin Name Sever。(去那个域名列表那戳管理就行) 4、改完DNS后点击Crypto，在SSL那选择Flexible，如果自己有证书的话可以选择Full(用github pages的貌似无法再部署SSL)，大概区别如下： 具体的区别自己戳旁边的链接，都有很详细的介绍，非常良心的一家网站诶。其他的话，开启强制HTTPS以及Automatic HTTPS Rewrites(如果资源路径支持https，那么会自行跳转成https)这两个就可以。 ​ 以上步骤全部完成后，如果你没有引用http的资源(即混合引用)，是可以看到小绿锁的。 PS:为此，我把图床从七牛搬到了新浪博客。。。。 PPS：新浪博客的图床真的挺好用的。 Google收录1、首先在根目录下键入以下命令安装sitemap插件 npm install hexo-generator-sitemap --save 2、然后在站点文件(不是主题文件哦)增加以下内容(注意缩进) 123# 自动生成sitemapsitemap: path: sitemap.xml hexo g以下就能在public里面看到sitemap.xml了。 3、在source下增加robots.txt 123456789101112131415# hexo robots.txtUser-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://primykq.top/sitemap.xml 把网址改成自己的。 4、进入Google Search Console，没有谷歌账号的注册一个。添加网站，把自己的个人网站输进去，这里要验证域名所有权。我选择了文件验证，把下的文件放在站点的source目录下，注意：不要编译 不要编译 不要编译 直接hexo d 把这份文件上传到服务器中，编译的话hexo会自动给你加上一大串html代码。 5、验证完了以后测试一下robots.txt协议。 6、提交sitemap，输入sitemap.xml就行。 7、抓取那一栏可以加上标签栏或者你觉得最容易被搜到的page，不加的话默认抓取首页，填完url后点击抓取，然后就点击“提交至索引”。注意了，这里可能要进行人机验证，我不得不吐槽一下这google的人机验证，比12306的还要骚，一堆图片，让你选有汽车呀路标呀什么的图片，然后，你点中以后，这个图会消失，然后出新的图，如果又有汽车或者路标等目标图片，你需要继续点，一直点到没有指定的图片为止，如果你提交验证后失败，请直接ctrl + r刷新后重来，我感觉后面是个无底洞，反正我在后面没成功过，你感兴趣的话可以试试。上两张图好了。 提交完索引后就大功告成了。大概过了那么一两分钟，我去google搜索那输入了primykq的博客，妈耶，马上就出来了，这收录速度真牛。 多说一句​ 有人可能会说，咋没有提交到百度的教程，emmmm，百度，我卡死在域名所有权验证那里，怎么都过不去，后来想想，还得双线部署到coding(因为github 禁了百度的爬虫)，暂时懒得折腾了，用了独立域名后访问速度也还过得去，大不了再压缩一下资源文件。(后来才知道，github下的二级域名可以直接强制https，可惜我还是喜欢个人的顶级域名。)]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>https</tag>
        <tag>Cloudflare</tag>
        <tag>google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF传送门]]></title>
    <url>%2F2017%2F09%2F29%2FCTF%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[​ 看到不错的分享，直接码在自己博客上比较方便(其实是chrome不想加那么多的书签QAQ，CTF方面的学习资料会继续在这补)。不过有的貌似挂了，比如我挺喜欢的IDF实验室 http://edu.gooann.com/ 谷安网校http://www.jikexueyuan.com/ 极客学院http://www.hetianlab.com/ 合天http://www.moonsos.com/ 米安网http://www.ichunqiu.com/ i 春秋http://www.honyaedu.com/ -红亚http://www.baimaoxueyuan.com/ 白帽学院http://www.simplexue.com/ctf/index 西普学院http://www.imooc.com/course/list 慕课http://www.secbox.cn/ 安全盒子http://www.freebuf.com/ freebufhttp://bobao.360.cn/ 360安全播报http://www.wooyun.org/ 乌云http://drops.wooyun.org/ 乌云知识库http://wiki.wooyun.org/ WooYun WiKihttps://www.91ri.org/ 91rihttps://www.t00ls[.NET](http://lib.csdn.net/base/dotnet)/toolshttp://www.ijiandao.com/ 爱尖刀http://www.secwk.com/article/index.html 威客众测http://bluereader.org/ 深蓝阅读http://www.shentou.org/ 黑客安全军火库http://netsecurity.51cto.com/ 51ctohttp://security.csdn.net/ csdnhttp://www.80sec.com/ 80sec teamhttps://security.alibaba.com/blog.htm?spm=0.0.0.0.knOqaI 阿里巴巴安全响应中心http://security.tencent.com/index.[PHP](http://lib.csdn.net/base/php)/blog 腾讯安全应急响应中心 博客http://security.360.cn/blog 360安全应急响应中心 博客http://sec.baidu.com/index.php?research/list 百度安全应急响应中心 博客 博客推荐http://security.tencent.com/index.php/bloghttp://217.logdown.com/ 217http://www.blue-lotus.net blue-lotus 蓝莲花http://blog.0ops.net/ 0opshttp://le4f.net/ e4fhttp://www.programlife.net/ 代码疯子http://www.hackdog.me/ redrain’bloghttp://www.syjzwjj.com/ 俊杰http://syclover.sinaapp.com/ 三叶草安全小组http://appleu0.sinaapp.com/ appleU0大大http://bl4ck.in/ tomato表哥http://www.sco4x0.com/ 4叔叔http://laterain.sinaapp.com/ 白神http://0nly3nd.sinaapp.com/ 0nly3ndhttp://hijacks.in/ LateRain’bloghttp://www.waitalone.cn/ 独自等待http://evilcos.me/ 余弦http://www.moonsec.com/ 暗月http://www.cnblogs.com/xuanhun/ 玄魂https://www.leavesongs.com/ 离别歌http://huaidan.org/ 鬼仔http://www.03sec.com/ sky的自留地http://joychou.org/ jc老师http://www.unhonker.com/ 90’s bloghttp://www1.taosay.net/ 道哥的黑板报http://blog.knownsec.com/ 知道创于http://www.sadk.org/ 焠安http://www.cnseay.com/ seay’bloghttp://blog.aptsec.net/ AptSec Teamhttp://lcx.cc/ 网络安全研究中心http://www.kali.org.cn/ kali中文网http://xiao106347.blog.163.com/ xiao106347 kali折腾更多大家推荐 渗透:http://www.wooyun.org/ 乌云http://bbs.blackbap.org/ 习科http://www.1937cn.net/ 1937http://forum.cnsec.org/ 暗组http://www.k33nteam.org/ keen teamhttp://forum.eviloctal.com/ 邪恶八进制http://www.evil0x.com/ 邪恶十六进制http://www.myhack58.com/ 黑吧安全吧http://www.cnhonkerarmy.com/ 中国红客 红盟http://www.chinahacker.com/ 中国黑客联盟http://www.hxhack.com/ 华夏黑客联盟http://www.heikexiehui.com/ 中国黑客协会官网http://www.hackbase.com/ 黑基http://www.2cto.com/ 红黑联盟http://bbs.2cto.com/ 红黑联盟论坛http://www.hackwd.com/http://www.heishou.com.cn/ 黑手安全网https://www.sitedirsec.com/ 非安全中国网http://www.zatokasztuki.com/ 学生技术联盟 逆向http://www.52pojie.cn/ 吾爱破解http://bbs.pediy.com/ 看雪论坛一蓑烟雨貌似被关了，逆向方面了解不多，问问表哥们吧( ?? ω ?? )y 编程http://www.he11oworld.com/ hello wordhttp://www.w3school.com.cn/ w3schoolhttp://www.runoob.com/ 菜鸟http://www.51zxw.net/https://github.com/http://navisec-[Git](http://lib.csdn.net/base/git).qiniudn.com/http://c.biancheng.net/cpp/http://www.liaoxuefeng.com/http://www.php100.com/https://ruby-china.org/wikihttp://bbs.csdn.net/forums/[Java](http://lib.csdn.net/base/javaee)/http://outofmemory.cn/tutorial/ 书籍http://zhuanlan.zhihu.com/Evi1m0/19706178 Evi1m0: 书籍推荐http://www.douban.com/doulist/3339701/ 信息安全必读书单http://www.douban.com/doulist/1363865/ 信息安全经典书籍http://www.zhihu.com/question/21390646http://my.oschina.net/bluefly/blog/335409?utm_source=tuicool&amp;utm_medium=referral Web安全核心书单连载《安全参考》http://www.douban.com/group/topic/72383272/ (2013年第一期–2015年第一期)全集《书安》(更新中)http://www.secbox.cn/hacker/8205.html 书安SecBook 第一期《icloud iOS安全大揭秘》http://www.secbox.cn/hacker/7366.html 书安SecBook 第二期《信息安全攻防赛》渗透实战文章可以看看里的杨凡(http://blog.sina.com.cn/s/articlelist_1758675673_4_1.html)和法克文章（http://pan.baidu.com/share/link?shareid=249629&amp;uk=2198816663） 工具(黑软有分风险，最好在虚拟机里搞)ftp://222.18.158.199/(校园网内网可以访问，不仅仅只有工具哦，有许多总结，各方面的)http://forum.cnsec.org/thread-94330-1-1.html 2015暗组工具包（渗透）http://bbs.secbox.cn/thread-196-1-1.html 2015_安全盒子工具包http://www.secbox.cn/hacker/tools/3552.html 法客论坛2015工具包-第三版http://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=388015 吾爱破解工具包 2015/7/22（逆向）http://down.52pojie.cn/ 爱盘 – 在线破解工具包，教程，http://www.52pojie.cn/thread-341238-1-1.html 吾爱破解论坛专用破解虚拟机ctf常用工具包请看http://tieba.baidu.com/p/3933947157里面群文件 其他http://www.zhihu.com/topic/19558642 黑客知乎话题http://www.zhihu.com/topic/20011446 ctf知乎话题http://www.zhihu.com/topic/19561983 信息安全知乎话题http://zhuanlan.zhihu.com/evilcos/19961466 余弦知乎专栏 CTF方面http://blog.idf.cn/2015/02/ctf-field-guide/http://tieba.baidu.com/p/3933947157 ctf大全https://ctftime.org/event/list/upcoming 各种CTF赛事预告(ps:国内各个高校或企业举办的比赛请进http://tieba.baidu.com/p/3933947157里面的群) 平时ctf练习 ctf逆向:http://reversing.kr/http://pwnable.kr/http://exploit-exercises.com/http://overthewire.orghttp://security.cs.rpi.edu/courses/binexp-spring2015/ bin 干货区http://www.52pojie.cn/forum-67-1.html 『2014CrackMe大赛』 SQL:https://github.com/Audi-1/sqli-labshttp://redtiger.labs.overthewire.org/ ctf XSS:http://prompt.ml/http://xss.pkav.net/xss/http://www.doscn.org/xss/http://xss-quiz.int21h.jp/http://escape.alf.nu/ ctf综合练习： http://hackinglab.cn/ 网络信息安全攻防学习平台http://captf.com/ ctf题目http://cafebabe.cc/nazo/ 脑洞开发，与ctf只有那么一点关系，有85关了( ?? ω ?? )yhttp://1111.segmentfault.com/ 光棍节程序员闯关秀http://www.helloisa.com/test/http://www.fj543.com/hack/ 黑客丛林之旅http://monyer.com/game/game1// 梦之光芒的小游戏http://oj.xctf.org.cn/ XCTF_OJ练习平台http://hackgame.blackbap.org/ 习科黑客游戏http://ctf.3sec.cn/ Jlu.CTFhttp://www.baimaoxueyuan.com/ctf 白帽学院ctf挑战赛http://www.ichunqiu.com/tiaozhans i春秋ctf挑战http://ctf.idf.cn/ idf 实验室http://ctf.moonsos.com/pentest/index.php 米安网ctfhttp://www.hetianlab.com/CTFrace.html 合天ctfhttp://www.shiyanbar.com/ctf/index 实验吧(前名西普学院）http://hkyx.myhack58.com/ 黑吧安全网-红客闯关游戏http://202.108.211.5/ 实训竞赛系统 国外比较好的几个综合练习平台http://www.wechall.nethttp://insight-labs.org/http://wargame.kr/http://canyouhack.it/http://hackit.sinaapp.com/http://webhacking.kr/http://fun.coolshell.cn/http://ringzer0team.com/challengehttps://backdoor.sdslabs.co/http://smashthestack.org/ 漏洞利用练习网站 ctf writeup(WP):直接百度:writeup(一边看一边总结，有道笔记，印象笔记什么的，最好能复现)另外乌云和360安全播报上有些WPhttp://drops.wooyun.org/?s=writeup&amp;submit=%E6%90%9C%E7%B4%A2http://bobao.360.cn/ctf/https://github.com/ctfs/ 各种 writeuphttp://sec.yka.me/ CTF Writeup Summaryhttps://ctf-team.vulnhub.com/ Write Ups ​ 原地址： 链接1 A方向： RE for BeginnersIDA Pro权威指南揭秘家庭路由器0day漏洞挖掘技术自己定操作系统黑客攻防技术宝典：系统实战篇 有各种系统的逆向讲解 B方向： Web应用安全权威指南 最推荐小白，宏观web安全Web前端黑客技术揭秘黑客秘籍——渗透测试实用指南黑客攻防技术宝典 web实战篇 web安全的所有核心基础点，有挑战性，最常规，最全，学好会直线上升代码审计：企业级web代码安全架构 入门—-从基础题目出发（推荐资源）： http://ctf.idf.cn !!!首推 idf实验室：题目非常基础，只1个点www.ichunqiu.com 有线下决赛题目复现http://oj.xctf.org.cn/xctf 题库网站，历年题，练习场，比较难www.wechall.net/challs !!!!!!非常入门的国外ctf题库，很多国内都是从这里刷题成长起来的http://canyouhack.it/ 国外，入门，有移动安全https://microcorruption.com/login A方向 密码，逆向酷炫游戏代http：//smashthestack.org A方向，简洁，国外，wargames，过关http://overthewire.ofg/wargames/ ！！！！推荐A方向 国内资料多，老牌wargamehttps：//exploit-exercises.com A方向 老牌wargame，国内资料多http://pawnable.kr/play.php pwn类游乐场，不到100题http://ctf.moonsoscom/pentest/index.php B方向 米安的Web漏洞靶场，基础，核心知识点http：//prompt.ml/0 B方向 国外的xss测试http://redtiger.labs.overthewire.org/ B方向 国外sql注入挑战网站，10关，过关的形式 不同的注入，循序渐近地练习 工具：https://github.com/truongkma/ctf-toolshttps://github.com/Plkachu/v0lthttps://github.com/zardus/ctf-toolshttps://github.com/TUCTF/Tools 这是原链接 ：链接2。 ​]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT创新区招新酱油记]]></title>
    <url>%2F2017%2F09%2F26%2FIT%E5%88%9B%E6%96%B0%E5%8C%BA%E6%8B%9B%E6%96%B0%E9%85%B1%E6%B2%B9%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[​ 一直觉得自己很菜，但具体程度不知道，直到…….南航IT创新区招新，本着为以后的技术面积累经验的目的，就去报名参加了。 虽然通知上说IT创新区的合作组织比如纸飞机技术部、微软技术部、科协宣企等技术部门可以不参加面试，后期考核一下合格后直接转入，但别人认可的是技术部的水平，感觉自己离那个水平有点远，所以还是老老实实去走流程。 ​ 先笔试，前面有数据结构与算法、Web大前端、网络后端、逻辑思维能力这几个板块，有多项选择题，填空题。然后后面就是这几个板块的面试题，自行准备有把握或者有思路的题，做完前面会做的就可以去排队面试了。有印象的题不多，因为大部分完全不会，稍微整理一下还有点印象的题。 逻辑思维题​ 填空题里有好几个印象挺深的题，先来看第一个吧。 火车运煤问题​ 题目是这样的： 你是山西的一个煤老板，你在矿区开采了有3000吨煤需要运送到市场上去卖，从你的矿区到市场有1000公里，你手里有一列烧煤的火车，这个火车最多只能装1000吨煤，且其能耗比较大——每一公里需要耗一吨煤。请问最后能运到集市上卖多少吨煤？ ​ 当时脑子里一片混乱，被前端的知识点和数据结构的东西弄的有点晕，心里想着反正答案不是零，但要分段运的话。。。在草稿本上画了画图，算来算去有点不清晰，懒得算了。后来去网上搜索了一下，才发现这是有名的”火车运煤问题“，(此处更新一条消息。我正写到这里，IT创新区发来了机考的通知。。。呃，一面要求这么低的吗。。。。还以为被刷定了)看了看别人的解法，再想了会，其实也不是很难，但要在短时间内做很多这样的题目，我就感觉有点变态了。 ​ 3000吨煤初步设想肯定是要运3次的，因为一次最多只能运1000吨，大概思路就是：在中间设两个暂存点1和2，第一次运到1，留下返程的煤然后回去，装满1000后到1处将煤补满至1000，到2位置，然后卸掉一些煤，留下返回到1的煤，到1后再装上回到矿区的煤，接着再把最后的1000吨煤全装上，到1时将这里剩下的煤都装上（应该是刚好凑成1000的），然后到2后再装上2处剩下的煤（同理应该恰好装满），最后运到市区。方程最后算出来的结果应该是533.3t，有兴趣的自己解下方程试试。其实这里有一个 突破点，每运1公里是要耗1吨煤的，所以一开始就能确定只需要从起点运3次，即每次都装满1000t。 这个解法直接把此问题转为了线性规划，需要一定的数学能力，不是我等数学渣渣可以轻易做到的。。。。 海盗分金​ 这个问题是经济学上有名的模型（甚至还给它建了百度百科。。。），以前没怎么思考过，还好上次离散课上老师稍微提了一下，就说了一下逆推法，不过要注意的是这个题目说的是方案必须大于半数才能通过。找到了方法其实并不难，如果最后剩下4号和5号，5号投反对票，就可以独得金币，所以3号只需要给4号一点金币让他投赞成票就行了(其实就算3号不给4号，他也只能投赞成票，不然他就得死)，然后2号就只需要给4号和5号一点点金币就可以了，同理，1号只需要给3号一点好处，然后4号或5号选一个给一点就行了，这样就能保证自己的利益最大化。重点就是后面的那个人一定会投反对票，以及，逆推 前端后端canvas和svg的区别​ svg，这玩意我听说的很少，查了下后才知道，svg年代久远，已经十几年了，可以自定义标签或属性，用来描述二维图形，canvas倒是看过一些大佬们写的博客，有些许了解。 ​ 从功能上来讲，canvas是画布，画出来的图形为标量图形，所以，canvas可以直接引入jpg或者png类的图片，在实际开发中，canvas也很受欢迎，而且现在canvas的技术也比较成熟了。而svg则是用来描绘矢量图的，所以不支持直接引入普通的图片，但svg的矢量图不会失真，所以可以用来做一些动态的小图标，由于svg的图片不会失真，很适合用来做地图，不管怎么放大都很清晰，比如百度地图。 ​ 在技术层面，canvas绘制的图片是不能被引擎抓取的，一般用javascript，而svg更多是通过标签来实现的，并且支持事件绑定。 javascript中this的用法​ 我印象中，this就是指向当前函数的直接调用者来着，别的没了。。。呃，查了一下，简单点说就是这样： 有对象就指向调用对象 没调用对象就指向全局对象 用new构造就指向新对象 通过 apply 或 call 或 bind 来改变 this 的所指。 具体解释 http/https tcp/udp socket​ 首先说下tcp和udp，两者都是超文本传输协议，属于传输层，但区别是，在IP环境下TCP比UDP传输数据的可靠性更强，所以tcp/ip协议对应的是数据可靠性更高的应用，tcp协议支持的应用层协议主要有：Telent、FTP、SMTP等，而UDP支持的应用层协议主要有：NFS(网络文件系统)、SNMP(简单网络管理协议)、DNS(主域名称系统)、TFTP(通用文件传输协议)等。 ​ socket简单点说就是网络上的两个程序通过一个双向的通信连接实现数据的交换，连接的一端就称为一个socket。而建立网络通信连接至少要一对端口号(socket)，其本质就是API，对TCP/IP的封装，而TCP/IP也要提供可供程序猿做网络开发所用的借口，即socket编程接口。 ​ http与https的区别就在于有无一层加密模块(SSL)，http传输的数据都是明文，很不安全，于是诞生了https，一开始用的版本是SSL，但现在基本上换成了TLS。有一个问题经常会被问到：在浏览器地址栏输入https开头的URL，到整个网页界面显示完毕，发生了什么？其实问的就是https的原理。上个图 ​ 1.客户端输入URL后，发起了一个https的请求，把自身支持的一系列Cipoer Suite(密钥算法套件)发给服务端 ​ 2.服务端接受到客户端所有的Cipher后与自身支持的对比，如果不支持就断开连接，支持的话就从中选出一种加密算法，以证书的形式返回给客户端，证书中会包含公钥、颁证的机构、网址、失效日期等等。 ​ 3、客户端收到服务器响应后会做的事： ​ 3.1 验证证书的合法性。即机构是否合法、是否过期，证书中包含的网站地址是否与正在访问的的地址一致等，证书验证通过后，在浏览器的地址栏会加上一把小锁(Chrome的亲测有效) ​ 3.2 生成随机密码。如果证书验证通过，或者用户接受不了授信的证书，此时浏览器会生成一串随机数，然后用证书中的公钥加密。 ​ 3.3 HASH握手信息。用最开始约定好的HASH方式，把握手消息取HASH值，然后用随机数加密“握手消息+握手消息HASH值(签名)”并一起发给服务端。这里之所以要取握手消息的HASH值，是为了把握手消息做一个签名，用于验证握手消息在传输过程中有没有被修改过。 ​ 4、 服务端拿到客户端传来的密文，用自己的私钥来解密握手消息去除随机数密码，再用随机密码解密握手消息与HASH值，并与传过来的HASH值做对比确认是否一致。然后用随机密码加密一段握手消息(握手消息+握手消息的HASH值)给客户端。 ​ 5、 客户端用随机数解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密，因为这串密钥只有客户端和服务端知道，即使在中间被拦截也无法破解。 非对称加密算法：RSA，DSA/DSS，客户端与服务端相互验证的过程是对称加密 对称加密算法：AES，RC4，3DES 验证通过后，以随机数作为密钥，就是对称加密 HASH算法： MD5，SHA1，SHA256 确认握手消息没有被篡改时 后来​ 今天按照通知去机考，然后被PM发现是技术部的(但实际上我比技术部的平均水平差太多，所以不好意思说自己是技术部的…)最后提前走了，因为想做的板块自身基础的确不好，被告知等技术成熟了，随时接受内推。。。。(被小小地照顾了一下自尊心)]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python爬虫系统学习笔记]]></title>
    <url>%2F2017%2F09%2F16%2Fpython%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在中国大学MOOC那发现了python的爬虫专题系列，可以说是非常非常开心了 Requests库入门​ 在前两次的爬虫体验里面已经用到了这个牛X的库，现在开始对它进行系统点的学习（emmm，个人不是很喜欢看文档，喜欢视频），嵩天老师讲的超级好，之前python入门也看过一点他的视频，感觉超级赞。废话貌似说的有点多。。。。 Requests库安装及七个基本方法​ python提供了安装包管理工具pip，有点类似于Sublime text的Package Control，pip安装的时候注意版本的兼容，建议选择源码编译安装，解压的个人觉得容易出问题，具体请自行百度。有了pip以后就简单了，打开cmd直接输入键入命令pip install requests(此处针对的是windows环境，mac什么的应该更加方便就不说了)。然后检查一下是否已经成功安装。 1234import requestsr = requests.get("http://www.baidu.com")print(r.status_code)print(r.text) 这里我用的是Sublime Text，其实用python自带的idle也挺方便的，但我个人不习惯呃。 如果打印出状态码为200而且输出的百度的文本内容，说明已经requests库已经到位，否则请回去检查一下安装是否出了问题。 其中requests.request()是基础，构造请求。然后其他6个分别是： get：获取HTML网页的主要方法 head: 获取HTML头部信息。 这是最为重要的两个，还有post, put, patch, delete。这6个方法均对应着HTTP协议的操作(可以说requests库就是为HTTP而生的)。 requests.request()​ 标准形式是：requests.request(method, url, **kwargs)，method对应上面的post, put等方法，而**keargs是控制参数。比如这样写： 123kv = &#123;'key1': 'value1','key2': 'value2'&#125;r = requests.request('GET', 'url', params = kv)print(r.url) 会打印出url?key1=value1&amp;key2=value2。最重要的是伪造header，这样写： 12hd = &#123;'user-agent':'Mozilla/5.0'&#125;r = requests.request('GET', 'url', heaers = hd) 其他还有json，data, cookies, auth, timeout等。 requests.get()​ 最常见的写法：r = requests.get(url),r表示的是服务器返回的一个Response对象，url即目标网页，完整的写法是这样的：r = requests.get(url, params = None, **kwargs)，后面两个为选填参数，其中params表示字典或者字节流格式，**keargs表示12个控制的参数。 ​ 有意思的是，response(下面简称r)对象不仅包括服务器返回的信息，也包括requests请求的信息。r的属性主要有这么5个： r.status_code: 200表示成功，404表示失败，更多状态码自己查查看。 r.text: HTTP响应内容的字符串形式。 r.encoding: 编码方式 r.apparent_encoding: 备选编码方式 r.content: HTTP响应内容的二进制形式 其中encoding是根据header里面的charset字段来判断的，如果没有，会默认为ISO-8859-1，此编码下中文会乱码，备选编码方式一般是utf-8。 Requests库的异常​ 嵩老师说了一句：网络连接有风险，异常处理很重要。错误有很多种，DNS查询失败，HTTP 错误，URL错误，超过最大重定向次数导致重定向异常，超时错误等等。只要状态不是200就可以认为是HTTP错误了。 通用代码框架1234567891011121314import requestsdef getHTMLText(url): try: r = requests.get(url) r.raise_for_status()#不是200就会引发异常 r.encoding = r.apparent_encoding return r.text except: return "异常"if __name__ == "__main__": url = "" print(getHTMLText(url)) ​ 不得不说，这代码比较严谨，不像我前面两次的那样，哈哈哈，从开始就养成好习惯。 盗亦有道——robots协议爬虫尺度分类与可能带来的问题​ 网络爬虫是有尺度的，大概可以分为这么三种： 规模小，数据量小，速度不敏感，用requests库即能完成，用来玩转网页的。 中等规模，爬取速度敏感，用scrapy库，爬取系列网站。 大规模，用搜索引擎，定制开发。爬取全网 网络爬虫会带来的三个问题： 性能骚扰：水平太烂的话会给服务器资源造成巨大的压力 法律风险：如果爬来的数据用于商业用途可能要面对法律风险 隐私泄露；爬到正常情况下无权限获取的数据可能会造成个人隐私泄露 网络爬虫的限制来源审查：判断User-Agent，只允许友好爬虫和浏览器访问 发布公告：robots协议，告知爬虫，要求遵守。 robots协议全名叫：Robots Exclusion Standard，网络爬虫排除标准。以协议约定的形式告知爬虫爬取权限，一般在网站的根目录下。来看一下京东的robots协议： 12345678910111213&gt;User-agent: * &gt;Disallow: /?* &gt;Disallow: /pop/*.html &gt;Disallow: /pinpai/*.html?* &gt;User-agent: EtaoSpider &gt;Disallow: / &gt;User-agent: HuihuiSpider &gt;Disallow: / &gt;User-agent: GwdangSpider &gt;Disallow: / &gt;User-agent: WochachaSpider &gt;Disallow: /&gt; *代表所有，/代表根目录 原则上是应该要遵守robots协议的，但如果访问量很小，类似人的上网行为，可以不考虑遵守robots协议。但是！！！如果是商业用途或者爬取全网，必须遵守robots协议，不然出了问题是真的要背法律责任的。 举个栗子保存一张图片： 12345678910111213141516171819import requestsimport osurl = "https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1832529435,1519198910&amp;fm=11&amp;gp=0.jpg"root = "D://pics//"path = root + url.split('/')[-1]try: if not os.path.exists(root): os.mkdir(root) if not os.path.exists(path): r = requests.get(url) with open(path, 'wb') as f: f.write(r.content) f.close() print("文件保存成功") else: print("文件已存在")except: print("爬取失败") root是目录，先检测目录是否存在，如果没有，建一个，然后路径同理，接着打开一个个文件，然后写入r.content(因为content属性是二进制形式的) 嗯？保存一张图片也许没有右键另存为来的快，但成百上千张图片可就无能为力了，特别是还要对图片进行筛选的情况下。(我存的图片男生可以参考，女生可以换一张，哈哈哈哈哈哈哈) Beautiful Soup库入门​ 懒得再新建文章了，直接继续第二章的内容。这次是学习Beautiful Soup库，(形象地称之为煲汤。。。。是的，没错，老师也用了这个词。。。。)自行安装 测试是否安装成功： 1234567import requestsfrom bs4 import BeautifulSoupr = requests.get("http://python123.io/ws/demo.html")demo = r.textsoup = BeautifulSoup(demo, 'html.parser')print(soup.prettify()) 如果打印出来的内容和HTML文档排版一样就OK。 ##Beautiful Soup库的基本元素 ​ 首先，Beautiful Soup库是解析、遍历、维护“标签树”的功能库，这里会对应HTML的框架(Requests库对应HTTP操作)。 ​ Beautiful Soup库的引用一般是BeautifulSoup类，有意思的是，真正用的时候只要写bs4就好，from bs4 import BeautifulSoup,就是这样奇葩。而上面代码中soup = BeautifulSoup(demo, &#39;html.parser&#39;),html.parser则指的是html解析器。用来解析demo的HTML结构。 ​ Beautiful Soup库有如下5个基本元素： Tag: 最基本的信息单元 Name: 标签的名字，格式：.name Attributes: 标签的属性。格式：.attrs NavigableString: 标签内非属性字符串。格式：.string Comment: 标签内部的注释信息，一种特殊的comment类型 Tag 标签​ 任何HTML语法中的标签都可以通过soup.tag访问，比如，soup.title，soup.a等等当存在多个相同的tag时，返回第一个 ​ 每个标签都有自己的名字，可以这样来访问：soup.a.name，还可以查看其上一级标签名字soup.a.parent.name，父亲的父亲同理，儿子的话用children就行. ​ 标签属性是字典形式，可以这样来访问：tag = soup.a,tag.attrs，打印出一个字典后，还可以查看具体的某一个属性，比如tag.attrs[&#39;class&#39;]。 ​ NavigableString 和 Comment不再细说，原理和这个一样。 基于bs4库的HTML内容遍历方法​ 贴一下HTML的基本结构 123456789101112131415161718192021222324&lt;html&gt; &lt;head&gt; &lt;title&gt; This is a python demo page &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class="title"&gt; &lt;b&gt; The demo python introduces several python courses. &lt;/b&gt; &lt;/p&gt; &lt;p class="course"&gt; Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses: &lt;a class="py1" href="http://www.icourse163.org/course/BIT-268001" id="link1"&gt; Basic Python &lt;/a&gt; and &lt;a class="py2" href="http://www.icourse163.org/course/BIT-1001870001" id="link2"&gt; Advanced Python &lt;/a&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 标签树的三个属性可以做到下行遍历： .contents：将tag的所有子节点都存入列表 .children：子节点的迭代类型，用循环遍历子节点 .descendants：子孙节点的迭代烈性，包括所有子孙节点，用循环遍历 遍历子节点和子孙节点： 12345for child in soup.body.children: print(child) for child in soup.body.descendants: print(child) ​ 上行遍历： .parent：节点的父节点 .parents：节点父辈的迭代类型，循环遍历 上行遍历示例： 12345for parent in soup.a.parents: if parent is None: print(parent) else: print(parent.name) 考虑到会遍历到根节点(即soup本身)，所以做了一个判断。 平行遍历： .next_sibling：按照顺序遍历下一个平行节点 .previous_sibling：按照顺序遍历上一个平行节点 .next_siblings：迭代，循环遍历后面所有平行节点 .previous_siblings：迭代，循环遍历前面所有平行节点 注意一个问题：在同一个父节点下才算是平行节点。 比如，这是遍历后续节点： 12for sibling in soup.a.next_sibling: print(sibling) 友好输出：Prettify()​ 很简单，直接print(soup.prettify())，而且支持utf-8编码. 信息标记与提取信息标记上表就好： XML：最早的通用信息标记语言，可扩展性强但是繁琐 JSON：信息有类型，键值对显示，超级适合js的处理，比XML简洁 YAML：信息无类型，文本信息比例高，可读性很好。 作用： XML：Internet上的信息交互与传递 JSON：移动应用端与节点的信息通信 YAML：系统的配置文件 信息提取​ 最好的方法当然是形式解析与关键字内容搜索融合。 ​ 比如，要提取所有的URL链接，只需要这样： 12for link in soup.find_all('a'): print(link.get('href')) ​ find_all(name, attrs, recursive, string, **kwargs)，参数分别是标签名字，标签属性，是否对子孙全部检索(默认为True)，检索区域，及控制参数，既然是匹配，肯定是正则大法好咯。TIPS：(…) 等价于 .find_all()，soup(…) 等价于 soup.find_all() 再举个栗子​ 爬取中国大学排名，很简单的栗子，直接上代码好了： 1234567891011121314151617181920212223242526272829303132333435import requestsfrom bs4 import BeautifulSoupimport bs4def getHTMLText(url): try: r = requests.get(url, timeout = 30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return ""def fillUnivList(ulist, html): soup = BeautifulSoup(html, "html.parser") for tr in soup.find('tbody').children: if isinstance(tr, bs4.element.Tag): tds = tr('td') ulist.append([tds[0].string, tds[1].string, tds[3].string])def printUnivList(ulist, num): tplt = "&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;" print(tplt.format("排名", "学校名称", "总分",chr(12288))) for i in range(num): u = ulist[i] print(tplt.format(u[0], u[1], u[2], chr(12288)))def main(): unifo = [] url = 'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html' html = getHTMLText(url) fillUnivList(unifo, html) printUnivList(unifo, 30)#30所大学main() ​ tplt和chr(12288)是为了使输出稍微美观一点而做的一点小优化。中间要判断是否是bs4.element.tag类型，所以引用了bs4库。(吐槽一下python的format是真的强，还有，南航居然排到了29诶。。。) Re(正则表达式)入门​ 前面已经有过接触，正则表达式是一种针对字符串表达“简洁”和“特征”思想的工具，用来判断某字符串的的特征归属，可以用来替换或者匹配字符串。我决定直接贴图… ​ 调用方式：import re，re库一般匹配raw string(原生字符串类型r’text’)，即不包括对转义符再次转义的字符串。re库也可以直接用string类型来表示，但会更繁琐，如果正则包含转义符时，用raw string类型更好。 ​ 主要函数： ​ 大部分函数都是三个参数：pattern, string, flags。pattern即为构造的正则表达式，string为待匹配字符串，flags为控制参数，其中split函数还有一个maxsplit(最大切割次数)，放在string和flags中间。sub函数更特殊，re.sub(pattern, repl, string, count = 0, flags = 0), 另外常用的正则可以经过编译使用：pat = re.compile(pattern, flags), rst = pat.search(&#39;string&#39;),可以提升运行速度。返回的是match对象，它的属性如下： ​ ​ 属性的方法： ​ 另外，在默认返回一个对象而又能同时匹配多个字符串时，默认返回最长的那个(贪婪匹配)，如果有 需要，作最短匹配，加一个?就可以了。 ​ 定向爬取淘宝商品(不要不加限制地爬，robots协议不允许….) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsimport redef getHTMLText(url): try: r = requests.get(url, timeout = 30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return ""def parsePage(ilt, html): try: plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"', html) tlt = re.findall(r'\"raw_title\"\:\".*?\"', html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price, title]) except: print("")def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号", "价格", "商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1]))def main(): goods = '书包' depth = 3 start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] for i in range(depth): try: url = start_url + '&amp;s=' + str(44 * i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList)main() ​ 上一段比较优美的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import requestsfrom bs4 import BeautifulSoupimport tracebackimport re def getHTMLText(url, code="utf-8"): try: r = requests.get(url) r.raise_for_status() r.encoding = code return r.text except: return "" def getStockList(lst, stockURL): html = getHTMLText(stockURL, "GB2312") soup = BeautifulSoup(html, 'html.parser') a = soup.find_all('a') for i in a: try: href = i.attrs['href'] lst.append(re.findall(r"[s][hz]\d&#123;6&#125;", href)[0]) except: continue def getStockInfo(lst, stockURL, fpath): count = 0 for stock in lst: url = stockURL + stock + ".html" html = getHTMLText(url) try: if html=="": continue infoDict = &#123;&#125; soup = BeautifulSoup(html, 'html.parser') stockInfo = soup.find('div',attrs=&#123;'class':'stock-bets'&#125;) name = stockInfo.find_all(attrs=&#123;'class':'bets-name'&#125;)[0] infoDict.update(&#123;'股票名称': name.text.split()[0]&#125;) keyList = stockInfo.find_all('dt') valueList = stockInfo.find_all('dd') for i in range(len(keyList)): key = keyList[i].text val = valueList[i].text infoDict[key] = val with open(fpath, 'a', encoding='utf-8') as f: f.write( str(infoDict) + '\n' ) count = count + 1 print("\r当前进度: &#123;:.2f&#125;%".format(count*100/len(lst)),end="") except: count = count + 1 print("\r当前进度: &#123;:.2f&#125;%".format(count*100/len(lst)),end="") continue def main(): stock_list_url = 'http://quote.eastmoney.com/stocklist.html' stock_info_url = 'https://gupiao.baidu.com/stock/' output_file = 'D:/BaiduStockInfo.txt' slist=[] getStockList(slist, stock_list_url) getStockInfo(slist, stock_info_url, output_file) main() ​ 动态优化好评。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取网易云热评]]></title>
    <url>%2F2017%2F09%2F14%2F%E7%88%AC%E5%8F%96%E7%BD%91%E6%98%93%E4%BA%91%E7%83%AD%E8%AF%84%2F</url>
    <content type="text"><![CDATA[爬取网易云热评，用python上手真心简单，怪不得有人总说“人生苦短，我用python“。 ​ 爬网页数据的话一般是解析html的结构，这种适合抓取html里面多种元素的情况，而我只是想看个热评而已，可以另辟蹊径：直接搞到评论的API，然后获取json返回，最后解析就行了。((￣▽￣)~所以说很简单咦) 找到API​ 打开网易云网页版，输入自己想抓取热评的歌曲，然后用开发者工具，输入comments就能找到评论API的url了，点response就能看到json格式的评论了。 那个数字代表的应该就是这首歌的id了，后面有一个叫csrf_tocken的参数，显示为空，那就不管它了。请求方式依然是post，然后表单那里还有两个加密过的参数，分别是params和encSecKey，一开始以为是每首歌都会对应这么一个参数，后来发现并不是，刷新了页面后却发现这个参数变了，可能是对应评论页码加密的？ 获取json​ 再一次慨叹一下python库的强大，不信？那你看代码长度咯。 1234567import requestsimport jsonurl = 'http://music.163.com/weapi/v1/resource/comments/R_SO_4_63650?csrf_token='param = &#123;'params':'', 'encSecKey':''&#125;r = requests.post(url, param)data = r.text #拿到json 这样就拿到评论的json格式了(PS：那两个参数实在是太长了，贴出来看的我不舒服，写的时候自行粘贴上去就好)。 解析json拿到了json后自然要解析一波，python的json库可以很轻易地帮我们解决这个问题。首先从开发者工具那直接复制json，拿到这里在线json校验格式化工具,看一下json的具体形式(直接那么长一串简直反人类没法看)。 舒服多了23333。主要信息有nickname，content，likedCount把这三个拎出来就差不多了。(id, 内容, 点赞量)json库不会用的话去查一下就好，上手很容易的，然后直接解析后打印就好了。(就一页热评，懒得写入文件了。)稍微完整的代码： 1234567891011121314151617import requestsimport jsonurl = 'http://music.163.com/weapi/v1/resource/comments/R_SO_4_63650?csrf_token='param = &#123;'params':'', 'encSecKey':''&#125;r = requests.post(url, param)data = r.text #拿到jsonjsOb = json.loads(data)hotComments = jsOb['hotComments']for i in range(len(hotComments)): user_nickname = hotComments[i]['user']['nickname'] likedCount = hotComments[i]['likedCount'] content = hotComments[i]['content'] print('评论',str(i+1),' 用户名:',user_nickname,'喜 欢：',str(likedCount)) print('-----------------------------') print(content) 这样就OK咯。贴一下我抓的《独家记忆》第一页热评。 emmmmm，后期再更新一下抓全部评论和整个歌单的热评好了。不过那样数据会比较大，时间相应也挺长的，不太敢多开线程加快速度，怕触发反爬虫机制ip被封了就GG了。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫初体验]]></title>
    <url>%2F2017%2F09%2F11%2Fpython%E7%88%AC%E8%99%AB%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[python基础部分看了一遍后，感觉需要找点乐子，于是想到去学一点爬虫批量抓图片，嘿嘿嘿 先介绍一下python的两大利器(库)：requests和re(emmmm，可别以为后面那个是前者的缩写，其实半毛钱关系都没有)。requests库有多厉害呢？简单地说就是python 的http库，可以帮开发人员省很多代码，具体有多厉害呢？戳这里 。而re库则是regexp的缩写，python提供了相当强大的正则表达式引擎，很大程度上简化了python代码，稍微详细一点的介绍在这里 。好了以下是正文 获取网页12345import requestsheader = &#123;'User-Agent':'xxx'&#125;url='https://www.xxxxx'r = requests.get(url,headers = header)txt = r.text 先引入 requests模块，然后header是用来伪造浏览器UA的，用Chrom的话直接去开发者工具那找一下自己的Request Headers就好，url则是要抓取的网页地址，传入这两个参数给.get函数后，就能拿到初步结果 解析图片嗯，别忘了自己是来抠图的，上面那个函数写完后，一个print(text)出来的却是一大坨HTML，这当然不是我要的，去网上找了一下发现Python还有个叫Beautiful Soup的东西(→_→我第一反应是煲汤)，这个库是用来解析HTML结构的，看了几眼觉得有点复杂，这时候想起了正则大法，图片链接不都是有明显特征的嘛，于是考虑正则。匹配以https://开头以.jpg类结尾的，并作最短匹配，然后全部累塞进数组。 12345678910jpg = re.compile(r'https://[^\s]*?\.jpg')jpeg = re.compile(r'https://[^\s]*?\.jpeg')gif = re.compile(r'https://[^\s]*?\.gif')png = re.compile(r'https://[^\s]*?\.png')imgs=[]imgs+=jpg.findall(txt)imgs+=jpeg.findall(txt)imgs+=gif.findall(txt)imgs+=png.findall(txt) 下载图片request用来存储get的url，判断状态码是否正常，如果正常就写入文件。 12345678910def download(url): request = requests.get(url) if req.status_code == requests.codes.ok: name = url.split('/')[-1] f = open("./"+name,'wb') f.write(req.content) f.close() return True else: return False 写好下载函数后就可以写循环来挨个下载了 12345678errors = []for img_url in imgs: if download(img_url): print("download :"+img_url) else: errors.append(img_url)print("error urls:")print(errors) 还可以设置一个urls数组，同时下载多个网页的图，download函数也可以加个文件夹名，这样就可以了。 最后我干了什么呢？上个图，自己体会 以上代码需要优化，直接用的话还有些不完善，需要根据实际的网站来调整。 多说一句​ 想起一位厉害小姐姐的训示：少年的你的梦想应该是拯救世界，怎么能每天爬一些日韩女人啊爆照贴妹子什么的。 ​ (逃：]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10改掉C盘下的中文用户名]]></title>
    <url>%2F2017%2F09%2F11%2Fwin10%E6%94%B9%E6%8E%89C%E7%9B%98%E4%B8%8B%E7%9A%84%E4%B8%AD%E6%96%87%E7%94%A8%E6%88%B7%E5%90%8D%2F</url>
    <content type="text"><![CDATA[昨天早上一起来，正愉快地折腾着，突然发现有些报错无论如何都解决不了，有的虽然影响不大但看起来很烦，搜索一波后发现其实是我c盘下中文路径搞的鬼， 嗯，话不多说就是干。 搜了一会儿后发现这个世界上的误解还真多，居然有这么多人以为是改本地的管理员账号，毫不客气地给了一个”踩”。终于在知乎下面找到了一点眉目。（还是比百度强） 懒得传图，直接复制一下第一个答案： 假设原用户名为 小明，需改为 xiaoming。 1.先新建一个管理员账户，然后注销当前用户，以新建的管理员账户登录； 2.重命名 c:\Users\小明 为 c:\Users\xiaoming； 3.打开注册表编辑器（win+R 输入 regedit），定位到 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList 的某一子项（S-1-5-21… 开头的），将“数据名称”为 ProfileImagePath 的“数值数据”内容 C:\Users\小明 改为 C:\Users\xiaoming ； 4.改后以原账户登录并删除新建账户。 咦，下面有80+评论，去瞄了一眼，虽然成功的人也有，但失败的也不少，我还是没有直接按照这个方法改，但大概思路已经清楚了，即临时存一下当前中文名下的东西，拿到改名权限后改掉中文名，再换回来。 在下面的回答中找到了一位小姐姐的博客园链接，给链接的人称此方法很成功，嗯，大概说一下这个方法的步骤： 改注册表用win+r打开命令窗口，输入regedit，把系统注册表调出来，然后去这个地方 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList 依次点开那些以S-1-5-开头的项，找到ProfileImagePath，把C：\Users\中文名 改成C：\Users\English name 记得把所有的Path都改掉，确认后关掉注册表。 改文件名打开cmd后发现依旧是中文名，这个当然，因为只是改完了注册表，文件权限还没转移，于是重启电脑。 启动后发现壁纸什么的都不一样了，这是因为当前Users 已经变成了TEMP，即临时系统账户。这时候系统会提醒你无法连接到你的账户，嗯，因为你的注册表已经改了，点击隐藏， 别点注销，然后按ctrl + e 打开我的电脑，找到C：\Users\中文名，修改文件名，点击给予权限。然后重启电脑就大功告成啦 可能有的问题更改之前就已经安装的软件可能依旧会显示中文路径，如果不报错的话就没关系，（强迫症选手请重装软件）。其他的问题好像没了，那个小姐姐还给了测试。 这是小姐姐的文章链接]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大和子序列]]></title>
    <url>%2F2017%2F09%2F10%2F%E6%9C%80%E5%A4%A7%E5%92%8C%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[今天来看一个简单的问题，求最大的和子序列/求最大和子数组 题目是这样的：已知序列：-2, 11, -4, 13, -5, 2, -5, -3, 12, -9，求此序列的最大子序列和 ​ 其实题目很简单，但智障的我一开始弄错了，直接把所有负数提出去然后把剩下的相加，这也太简单了点吧。。。。后来想想，貌似不太对，于是，重来。一共用了三种方法。(名字都是我瞎写的) 方法一：暴力法​ 没错，就是直接把这个数组的所有子序列的和都算一遍，跟初始最大值比较，代码如下： 12345678910111213141516171819int main()&#123; int a[] = &#123;-2,11,-4,13,-5,2,-5,-3,12,-9&#125;; int maxSum = a[0],n = sizeof(a)/sizeof(a[0]); for(int i = 0;i &lt; n;i++)//子数组长度 &#123; for(int j = 0;j &lt; n;j++)//子数组开始的位置，数组下标 &#123; int sum = 0;//记录当前子数组和 for(int k = j;k &lt; n&amp;&amp;k &lt; j + i;k++)//求和 &#123; sum += a[k]; &#125; if(sum &gt; maxSum) maxSum = sum; &#125; &#125; cout &lt;&lt; "子序列的最大和是："&lt;&lt; maxSum &lt;&lt; endl; return 0;&#125; 对，就是这么暴力，效率很低，时间复杂度：O(n³) 方法二：递进求和​ 不断求出以a[i]开头的子序列的和，并在求的过程中记录好最大的子序列的和，函数代码如下： 1234567891011121314int maxSubArraySum(int *arr,int n)&#123; int i,j,maxSum = 0,sum; for(i = 0;i &lt; n;i++)//子数组开始位置 &#123; sum = 0; for(j = i;j &lt; n;j++) &#123; sum += arr[j]; if(sum &gt; maxSum) maxSum = sum;//求和并比较 &#125; &#125; return maxSum; &#125; 相对方法一来说，方法二减少了一次遍历，时间复杂度为：O(n²) 方法三：判断求和​ 仔细想一下，一个数，加上一个负数会变小，加上零不变，加上正数才会变大，对，就是这么简单的道理，就可以用来优化这个题的算法了。从a[0]开始累加，如果大于初始值，就替换，如果和小于零，直接舍弃，然后是a[1]，函数代码如下： 1234567891011int maxSubArraySum_2(int *arr,int n)&#123; int i,maxSum = arr[0],sum = 0; for(i = 0;i &lt; n;i++)//子数组开始位置 &#123; sum += arr[i]; if(sum &gt; maxSum) maxSum = sum;//记录最大累加和 if(sum &lt; 0) sum = 0;//累加和小于零的不要 &#125; return maxSum;&#125; 这样的话，只要对数组遍历一次就能解决了，时间复杂度降为O(n)，最简单道理往往有意想不到的效果，哈哈哈哈。 另外，加个tips: n = sizeof(a)/sizeof(a[0])，Strlen()函数不适用于整数数组]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于排序]]></title>
    <url>%2F2017%2F09%2F10%2F%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[我目前已经学会的排序以及理解（会不断更新） 先贴个交换函数： 123456void Swap(int A[],int i,int j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp;&#125; 冒泡排序这是进大学后c语言课本上介绍的第一个排序，也是最简单，最容易理解的一个排序，顾名思义，就像冒泡一样，一次一次把最值往最后面放，完成排序。函数代码如下： 12345678910111213void BubbleSort(int A[],int n)&#123; for(int j = 0;j &lt; n - 1;j++) &#123; for(int i = 0;i &lt; n - 1 - j;i++) &#123; if(A[i] &gt; A[i + 1]) //从小到大排序 &#123; Swap(A,i,i + 1); &#125; &#125; &#125;&#125; 冒泡排序是稳定的，因为即使有相同的数也不会打乱原来是次序，平均时间复杂度：O(n²)。 选择排序​ 相比于相邻交换的冒牌排序，选择排序是通过从未排序的数据元素中选出最值放在该序列的起始位置，直到所有元素排完，同样需要循环两次，无法优化时间。代码如下： 123456789101112131415161718void SelectionSort(int A[],int n)&#123; for(int i = 0;i &lt; n - 1;i++) &#123; int min = i; for(int j = i + 1;j &lt; n;j++) &#123; if(A[j] &lt; A[min]) &#123; min = j; &#125; &#125; if(min != i) &#123; Swap(A,min,i); &#125; &#125;&#125; 选择排序是不稳定的，因为如果有相同的数的话是可以改变原来次序的，平均时间复杂度：O(n²)。 插入排序​ 看到这个方法，我的第一反应便是抓扑克牌，原理和抓牌原理一样，即，左手上的牌是已经排好序了的，将左手上的牌依次和抓到的牌比较，如果大于抓到的牌便把这张牌左移，然后插入抓到的牌。函数代码如下: 1234567891011121314void InsertionSort(int A[],int n)&#123; for(int i = 1;i &lt; n;i++) &#123; int get = A[i]; int j = i - 1; while(j &gt;= 0 &amp;&amp; A[j] &gt; get) &#123; A[j + 1] = A[j]; j--; &#125; A[j + 1] = get; &#125;&#125; 相同的牌不影响顺序，插入排序是稳定的，平均时间复杂度：O(n²)。 快速排序​ 快速排序基于一种二分的思想，即以一个数为基准数，不断将数组二分，最终当所有基准数都归位后，排序也就完成了。快速排序之所以较快，是因为每次交换都是跳跃式的。函数代码如下：(千万注意下标是从0开始的 ) 12345678910111213141516171819202122void quicksort(int arr[],int left,int right)&#123; if(left &gt; right) return; int i,j,temp; temp = arr[left];//temp为基准数 i = left; j = right; while(i != j) &#123; //基准数在左边，所以要从右边开始找 while(arr[j] &gt;= temp &amp;&amp; i &lt; j)j--; //再从左往右找 while(arr[i] &lt;= temp &amp;&amp; i &lt; j)i++; //如果没有相遇。就交换 if(i &lt; j) Swap(arr,i,j); &#125; arr[left] = arr[i]; arr[i] = temp; quicksort(arr,left,i - 1);//继续处理左边 quicksort(arr,i + 1,right);//继续处理右边 &#125; 这两个等我会了再写233333 归并排序归并排序的原理是分治法，简单点说就是把一个序列拆成多个子序列，将子序列排好序后，再将其合并为一个序列。归并排序的效率也比较可观，达到了o(NlogN)。 1234567891011121314void mergeArray(int a[], int first, int mid, int last, int temp[])&#123; int i = first, j = mid + 1; int m = mid, n = last, k = 0; while(i &lt;= m &amp;&amp; j &lt;= n) &#123; if(a[i] &lt;= a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; &#125; while(i &lt;= m) temp[k++] = a[i++]; while(j &lt;= n) temp[k++] = a[j++]; for(i = 0;i &lt; k;i++) a[first + i] = temp[i];&#125; 12345678910void mergeSort(int a[], int first, int last, int temp[])&#123; if(first &lt; last) &#123; int mid = (first + last) / 2; mergeSort(a, first, mid, temp);//处理左边 mergeSort(a, mid + 1,last, temp);//处理右边 mergeArray(a, first, mid, last, temp);//合并 &#125;&#125; 堆排序]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将Sublime配置成python环境]]></title>
    <url>%2F2017%2F07%2F19%2F%E5%B0%86Sublime%E9%85%8D%E7%BD%AE%E6%88%90pythona%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[刚开始学python的时候，用的是python自带的IDLE.bat，总感觉太简陋，字体很小，也没有自动补全的东西，之前有段时间在写网页玩，一直用着Sublime text 3——这款轻量而且扩展性很强而且颜值高的编辑器，想着在St3上写python岂不是美滋滋了，于是搜索了一波，最后发现了St3直接提供了一个强大的插件——Anaconda，可以将St3打造成一个python IDE。 下载好python和Sublime text 3打开安装包管理工具（这个还不会的小白请自行百度，不太好截图），输入Install Package，然后输入Anaconda，回车安装保存文件名为.py后缀后就会发现写python会有高亮和自动补全了。可能遇到的问题 用ST3一打开python文件就有这个问题，发现后面写着try to set the ‘swallow_startup_errors’ to ‘true’ 然后发现这个json的设置居然是在SublimeREPL里面而不是Anaconda。。。 好吧不管了 先试试再说 进入Preferences–package settings–&gt;SublimeRPEL–&gt;settings user 键入： “swallow_startup_errors”: true, 保存后重启。然鹅并没有什么卵用…能解决这个问题的大佬可以来教一下 还有可能遇到这种情况： 大白框和小白点，猜想可能是因为python的缩进？ （你自己喜欢的话就没关系，不用改了） 我个人看着很不舒服，搜索后发现这个是默认开启的功能，点开Preferences-Pacakage Settings-Anaconda-Settings user 加上如下一句： 即可解决这个问题. 然后就可以愉快地用St3写Python了。（ctrl + B 即可运行） 嗯，故事就这么结束了么？当然没有 然后就遇到了第一个坑：Input无效 Sublime似乎无法完成input这种交互式命令 解决方法请参考此链接]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Sublime</tag>
      </tags>
  </entry>
</search>
